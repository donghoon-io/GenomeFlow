var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key2, value2) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key2] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target, mod2));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet = (obj, member, value2, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
  toFormData: () => toFormData
});
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match2 = m2[2] || m2[3] || "";
  let filename = match2.slice(match2.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body2, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData();
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new File(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body2) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var import_node_worker_threads, s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
  "node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js"() {
    import_node_worker_threads = require("worker_threads");
    init_install_fetch();
    globalThis.DOMException || (() => {
      const port = new import_node_worker_threads.MessageChannel().port1;
      const ab = new ArrayBuffer(0);
      try {
        port.postMessage(ab, [ab, ab]);
      } catch (err) {
        return err.constructor;
      }
    })();
    s = 0;
    S = {
      START_BOUNDARY: s++,
      HEADER_FIELD_START: s++,
      HEADER_FIELD: s++,
      HEADER_VALUE_START: s++,
      HEADER_VALUE: s++,
      HEADER_VALUE_ALMOST_DONE: s++,
      HEADERS_ALMOST_DONE: s++,
      PART_DATA_START: s++,
      PART_DATA: s++,
      END: s++
    };
    f = 1;
    F = {
      PART_BOUNDARY: f,
      LAST_BOUNDARY: f *= 2
    };
    LF = 10;
    CR = 13;
    SPACE = 32;
    HYPHEN = 45;
    COLON = 58;
    A = 97;
    Z = 122;
    lower = (c) => c | 32;
    noop = () => {
    };
    MultipartParser = class {
      constructor(boundary) {
        this.index = 0;
        this.flags = 0;
        this.onHeaderEnd = noop;
        this.onHeaderField = noop;
        this.onHeadersEnd = noop;
        this.onHeaderValue = noop;
        this.onPartBegin = noop;
        this.onPartData = noop;
        this.onPartEnd = noop;
        this.boundaryChars = {};
        boundary = "\r\n--" + boundary;
        const ui8a = new Uint8Array(boundary.length);
        for (let i2 = 0; i2 < boundary.length; i2++) {
          ui8a[i2] = boundary.charCodeAt(i2);
          this.boundaryChars[ui8a[i2]] = true;
        }
        this.boundary = ui8a;
        this.lookbehind = new Uint8Array(this.boundary.length + 8);
        this.state = S.START_BOUNDARY;
      }
      write(data) {
        let i2 = 0;
        const length_ = data.length;
        let previousIndex = this.index;
        let { lookbehind, boundary, boundaryChars, index: index2, state, flags } = this;
        const boundaryLength = this.boundary.length;
        const boundaryEnd = boundaryLength - 1;
        const bufferLength = data.length;
        let c;
        let cl;
        const mark = (name) => {
          this[name + "Mark"] = i2;
        };
        const clear = (name) => {
          delete this[name + "Mark"];
        };
        const callback = (callbackSymbol, start2, end, ui8a) => {
          if (start2 === void 0 || start2 !== end) {
            this[callbackSymbol](ui8a && ui8a.subarray(start2, end));
          }
        };
        const dataCallback = (name, clear2) => {
          const markSymbol = name + "Mark";
          if (!(markSymbol in this)) {
            return;
          }
          if (clear2) {
            callback(name, this[markSymbol], i2, data);
            delete this[markSymbol];
          } else {
            callback(name, this[markSymbol], data.length, data);
            this[markSymbol] = 0;
          }
        };
        for (i2 = 0; i2 < length_; i2++) {
          c = data[i2];
          switch (state) {
            case S.START_BOUNDARY:
              if (index2 === boundary.length - 2) {
                if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else if (c !== CR) {
                  return;
                }
                index2++;
                break;
              } else if (index2 - 1 === boundary.length - 2) {
                if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
                  state = S.END;
                  flags = 0;
                } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
                  index2 = 0;
                  callback("onPartBegin");
                  state = S.HEADER_FIELD_START;
                } else {
                  return;
                }
                break;
              }
              if (c !== boundary[index2 + 2]) {
                index2 = -2;
              }
              if (c === boundary[index2 + 2]) {
                index2++;
              }
              break;
            case S.HEADER_FIELD_START:
              state = S.HEADER_FIELD;
              mark("onHeaderField");
              index2 = 0;
            case S.HEADER_FIELD:
              if (c === CR) {
                clear("onHeaderField");
                state = S.HEADERS_ALMOST_DONE;
                break;
              }
              index2++;
              if (c === HYPHEN) {
                break;
              }
              if (c === COLON) {
                if (index2 === 1) {
                  return;
                }
                dataCallback("onHeaderField", true);
                state = S.HEADER_VALUE_START;
                break;
              }
              cl = lower(c);
              if (cl < A || cl > Z) {
                return;
              }
              break;
            case S.HEADER_VALUE_START:
              if (c === SPACE) {
                break;
              }
              mark("onHeaderValue");
              state = S.HEADER_VALUE;
            case S.HEADER_VALUE:
              if (c === CR) {
                dataCallback("onHeaderValue", true);
                callback("onHeaderEnd");
                state = S.HEADER_VALUE_ALMOST_DONE;
              }
              break;
            case S.HEADER_VALUE_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              state = S.HEADER_FIELD_START;
              break;
            case S.HEADERS_ALMOST_DONE:
              if (c !== LF) {
                return;
              }
              callback("onHeadersEnd");
              state = S.PART_DATA_START;
              break;
            case S.PART_DATA_START:
              state = S.PART_DATA;
              mark("onPartData");
            case S.PART_DATA:
              previousIndex = index2;
              if (index2 === 0) {
                i2 += boundaryEnd;
                while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
                  i2 += boundaryLength;
                }
                i2 -= boundaryEnd;
                c = data[i2];
              }
              if (index2 < boundary.length) {
                if (boundary[index2] === c) {
                  if (index2 === 0) {
                    dataCallback("onPartData", true);
                  }
                  index2++;
                } else {
                  index2 = 0;
                }
              } else if (index2 === boundary.length) {
                index2++;
                if (c === CR) {
                  flags |= F.PART_BOUNDARY;
                } else if (c === HYPHEN) {
                  flags |= F.LAST_BOUNDARY;
                } else {
                  index2 = 0;
                }
              } else if (index2 - 1 === boundary.length) {
                if (flags & F.PART_BOUNDARY) {
                  index2 = 0;
                  if (c === LF) {
                    flags &= ~F.PART_BOUNDARY;
                    callback("onPartEnd");
                    callback("onPartBegin");
                    state = S.HEADER_FIELD_START;
                    break;
                  }
                } else if (flags & F.LAST_BOUNDARY) {
                  if (c === HYPHEN) {
                    callback("onPartEnd");
                    state = S.END;
                    flags = 0;
                  } else {
                    index2 = 0;
                  }
                } else {
                  index2 = 0;
                }
              }
              if (index2 > 0) {
                lookbehind[index2 - 1] = c;
              } else if (previousIndex > 0) {
                const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
                callback("onPartData", 0, previousIndex, _lookbehind);
                previousIndex = 0;
                mark("onPartData");
                i2--;
              }
              break;
            case S.END:
              break;
            default:
              throw new Error(`Unexpected state entered: ${state}`);
          }
        }
        dataCallback("onHeaderField");
        dataCallback("onHeaderValue");
        dataCallback("onPartData");
        this.index = index2;
        this.state = state;
        this.flags = flags;
      }
      end() {
        if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
          this.onPartEnd();
        } else if (this.state !== S.END) {
          throw new Error("MultipartParser.end(): stream ended unexpectedly");
        }
      }
    };
  }
});

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type2 = meta[0] || "text/plain";
  let typeFull = type2;
  for (let i2 = 1; i2 < meta.length; i2++) {
    if (meta[i2] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i2]}`;
      if (meta[i2].indexOf("charset=") === 0) {
        charset = meta[i2].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type2;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function formDataToBlob(F2, B = Blob$1) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F2.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, "\r\n")}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, "\r\n"));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (!(body instanceof import_node_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value2, index2, array2) => {
    if (index2 % 2 === 0) {
      result.push(array2.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name, value2]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value2));
      return true;
    } catch {
      return false;
    }
  }));
}
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = (0, import_net.isIP)(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (/^(.+\.)*localhost$/.test(url.host)) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy = token;
    }
  }
  return policy;
}
async function fetch2(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options: options2 } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dataUriToBuffer(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? import_node_https.default : import_node_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_node_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL, options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s3) => {
        let endedWithEventsCount;
        s3.prependListener("end", () => {
          endedWithEventsCount = s3._eventsCount;
        });
        s3.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s3._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location2 = headers.get("Location");
        const locationURL = location2 === null ? null : new URL(location2, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_node_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve2(fetch2(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_node_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_node_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_node_stream.pipeline)(response_, new import_node_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflate(), reject) : (0, import_node_stream.pipeline)(body, import_node_zlib.default.createInflateRaw(), reject);
          response = new Response2(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_node_stream.pipeline)(body, import_node_zlib.default.createBrotliDecompress(), reject);
        response = new Response2(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
function installFetch() {
  Object.defineProperties(globalThis, {
    fetch: {
      enumerable: true,
      configurable: true,
      value: fetch2
    },
    Response: {
      enumerable: true,
      configurable: true,
      value: Response2
    },
    Request: {
      enumerable: true,
      configurable: true,
      value: Request2
    },
    Headers: {
      enumerable: true,
      configurable: true,
      value: Headers2
    }
  });
}
var import_node_http, import_node_https, import_node_zlib, import_node_stream, import_node_util, import_node_url, import_net, commonjsGlobal, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _parts, _type, _size, _a, _Blob, Blob2, Blob$1, _lastModified, _name, _a2, _File, File, t, i, h, r, m, f2, e, x, _d, _a3, FormData, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, INTERNALS$2, Body, clone, getNonSpecFormDataBoundary, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers2, redirectStatus, isRedirect, INTERNALS$1, Response2, getSearch, ReferrerPolicy, DEFAULT_REFERRER_POLICY, INTERNALS, isRequest, Request2, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    import_node_http = __toESM(require("http"), 1);
    import_node_https = __toESM(require("https"), 1);
    import_node_zlib = __toESM(require("zlib"), 1);
    import_node_stream = __toESM(require("stream"), 1);
    import_node_util = require("util");
    import_node_url = require("url");
    import_net = require("net");
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports2) {
      (function(global2, factory) {
        factory(exports2);
      })(commonjsGlobal, function(exports3) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop4() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x3) {
          return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
        }
        const rethrowAssertionErrorRejection = noop4;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value2) {
          return originalPromiseResolve(value2);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F2, V, args) {
          if (typeof F2 !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F2, V, args);
        }
        function promiseCall(F2, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F2, V, args));
          } catch (value2) {
            return promiseRejectedWith(value2);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i2 = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i2 !== elements.length || node._next !== void 0) {
              if (i2 === elements.length) {
                node = node._next;
                elements = node._elements;
                i2 = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i2]);
              ++i2;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x3) {
          return typeof x3 === "number" && isFinite(x3);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x3) {
          return typeof x3 === "object" || typeof x3 === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x3, context) {
          if (typeof x3 !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject2(x3) {
          return typeof x3 === "object" && x3 !== null || typeof x3 === "function";
        }
        function assertObject(x3, context) {
          if (!isObject2(x3)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x3, position, context) {
          if (x3 === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x3, field, context) {
          if (x3 === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value2) {
          return Number(value2);
        }
        function censorNegativeZero(x3) {
          return x3 === 0 ? 0 : x3;
        }
        function integerPart(x3) {
          return censorNegativeZero(MathTrunc(x3));
        }
        function convertUnsignedLongLongWithEnforceRange(value2, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x3 = Number(value2);
          x3 = censorNegativeZero(x3);
          if (!NumberIsFinite(x3)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x3 = integerPart(x3);
          if (x3 < lowerBound || x3 > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x3) || x3 === 0) {
            return 0;
          }
          return x3;
        }
        function assertReadableStream(x3, context) {
          if (!IsReadableStream(x3)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readRequests")) {
            return false;
          }
          return x3 instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value2) {
            const returnSteps = () => this._returnSteps(value2);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value2) {
            if (this._isFinished) {
              return Promise.resolve({ value: value2, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value2);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value: value2, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value: value2, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value2) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value2);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x3._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a5) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name) {
          return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x3) {
          return x3 !== x3;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice2 = new ArrayBuffer(length);
          CopyDataBlockBytes(slice2, 0, buffer, begin, length);
          return slice2;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value2, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value: value2, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry4 = this._queue.shift();
              this._queueTotalSize -= entry4.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry4.buffer, entry4.byteOffset, entry4.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableByteStream")) {
            return false;
          }
          return x3 instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x3 instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableByteStreamControllerError(controller, e3);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              readIntoRequest._errorSteps(e3);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e3 = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e3);
              throw e3;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              if (controller._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerShiftPendingPullInto(controller);
              }
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e3) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          const viewByteLength = view.byteLength;
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableByteStreamControllerError(controller, r2);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name) {
          return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e3) => rejectPromise(e3)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readIntoRequests")) {
            return false;
          }
          return x3 instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          const size = init3 === null || init3 === void 0 ? void 0 : init3.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type2 = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start2, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type: type2
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x3, context) {
          if (!IsWritableStream(x3)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value2) {
          if (typeof value2 !== "object" || value2 === null) {
            return false;
          }
          try {
            return typeof value2.aborted === "boolean";
          } catch (_a5) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type2 = underlyingSink.type;
            if (type2 !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_writableStreamController")) {
            return false;
          }
          return x3 instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a5;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a5 = stream._writableStreamController._abortController) === null || _a5 === void 0 ? void 0 : _a5.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_ownerWritableStream")) {
            return false;
          }
          return x3 instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e3 = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e3);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          abortReason: { enumerable: true },
          signal: { enumerable: true },
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledWritableStream")) {
            return false;
          }
          return x3 instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r2) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r2);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value2 = PeekQueueValue(controller);
          if (value2 === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value2);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name) {
          return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name) {
          return new TypeError("Cannot " + name + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a5) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name) {
            this.message = message || "";
            this.name = name || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop4);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e3 = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e3);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledReadableStream")) {
            return false;
          }
          return x3 instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e3) => {
            ReadableStreamDefaultControllerError(controller, e3);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e3) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e3);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r2) => {
            ReadableStreamDefaultControllerError(controller, r2);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgain = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              readAgain = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgain = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgain) {
                    pullAlgorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r2) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let readAgainForBranch1 = false;
          let readAgainForBranch2 = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r2) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r2);
              ReadableByteStreamControllerError(branch2._readableStreamController, r2);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  readAgainForBranch1 = false;
                  readAgainForBranch2 = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  reading = false;
                  if (readAgainForBranch1) {
                    pull1Algorithm();
                  } else if (readAgainForBranch2) {
                    pull2Algorithm();
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              readAgainForBranch1 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              readAgainForBranch2 = true;
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type2 = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start2, original, `${context} has member 'start' that`),
            type: type2 === void 0 ? void 0 : convertReadableStreamType(type2, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type2, context) {
          type2 = `${type2}`;
          if (type2 !== "bytes") {
            throw new TypeError(`${context} '${type2}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type2;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable2 = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable2, "readable", "ReadableWritablePair");
          assertReadableStream(readable2, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable: readable2, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e3) {
              return promiseRejectedWith(e3);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_readableStreamController")) {
            return false;
          }
          return x3 instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop4);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e3) {
          stream._state = "errored";
          stream._storedError = e3;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e3);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e3);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e3);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name) {
          return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init3, context) {
          assertDictionary(init3, context);
          const highWaterMark = init3 === null || init3 === void 0 ? void 0 : init3.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x3 instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name) {
          return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x3 instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start2 === void 0 ? void 0 : convertTransformerStartCallback(start2, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer2 = convertTransformer(rawTransformer, "First parameter");
            if (transformer2.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer2.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer2);
            if (transformer2.start !== void 0) {
              startPromise_resolve(transformer2.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_transformStreamController")) {
            return false;
          }
          return x3 instanceof TransformStream;
        }
        function TransformStreamError(stream, e3) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e3);
          TransformStreamErrorWritableAndUnblockWrite(stream, e3);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e3) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e3);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x3) {
          if (!typeIsObject(x3)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x3, "_controlledTransformStream")) {
            return false;
          }
          return x3 instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer2) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer2.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer2.transform(chunk, controller);
          }
          if (transformer2.flush !== void 0) {
            flushAlgorithm = () => transformer2.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e3) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e3);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e3) {
          TransformStreamError(controller._controlledTransformStream, e3);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r2) => {
            TransformStreamError(controller._controlledTransformStream, r2);
            throw r2;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable2 = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable2._state === "errored") {
              throw readable2._storedError;
            }
            ReadableStreamDefaultControllerClose(readable2._readableStreamController);
          }, (r2) => {
            TransformStreamError(stream, r2);
            throw readable2._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name) {
          return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
        }
        exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports3.CountQueuingStrategy = CountQueuingStrategy;
        exports3.ReadableByteStreamController = ReadableByteStreamController;
        exports3.ReadableStream = ReadableStream2;
        exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports3.TransformStream = TransformStream;
        exports3.TransformStreamDefaultController = TransformStreamDefaultController;
        exports3.WritableStream = WritableStream;
        exports3.WritableStreamDefaultController = WritableStreamDefaultController;
        exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        const process2 = require("process");
        const { emitWarning } = process2;
        try {
          process2.emitWarning = () => {
          };
          Object.assign(globalThis, require("stream/web"));
          process2.emitWarning = emitWarning;
        } catch (error2) {
          process2.emitWarning = emitWarning;
          throw error2;
        }
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = (_a = class {
      constructor(blobParts = [], options2 = {}) {
        __privateAdd(this, _parts, []);
        __privateAdd(this, _type, "");
        __privateAdd(this, _size, 0);
        if (typeof blobParts !== "object" || blobParts === null) {
          throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
        }
        if (typeof blobParts[Symbol.iterator] !== "function") {
          throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
        }
        if (typeof options2 !== "object" && typeof options2 !== "function") {
          throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        if (options2 === null)
          options2 = {};
        const encoder2 = new TextEncoder();
        for (const element of blobParts) {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof _a) {
            part = element;
          } else {
            part = encoder2.encode(element);
          }
          __privateSet(this, _size, __privateGet(this, _size) + (ArrayBuffer.isView(part) ? part.byteLength : part.size));
          __privateGet(this, _parts).push(part);
        }
        const type2 = options2.type === void 0 ? "" : String(options2.type);
        __privateSet(this, _type, /^[\x20-\x7E]*$/.test(type2) ? type2 : "");
      }
      get size() {
        return __privateGet(this, _size);
      }
      get type() {
        return __privateGet(this, _type);
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (const part of toIterator(__privateGet(this, _parts), false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(__privateGet(this, _parts), false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(__privateGet(this, _parts), true);
        return new globalThis.ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          },
          async cancel() {
            await it.return();
          }
        });
      }
      slice(start2 = 0, end = this.size, type2 = "") {
        const { size } = this;
        let relativeStart = start2 < 0 ? Math.max(size + start2, 0) : Math.min(start2, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = __privateGet(this, _parts);
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            relativeEnd -= size2;
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new _a([], { type: String(type2).toLowerCase() });
        __privateSet(blob, _size, span);
        __privateSet(blob, _parts, blobParts);
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object2) {
        return object2 && typeof object2 === "object" && typeof object2.constructor === "function" && (typeof object2.stream === "function" || typeof object2.arrayBuffer === "function") && /^(Blob|File)$/.test(object2[Symbol.toStringTag]);
      }
    }, _parts = new WeakMap(), _type = new WeakMap(), _size = new WeakMap(), _a);
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    _File = (_a2 = class extends Blob$1 {
      constructor(fileBits, fileName, options2 = {}) {
        if (arguments.length < 2) {
          throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
        }
        super(fileBits, options2);
        __privateAdd(this, _lastModified, 0);
        __privateAdd(this, _name, "");
        if (options2 === null)
          options2 = {};
        const lastModified = options2.lastModified === void 0 ? Date.now() : Number(options2.lastModified);
        if (!Number.isNaN(lastModified)) {
          __privateSet(this, _lastModified, lastModified);
        }
        __privateSet(this, _name, String(fileName));
      }
      get name() {
        return __privateGet(this, _name);
      }
      get lastModified() {
        return __privateGet(this, _lastModified);
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }, _lastModified = new WeakMap(), _name = new WeakMap(), _a2);
    File = _File;
    ({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
    r = Math.random;
    m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
    f2 = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t]) ? [(c = c !== void 0 ? c + "" : b[t] == "File" ? b.name : "blob", a), b.name !== c || b[t] == "blob" ? new File([b], c, b) : b] : [a, b + ""]);
    e = (c, f3) => (f3 ? c : c.replace(/\r?\n|\r/g, "\r\n")).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    x = (n, a, e3) => {
      if (a.length < e3) {
        throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e3} arguments required, but only ${a.length} present.`);
      }
    };
    FormData = (_a3 = class {
      constructor(...a) {
        __privateAdd(this, _d, []);
        if (a.length)
          throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
      }
      get [t]() {
        return "FormData";
      }
      [i]() {
        return this.entries();
      }
      static [h](o) {
        return o && typeof o === "object" && o[t] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
      }
      append(...a) {
        x("append", arguments, 2);
        __privateGet(this, _d).push(f2(...a));
      }
      delete(a) {
        x("delete", arguments, 1);
        a += "";
        __privateSet(this, _d, __privateGet(this, _d).filter(([b]) => b !== a));
      }
      get(a) {
        x("get", arguments, 1);
        a += "";
        for (var b = __privateGet(this, _d), l = b.length, c = 0; c < l; c++)
          if (b[c][0] === a)
            return b[c][1];
        return null;
      }
      getAll(a, b) {
        x("getAll", arguments, 1);
        b = [];
        a += "";
        __privateGet(this, _d).forEach((c) => c[0] === a && b.push(c[1]));
        return b;
      }
      has(a) {
        x("has", arguments, 1);
        a += "";
        return __privateGet(this, _d).some((b) => b[0] === a);
      }
      forEach(a, b) {
        x("forEach", arguments, 1);
        for (var [c, d] of this)
          a.call(b, d, c, this);
      }
      set(...a) {
        x("set", arguments, 2);
        var b = [], c = true;
        a = f2(...a);
        __privateGet(this, _d).forEach((d) => {
          d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
        });
        c && b.push(a);
        __privateSet(this, _d, b);
      }
      *entries() {
        yield* __privateGet(this, _d);
      }
      *keys() {
        for (var [a] of this)
          yield a;
      }
      *values() {
        for (var [, a] of this)
          yield a;
      }
    }, _d = new WeakMap(), _a3);
    FetchBaseError = class extends Error {
      constructor(message, type2) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type2;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type2, systemError) {
        super(message, type2);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object2) => {
      return typeof object2 === "object" && typeof object2.append === "function" && typeof object2.delete === "function" && typeof object2.get === "function" && typeof object2.getAll === "function" && typeof object2.has === "function" && typeof object2.set === "function" && typeof object2.sort === "function" && object2[NAME] === "URLSearchParams";
    };
    isBlob = (object2) => {
      return object2 && typeof object2 === "object" && typeof object2.arrayBuffer === "function" && typeof object2.type === "string" && typeof object2.stream === "function" && typeof object2.constructor === "function" && /^(Blob|File)$/.test(object2[NAME]);
    };
    isAbortSignal = (object2) => {
      return typeof object2 === "object" && (object2[NAME] === "AbortSignal" || object2[NAME] === "EventTarget");
    };
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_node_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_node_stream.default)
          ;
        else if (body instanceof FormData) {
          body = formDataToBlob(body);
          boundary = body.type.split("=")[1];
        } else {
          body = Buffer.from(String(body));
        }
        let stream = body;
        if (Buffer.isBuffer(body)) {
          stream = import_node_stream.default.Readable.from(body);
        } else if (isBlob(body)) {
          stream = import_node_stream.default.Readable.from(body.stream());
        }
        this[INTERNALS$2] = {
          body,
          stream,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_node_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].stream;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async formData() {
        const ct = this.headers.get("content-type");
        if (ct.startsWith("application/x-www-form-urlencoded")) {
          const formData = new FormData();
          const parameters = new URLSearchParams(await this.text());
          for (const [name, value2] of parameters) {
            formData.append(name, value2);
          }
          return formData;
        }
        const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), multipart_parser_exports));
        return toFormData2(this.body, ct);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Body.prototype.buffer = (0, import_node_util.deprecate)(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance[INTERNALS$2];
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_node_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_node_stream.PassThrough({ highWaterMark });
        p2 = new import_node_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].stream = p1;
        body = p2;
      }
      return body;
    };
    getNonSpecFormDataBoundary = (0, import_node_util.deprecate)((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body instanceof FormData) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
      }
      if (body instanceof import_node_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request[INTERNALS$2];
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_node_http.default.validateHeaderName === "function" ? import_node_http.default.validateHeaderName : (name) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_node_http.default.validateHeaderValue === "function" ? import_node_http.default.validateHeaderValue : (name, value2) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value2)) {
        const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers2 = class extends URLSearchParams {
      constructor(init3) {
        let result = [];
        if (init3 instanceof Headers2) {
          const raw = init3.raw();
          for (const [name, values] of Object.entries(raw)) {
            result.push(...values.map((value2) => [name, value2]));
          }
        } else if (init3 == null)
          ;
        else if (typeof init3 === "object" && !import_node_util.types.isBoxedPrimitive(init3)) {
          const method = init3[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init3));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init3].map((pair) => {
              if (typeof pair !== "object" || import_node_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name, value2]) => {
          validateHeaderName(name);
          validateHeaderValue(name, String(value2));
          return [String(name).toLowerCase(), String(value2)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name, value2) => {
                  validateHeaderName(name);
                  validateHeaderValue(name, String(value2));
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value2));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name) => {
                  validateHeaderName(name);
                  return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name) {
        const values = this.getAll(name);
        if (values.length === 0) {
          return null;
        }
        let value2 = values.join(", ");
        if (/^content-encoding$/i.test(name)) {
          value2 = value2.toLowerCase();
        }
        return value2;
      }
      forEach(callback, thisArg = void 0) {
        for (const name of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name), name, this]);
        }
      }
      *values() {
        for (const name of this.keys()) {
          yield this.get(name);
        }
      }
      *entries() {
        for (const name of this.keys()) {
          yield [name, this.get(name)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key2) => {
          result[key2] = this.getAll(key2);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key2) => {
          const values = this.getAll(key2);
          if (key2 === "host") {
            result[key2] = values[0];
          } else {
            result[key2] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property2) => {
      result[property2] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response2 = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers2(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response2(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size,
          highWaterMark: this.highWaterMark
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response2(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response2(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response2.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    ReferrerPolicy = /* @__PURE__ */ new Set([
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ]);
    DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
    INTERNALS = Symbol("Request internals");
    isRequest = (object2) => {
      return typeof object2 === "object" && typeof object2[INTERNALS] === "object";
    };
    Request2 = class extends Body {
      constructor(input, init3 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        if (parsedURL.username !== "" || parsedURL.password !== "") {
          throw new TypeError(`${parsedURL} is an url with embedded credentails.`);
        }
        let method = init3.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init3.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init3.body ? init3.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init3.size || input.size || 0
        });
        const headers = new Headers2(init3.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.set("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init3) {
          signal = init3.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        let referrer = init3.referrer == null ? input.referrer : init3.referrer;
        if (referrer === "") {
          referrer = "no-referrer";
        } else if (referrer) {
          const parsedReferrer = new URL(referrer);
          referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
        } else {
          referrer = void 0;
        }
        this[INTERNALS] = {
          method,
          redirect: init3.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal,
          referrer
        };
        this.follow = init3.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init3.follow;
        this.compress = init3.compress === void 0 ? input.compress === void 0 ? true : input.compress : init3.compress;
        this.counter = init3.counter || input.counter || 0;
        this.agent = init3.agent || input.agent;
        this.highWaterMark = init3.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init3.insecureHTTPParser || input.insecureHTTPParser || false;
        this.referrerPolicy = init3.referrerPolicy || input.referrerPolicy || "";
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_node_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      get referrer() {
        if (this[INTERNALS].referrer === "no-referrer") {
          return "";
        }
        if (this[INTERNALS].referrer === "client") {
          return "about:client";
        }
        if (this[INTERNALS].referrer) {
          return this[INTERNALS].referrer.toString();
        }
        return void 0;
      }
      get referrerPolicy() {
        return this[INTERNALS].referrerPolicy;
      }
      set referrerPolicy(referrerPolicy) {
        this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
      }
      clone() {
        return new Request2(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request2.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true },
      referrer: { enumerable: true },
      referrerPolicy: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers2(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = DEFAULT_REFERRER_POLICY;
      }
      if (request.referrer && request.referrer !== "no-referrer") {
        request[INTERNALS].referrer = determineRequestsReferrer(request);
      } else {
        request[INTERNALS].referrer = "no-referrer";
      }
      if (request[INTERNALS].referrer instanceof URL) {
        headers.set("Referer", request.referrer);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const options2 = {
        path: parsedURL.pathname + search,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return {
        parsedURL,
        options: options2
      };
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type2 = "aborted") {
        super(message, type2);
      }
    };
    supportedSchemas = /* @__PURE__ */ new Set(["data:", "http:", "https:"]);
  }
});

// .svelte-kit/output/server/chunks/index-a93c14e4.js
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function compute_rest_props(props, keys2) {
  const rest = {};
  keys2 = new Set(keys2);
  for (const k in props)
    if (!keys2.has(k) && k[0] !== "$")
      rest[k] = props[k];
  return rest;
}
function custom_event(type2, detail, bubbles = false) {
  const e3 = document.createEvent("CustomEvent");
  e3.initCustomEvent(type2, bubbles, false, detail);
  return e3;
}
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type2, detail) => {
    const callbacks = component.$$.callbacks[type2];
    if (callbacks) {
      const event = custom_event(type2, detail);
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
    }
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
}
function spread(args, attrs_to_add) {
  const attributes = Object.assign({}, ...args);
  if (attrs_to_add) {
    const classes_to_add = attrs_to_add.classes;
    const styles_to_add = attrs_to_add.styles;
    if (classes_to_add) {
      if (attributes.class == null) {
        attributes.class = classes_to_add;
      } else {
        attributes.class += " " + classes_to_add;
      }
    }
    if (styles_to_add) {
      if (attributes.style == null) {
        attributes.style = style_object_to_string(styles_to_add);
      } else {
        attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));
      }
    }
  }
  let str = "";
  Object.keys(attributes).forEach((name) => {
    if (invalid_attribute_name_character.test(name))
      return;
    const value2 = attributes[name];
    if (value2 === true)
      str += " " + name;
    else if (boolean_attributes.has(name.toLowerCase())) {
      if (value2)
        str += " " + name;
    } else if (value2 != null) {
      str += ` ${name}="${value2}"`;
    }
  });
  return str;
}
function merge_ssr_styles(style_attribute, style_directive) {
  const style_object = {};
  for (const individual_style of style_attribute.split(";")) {
    const colon_index = individual_style.indexOf(":");
    const name = individual_style.slice(0, colon_index).trim();
    const value2 = individual_style.slice(colon_index + 1).trim();
    if (!name)
      continue;
    style_object[name] = value2;
  }
  for (const name in style_directive) {
    const value2 = style_directive[name];
    if (value2) {
      style_object[name] = value2;
    } else {
      delete style_object[name];
    }
  }
  return style_object;
}
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match2) => escaped[match2]);
}
function escape_attribute_value(value2) {
  return typeof value2 === "string" ? escape(value2) : value2;
}
function escape_object(obj) {
  const result = {};
  for (const key2 in obj) {
    result[key2] = escape_attribute_value(obj[key2]);
  }
  return result;
}
function validate_component(component, name) {
  if (!component || !component.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css5) => css5.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value2, boolean) {
  if (value2 == null || boolean && !value2)
    return "";
  return ` ${name}${value2 === true && boolean_attributes.has(name) ? "" : `=${typeof value2 === "string" ? JSON.stringify(escape(value2)) : `"${value2}"`}`}`;
}
function style_object_to_string(style_object) {
  return Object.keys(style_object).filter((key2) => style_object[key2]).map((key2) => `${key2}: ${style_object[key2]};`).join(" ");
}
var current_component, boolean_attributes, invalid_attribute_name_character, escaped, missing_component, on_destroy;
var init_index_a93c14e4 = __esm({
  ".svelte-kit/output/server/chunks/index-a93c14e4.js"() {
    Promise.resolve();
    boolean_attributes = /* @__PURE__ */ new Set([
      "allowfullscreen",
      "allowpaymentrequest",
      "async",
      "autofocus",
      "autoplay",
      "checked",
      "controls",
      "default",
      "defer",
      "disabled",
      "formnovalidate",
      "hidden",
      "ismap",
      "loop",
      "multiple",
      "muted",
      "nomodule",
      "novalidate",
      "open",
      "playsinline",
      "readonly",
      "required",
      "reversed",
      "selected"
    ]);
    invalid_attribute_name_character = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
    escaped = {
      '"': "&quot;",
      "'": "&#39;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;"
    };
    missing_component = {
      $$render: () => ""
    };
  }
});

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports2) {
    "use strict";
    exports2.parse = parse;
    exports2.serialize = serialize;
    var decode = decodeURIComponent;
    var encode2 = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options2) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options2 || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i2 = 0; i2 < pairs.length; i2++) {
        var pair = pairs[i2];
        var index2 = pair.indexOf("=");
        if (index2 < 0) {
          continue;
        }
        var key2 = pair.substring(0, index2).trim();
        if (obj[key2] == void 0) {
          var val = pair.substring(index2 + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key2] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options2) {
      var opt = options2 || {};
      var enc = opt.encode || encode2;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value2 = enc(val);
      if (value2 && !fieldContentRegExp.test(value2)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value2;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e3) {
        return str;
      }
    }
  }
});

// node_modules/@lukeed/uuid/dist/index.mjs
function v4() {
  var i2 = 0, num, out = "";
  if (!BUFFER || IDX + 16 > 256) {
    BUFFER = Array(i2 = 256);
    while (i2--)
      BUFFER[i2] = 256 * Math.random() | 0;
    i2 = IDX = 0;
  }
  for (; i2 < 16; i2++) {
    num = BUFFER[IDX + i2];
    if (i2 == 6)
      out += HEX[num & 15 | 64];
    else if (i2 == 8)
      out += HEX[num & 63 | 128];
    else
      out += HEX[num];
    if (i2 & 1 && i2 > 1 && i2 < 11)
      out += "-";
  }
  IDX++;
  return out;
}
var IDX, HEX, BUFFER;
var init_dist = __esm({
  "node_modules/@lukeed/uuid/dist/index.mjs"() {
    IDX = 256;
    HEX = [];
    while (IDX--)
      HEX[IDX] = (IDX + 256).toString(16).substring(1);
  }
});

// .svelte-kit/output/server/chunks/hooks-5b953b47.js
var hooks_5b953b47_exports = {};
__export(hooks_5b953b47_exports, {
  handle: () => handle
});
var import_cookie, handle;
var init_hooks_5b953b47 = __esm({
  ".svelte-kit/output/server/chunks/hooks-5b953b47.js"() {
    import_cookie = __toESM(require_cookie(), 1);
    init_dist();
    handle = async ({ event, resolve: resolve2 }) => {
      const cookies = import_cookie.default.parse(event.request.headers.get("cookie") || "");
      event.locals.userid = cookies.userid || v4();
      const response = await resolve2(event);
      if (!cookies.userid) {
        response.headers.set("set-cookie", import_cookie.default.serialize("userid", event.locals.userid, {
          path: "/",
          httpOnly: true
        }));
      }
      return response;
    };
  }
});

// .svelte-kit/output/server/entries/pages/__layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => _layout
});
var Header, css, _layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/__layout.svelte.js"() {
    init_index_a93c14e4();
    Header = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `<header>
<nav class="${"bg-gray-800"}"><div class="${"mx-auto px-2 sm:px-6 lg:px-6"}"><div class="${"relative flex items-center justify-between h-16"}"><div class="${"absolute inset-y-0 left-0 flex items-center sm:hidden"}">
		  <button type="${"button"}" class="${"inline-flex items-center justify-center p-2 rounded-md text-gray-400 hover:text-white hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-white"}" aria-controls="${"mobile-menu"}" aria-expanded="${"false"}"><span class="${"sr-only"}">Open main menu</span>
			
			<svg class="${"block h-6 w-6"}" xmlns="${"http://www.w3.org/2000/svg"}" fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}" aria-hidden="${"true"}"><path stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" d="${"M4 6h16M4 12h16M4 18h16"}"></path></svg>
			
			<svg class="${"hidden h-6 w-6"}" xmlns="${"http://www.w3.org/2000/svg"}" fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}" aria-hidden="${"true"}"><path stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" d="${"M6 18L18 6M6 6l12 12"}"></path></svg></button></div>
		<div class="${"flex-1 flex items-center justify-center sm:items-stretch sm:justify-start"}"><div class="${"flex-shrink-0 flex items-center"}"><img class="${"block lg:hidden h-8 w-auto"}" src="${"genome.png"}" alt="${"Workflow"}">
			<img class="${"hidden lg:block h-8 w-auto"}" src="${"genome_expanded.png"}" alt="${"Workflow"}"></div></div>
		<div class="${"hidden relative mr-3 md:mr-0 md:block"}"><div class="${"flex absolute inset-y-0 left-0 items-center pl-3 pointer-events-none"}"><svg class="${"w-5 h-5 text-gray-500"}" fill="${"currentColor"}" viewBox="${"0 0 20 20"}" xmlns="${"http://www.w3.org/2000/svg"}"><path fill-rule="${"evenodd"}" d="${"M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z"}" clip-rule="${"evenodd"}"></path></svg></div>
		  <input type="${"text"}" id="${"email-adress-icon"}" class="${"block p-2 pl-10 w-full text-gray-900 bg-gray-50 rounded-lg border border-gray-300 sm:text-sm focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"}" placeholder="${"Search..."}"></div>
		<div class="${"absolute inset-y-0 right-0 flex items-center pr-2 sm:static sm:inset-auto sm:ml-6 sm:pr-0"}"><button type="${"button"}" class="${"bg-gray-800 p-1 rounded-full text-gray-400 hover:text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-white"}"><span class="${"sr-only"}">View notifications</span>
			
			<svg class="${"h-6 w-6"}" xmlns="${"http://www.w3.org/2000/svg"}" fill="${"none"}" viewBox="${"0 0 24 24"}" stroke="${"currentColor"}" aria-hidden="${"true"}"><path stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" d="${"M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"}"></path></svg></button>
  
		  
		  <div class="${"ml-3 relative"}"><div><button type="${"button"}" class="${"bg-gray-800 flex text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-800 focus:ring-white"}" id="${"user-menu-button"}" aria-expanded="${"false"}" aria-haspopup="${"true"}"><span class="${"sr-only"}">Open user menu</span>
				<img class="${"h-8 w-8 rounded-full"}" src="${"https://images.unsplash.com/photo-1472099645785-5658abf4ff4e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=facearea&facepad=2&w=256&h=256&q=80"}" alt="${""}"></button></div>
  
			</div></div></div></div></nav>
  
</header>`;
    });
    css = {
      code: "main.svelte-ddxgh{padding:1rem}footer.svelte-ddxgh{margin:1rem !important}",
      map: null
    };
    _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      $$result.css.add(css);
      return `${validate_component(Header, "Header").$$render($$result, {}, {}, {})}

<main class="${"svelte-ddxgh"}">${slots.default ? slots.default({}) : ``}</main>


<footer class="${"p-4 bg-white rounded-lg md:flex md:items-center md:justify-between md:p-6 svelte-ddxgh"}"><span class="${"text-sm text-gray-500 sm:text-center"}">\xA9 2022 <a class="${"hover:underline"}">GenomeFlow\u2122</a>. All Rights Reserved.
	</span>
	<ul class="${"flex flex-wrap items-center mt-3 text-sm text-gray-500 sm:mt-0"}"><li><a href="${"#"}" class="${"mr-4 hover:underline md:mr-6 "}">About</a></li>
	<li><a href="${"#"}" class="${"mr-4 hover:underline md:mr-6"}">Privacy Policy</a></li>
	<li><a href="${"#"}" class="${"mr-4 hover:underline md:mr-6"}">Licensing</a></li>
	<li><a href="${"#"}" class="${"hover:underline"}">Contact</a></li></ul>
	</footer>`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  css: () => css2,
  entry: () => entry,
  js: () => js,
  module: () => layout_svelte_exports
});
var entry, js, css2;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_svelte();
    entry = "pages/__layout.svelte-dade0db0.js";
    js = ["pages/__layout.svelte-dade0db0.js", "chunks/vendor-117ed6ab.js"];
    css2 = ["assets/pages/__layout.svelte-2ff02410.css"];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2,
  load: () => load
});
function load({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_index_a93c14e4();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { error: error2 } = $$props;
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
        $$bindings.error(error2);
      return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  css: () => css3,
  entry: () => entry2,
  js: () => js2,
  module: () => error_svelte_exports
});
var entry2, js2, css3;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    init_error_svelte();
    entry2 = "error.svelte-962791d0.js";
    js2 = ["error.svelte-962791d0.js", "chunks/vendor-117ed6ab.js"];
    css3 = [];
  }
});

// .svelte-kit/output/server/entries/pages/dashboard.svelte.js
var dashboard_svelte_exports = {};
__export(dashboard_svelte_exports, {
  default: () => Dashboard
});
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
function getRawTag(value2) {
  var isOwn = hasOwnProperty$e.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$3;
}
function arrayMap(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray$1(value2)) {
    return arrayMap(value2, baseToString) + "";
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$3 ? "-0" : result;
}
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject(value2) {
  var type2 = typeof value2;
  return value2 != null && (type2 == "object" || type2 == "function");
}
function toNumber(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol(value2)) {
    return NAN;
  }
  if (isObject(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = baseTrim(value2);
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
function identity$6(value2) {
  return value2;
}
function isFunction(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object2, key2) {
  return object2 == null ? void 0 : object2[key2];
}
function getNative(object2, key2) {
  var value2 = getValue(object2, key2);
  return baseIsNative(value2) ? value2 : void 0;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function noop$3() {
}
function copyArray(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant$8(value2) {
  return function() {
    return value2;
  };
}
function arrayEach(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
function baseFindIndex(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index2-- : ++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return index2;
    }
  }
  return -1;
}
function baseIsNaN(value2) {
  return value2 !== value2;
}
function strictIndexOf(array2, value2, fromIndex) {
  var index2 = fromIndex - 1, length = array2.length;
  while (++index2 < length) {
    if (array2[index2] === value2) {
      return index2;
    }
  }
  return -1;
}
function baseIndexOf(array2, value2, fromIndex) {
  return value2 === value2 ? strictIndexOf(array2, value2, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
}
function arrayIncludes(array2, value2) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && baseIndexOf(array2, value2, 0) > -1;
}
function isIndex(value2, length) {
  var type2 = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type2 == "number" || type2 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object2, key2, value2) {
  if (key2 == "__proto__" && defineProperty$1) {
    defineProperty$1(object2, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object2[key2] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
function assignValue(object2, key2, value2) {
  var objValue = object2[key2];
  if (!(hasOwnProperty$c.call(object2, key2) && eq(objValue, value2)) || value2 === void 0 && !(key2 in object2)) {
    baseAssignValue(object2, key2, value2);
  }
}
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key2 = props[index2];
    var newValue = customizer ? customizer(object2[key2], source[key2], key2, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object2, key2, newValue);
    } else {
      assignValue(object2, key2, newValue);
    }
  }
  return object2;
}
function overRest(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start2, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array2);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity$6), func + "");
}
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
function isIterateeCall(value2, index2, object2) {
  if (!isObject(object2)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
    return eq(object2[index2], value2);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$d;
  return value2 === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$3;
}
function stubFalse() {
  return false;
}
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key2 in value2) {
    if ((inherited || hasOwnProperty$a.call(value2, key2)) && !(skipIndexes && (key2 == "length" || isBuff && (key2 == "offset" || key2 == "parent") || isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || isIndex(key2, length)))) {
      result.push(key2);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function baseKeys(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys$1(object2);
  }
  var result = [];
  for (var key2 in Object(object2)) {
    if (hasOwnProperty$9.call(object2, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function keys(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key2 in Object(object2)) {
      result.push(key2);
    }
  }
  return result;
}
function baseKeysIn(object2) {
  if (!isObject(object2)) {
    return nativeKeysIn(object2);
  }
  var isProto = isPrototype(object2), result = [];
  for (var key2 in object2) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$8.call(object2, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
function keysIn(object2) {
  return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
}
function isKey(value2, object2) {
  if (isArray$1(value2)) {
    return false;
  }
  var type2 = typeof value2;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value2 == null || isSymbol(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object2 != null && value2 in Object(object2);
}
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$7.call(data, key2) ? data[key2] : void 0;
}
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key2] !== void 0 : hasOwnProperty$6.call(data, key2);
}
function hashSet(key2, value2) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate$1 && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry4 = entries[index2];
    this.set(entry4[0], entry4[1]);
  }
}
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array2, key2) {
  var length = array2.length;
  while (length--) {
    if (eq(array2[length][0], key2)) {
      return length;
    }
  }
  return -1;
}
function listCacheDelete(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value2]);
  } else {
    data[index2][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry4 = entries[index2];
    this.set(entry4[0], entry4[1]);
  }
}
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type2 = typeof value2;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key2) {
  var data = map2.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value2) {
  var data = getMapData(this, key2), size = data.size;
  data.set(key2, value2);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry4 = entries[index2];
    this.set(entry4[0], entry4[1]);
  }
}
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key2)) {
      return cache.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key2, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key2;
  });
  var cache = result.cache;
  return result;
}
function toString(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function castPath(value2, object2) {
  if (isArray$1(value2)) {
    return value2;
  }
  return isKey(value2, object2) ? [value2] : stringToPath$1(toString(value2));
}
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$2 ? "-0" : result;
}
function baseGet(object2, path2) {
  path2 = castPath(path2, object2);
  var index2 = 0, length = path2.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey(path2[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
function get$3(object2, path2, defaultValue) {
  var result = object2 == null ? void 0 : baseGet(object2, path2);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array2, values) {
  var index2 = -1, length = values.length, offset = array2.length;
  while (++index2 < length) {
    array2[offset + index2] = values[index2];
  }
  return array2;
}
function isFlattenable(value2) {
  return isArray$1(value2) || isArguments$1(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index2 = -1, length = array2.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value2 = array2[index2];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value2);
      }
    } else if (!isStrict) {
      result[result.length] = value2;
    }
  }
  return result;
}
function flatten$1(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? baseFlatten(array2, 1) : [];
}
function isPlainObject(value2) {
  if (!isObjectLike(value2) || baseGetTag(value2) != objectTag$3) {
    return false;
  }
  var proto = getPrototype$1(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function baseSlice(array2, start2, end) {
  var index2 = -1, length = array2.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start2 > end ? 0 : end - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start2];
  }
  return result;
}
function castSlice(array2, start2, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start2 && end >= length ? array2 : baseSlice(array2, start2, end);
}
function hasUnicode(string) {
  return reHasUnicode.test(string);
}
function asciiToArray(string) {
  return string.split("");
}
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}
function stringToArray(string) {
  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
}
function createCaseFirst(methodName) {
  return function(string) {
    string = toString(string);
    var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
    var chr = strSymbols ? strSymbols[0] : string.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
    return chr[methodName]() + trailing;
  };
}
function capitalize(string) {
  return upperFirst$1(toString(string).toLowerCase());
}
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  if (initAccum && length) {
    accumulator = array2[++index2];
  }
  while (++index2 < length) {
    accumulator = iteratee(accumulator, array2[index2], index2, array2);
  }
  return accumulator;
}
function basePropertyOf(object2) {
  return function(key2) {
    return object2 == null ? void 0 : object2[key2];
  };
}
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? void 0 : pattern;
  if (pattern === void 0) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
  };
}
function baseClamp(number3, lower22, upper) {
  if (number3 === number3) {
    if (upper !== void 0) {
      number3 = number3 <= upper ? number3 : upper;
    }
    if (lower22 !== void 0) {
      number3 = number3 >= lower22 ? number3 : lower22;
    }
  }
  return number3;
}
function clamp(number3, lower22, upper) {
  if (upper === void 0) {
    upper = lower22;
    lower22 = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower22 !== void 0) {
    lower22 = toNumber(lower22);
    lower22 = lower22 === lower22 ? lower22 : 0;
  }
  return baseClamp(toNumber(number3), lower22, upper);
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
function stackSet(key2, value2) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key2, value2]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value2);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
function baseAssign(object2, source) {
  return object2 && copyObject(source, keys(source), object2);
}
function baseAssignIn(object2, source) {
  return object2 && copyObject(source, keysIn(source), object2);
}
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array2[index2];
    if (predicate(value2, index2, array2)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
function copySymbols(source, object2) {
  return copyObject(source, getSymbols$1(source), object2);
}
function copySymbolsIn(source, object2) {
  return copyObject(source, getSymbolsIn$1(source), object2);
}
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$1(object2) ? result : arrayPush(result, symbolsFunc(object2));
}
function getAllKeys(object2) {
  return baseGetAllKeys(object2, keys, getSymbols$1);
}
function getAllKeysIn(object2) {
  return baseGetAllKeys(object2, keysIn, getSymbolsIn$1);
}
function initCloneArray(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty$4.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(object2);
    case boolTag$2:
    case dateTag$2:
      return new Ctor(+object2);
    case dataViewTag$2:
      return cloneDataView(object2, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object2, isDeep);
    case mapTag$4:
      return new Ctor();
    case numberTag$2:
    case stringTag$2:
      return new Ctor(object2);
    case regexpTag$2:
      return cloneRegExp(object2);
    case setTag$4:
      return new Ctor();
    case symbolTag$2:
      return cloneSymbol(object2);
  }
}
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate$1(getPrototype$1(object2)) : {};
}
function baseIsMap(value2) {
  return isObjectLike(value2) && getTag$1(value2) == mapTag$3;
}
function baseIsSet(value2) {
  return isObjectLike(value2) && getTag$1(value2) == setTag$3;
}
function baseClone(value2, bitmask, customizer, key2, object2, stack2) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object2 ? customizer(value2, key2, object2, stack2) : customizer(value2);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value2)) {
    return value2;
  }
  var isArr = isArray$1(value2);
  if (isArr) {
    result = initCloneArray(value2);
    if (!isDeep) {
      return copyArray(value2, result);
    }
  } else {
    var tag = getTag$1(value2), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value2)) {
      return cloneBuffer(value2, isDeep);
    }
    if (tag == objectTag$1 || tag == argsTag$1 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : initCloneObject(value2);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value2 : {};
      }
      result = initCloneByTag(value2, tag, isDeep);
    }
  }
  stack2 || (stack2 = new Stack());
  var stacked = stack2.get(value2);
  if (stacked) {
    return stacked;
  }
  stack2.set(value2, result);
  if (isSet$1(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack2));
    });
  } else if (isMap$1(value2)) {
    value2.forEach(function(subValue, key22) {
      result.set(key22, baseClone(subValue, bitmask, customizer, key22, value2, stack2));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value2);
  arrayEach(props || value2, function(subValue, key22) {
    if (props) {
      key22 = subValue;
      subValue = value2[key22];
    }
    assignValue(result, key22, baseClone(subValue, bitmask, customizer, key22, value2, stack2));
  });
  return result;
}
function cloneDeep(value2) {
  return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
function arraySome(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key2) {
  return cache.has(key2);
}
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array2);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array2, other);
  stack2.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array2);
  stack2["delete"](other);
  return result;
}
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key2) {
    result[++index2] = [key2, value2];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array$2(object2), new Uint8Array$2(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object2, +other);
    case errorTag:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag:
    case stringTag:
      return object2 == other + "";
    case mapTag$1:
      var convert = mapToArray;
    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object2, other);
      var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object2);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$3.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack2.get(object2);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack2.set(object2, other);
  stack2.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object2[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object2, stack2) : customizer(objValue, othValue, key2, object2, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object2);
  stack2["delete"](other);
  return result;
}
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$1(object2), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object2), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object2)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value2, other, bitmask, customizer, stack2) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
    return value2 !== value2 && other !== other;
  }
  return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack2);
}
function baseIsMatch(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key2 = data[0], objValue = object2[key2], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key2 in object2)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key2, object2, source, stack2);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value2) {
  return value2 === value2 && !isObject(value2);
}
function getMatchData(object2) {
  var result = keys(object2), length = result.length;
  while (length--) {
    var key2 = result[length], value2 = object2[key2];
    result[length] = [key2, value2, isStrictComparable(value2)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object2));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
function baseHasIn(object2, key2) {
  return object2 != null && key2 in Object(object2);
}
function hasPath(object2, path2, hasFunc) {
  path2 = castPath(path2, object2);
  var index2 = -1, length = path2.length, result = false;
  while (++index2 < length) {
    var key2 = toKey(path2[index2]);
    if (!(result = object2 != null && hasFunc(object2, key2))) {
      break;
    }
    object2 = object2[key2];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength(length) && isIndex(key2, length) && (isArray$1(object2) || isArguments$1(object2));
}
function hasIn(object2, path2) {
  return object2 != null && hasPath(object2, path2, baseHasIn);
}
function baseMatchesProperty(path2, srcValue) {
  if (isKey(path2) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path2), srcValue);
  }
  return function(object2) {
    var objValue = get$3(object2, path2);
    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key2) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key2];
  };
}
function basePropertyDeep(path2) {
  return function(object2) {
    return baseGet(object2, path2);
  };
}
function property(path2) {
  return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
}
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity$6;
  }
  if (typeof value2 == "object") {
    return isArray$1(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
  }
  return property(value2);
}
function arrayAggregator(array2, setter, iteratee, accumulator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    var value2 = array2[index2];
    setter(accumulator, value2, iteratee(value2), array2);
  }
  return accumulator;
}
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key2 = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
function baseForOwn(object2, iteratee) {
  return object2 && baseFor$1(object2, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach$1(collection, function(value2, key2, collection2) {
    setter(accumulator, value2, iteratee(value2), collection2);
  });
  return accumulator;
}
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray$1(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, baseIteratee(iteratee), accumulator);
  };
}
function debounce(func, wait, options2) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options2)) {
    leading = !!options2.leading;
    maxing = "maxWait" in options2;
    maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options2 ? !!options2.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$2();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$2());
  }
  function debounced() {
    var time2 = now$2(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function assignMergeValue(object2, key2, value2) {
  if (value2 !== void 0 && !eq(object2[key2], value2) || value2 === void 0 && !(key2 in object2)) {
    baseAssignValue(object2, key2, value2);
  }
}
function isArrayLikeObject(value2) {
  return isObjectLike(value2) && isArrayLike(value2);
}
function safeGet(object2, key2) {
  if (key2 === "constructor" && typeof object2[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object2[key2];
}
function toPlainObject(value2) {
  return copyObject(value2, keysIn(value2));
}
function baseMergeDeep(object2, source, key2, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet(object2, key2), srcValue = safeGet(source, key2), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue(object2, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object2, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue(object2, key2, newValue);
}
function baseMerge(object2, source, srcIndex, customizer, stack2) {
  if (object2 === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key2) {
    stack2 || (stack2 = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object2, source, key2, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet(object2, key2), srcValue, key2 + "", object2, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object2, key2, newValue);
    }
  }, keysIn);
}
function arrayIncludesWith(array2, value2, comparator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (comparator(value2, array2[index2])) {
      return true;
    }
  }
  return false;
}
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach$1(collection, function(value2, key2, collection2) {
    result[++index2] = iteratee(value2, key2, collection2);
  });
  return result;
}
function map$1(collection, iteratee) {
  var func = isArray$1(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
function flatMapDeep(collection, iteratee) {
  return baseFlatten(map$1(collection, iteratee), INFINITY$1);
}
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
function isEmpty(value2) {
  if (value2 == null) {
    return true;
  }
  if (isArrayLike(value2) && (isArray$1(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer$1(value2) || isTypedArray$1(value2) || isArguments$1(value2))) {
    return !value2.length;
  }
  var tag = getTag$1(value2);
  if (tag == mapTag || tag == setTag) {
    return !value2.size;
  }
  if (isPrototype(value2)) {
    return !baseKeys(value2).length;
  }
  for (var key2 in value2) {
    if (hasOwnProperty.call(value2, key2)) {
      return false;
    }
  }
  return true;
}
function isEqual(value2, other) {
  return baseIsEqual(value2, other);
}
function baseSome(collection, predicate) {
  var result;
  baseEach$1(collection, function(value2, index2, collection2) {
    result = predicate(value2, index2, collection2);
    return !result;
  });
  return !!result;
}
function some(collection, predicate, guard) {
  var func = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee(predicate));
}
function baseUniq(array2, iteratee, comparator) {
  var index2 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet$1(array2);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index2 < length) {
      var value2 = array2[index2], computed = iteratee ? iteratee(value2) : value2;
      value2 = comparator || value2 !== 0 ? value2 : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value2);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value2);
      }
    }
  return result;
}
function uniq(array2) {
  return array2 && array2.length ? baseUniq(array2) : [];
}
function namespace(name) {
  var prefix = name += "", i2 = prefix.indexOf(":");
  if (i2 >= 0 && (prefix = name.slice(0, i2)) !== "xmlns")
    name = name.slice(i2 + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none$2() {
}
function selector(selector2) {
  return selector2 == null ? none$2 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
      if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array$3(x22) {
  return x22 == null ? [] : Array.isArray(x22) ? x22 : Array.from(x22);
}
function empty$1() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array$3(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group[i2]) {
        subgroups.push(select2.call(node, node.__data__, i2, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
function childFind(match2) {
  return function() {
    return find$1.call(this.children, match2);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match2) {
  return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
function children() {
  return Array.from(this.children);
}
function childrenFilter(match2) {
  return function() {
    return filter.call(this.children, match2);
  };
}
function selection_selectChildren(match2) {
  return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
function selection_filter(match2) {
  if (typeof match2 !== "function")
    match2 = matcher(match2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
      if ((node = group[i2]) && match2.call(node, node.__data__, i2, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
function constant$7(x22) {
  return function() {
    return x22;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i2 = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i2 < dataLength; ++i2) {
    if (node = group[i2]) {
      node.__data__ = data[i2];
      update[i2] = node;
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      exit[i2] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key2) {
  var i2, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i2 = 0; i2 < groupLength; ++i2) {
    if (node = group[i2]) {
      keyValues[i2] = keyValue = key2.call(node, node.__data__, i2, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i2] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i2 = 0; i2 < dataLength; ++i2) {
    keyValue = key2.call(parent, data[i2], i2, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i2] = node;
      node.__data__ = data[i2];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i2] = new EnterNode(parent, data[i2]);
    }
  }
  for (i2 = 0; i2 < groupLength; ++i2) {
    if ((node = group[i2]) && nodeByKeyValue.get(keyValues[i2]) === node) {
      exit[i2] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value2, key2) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key2 ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value2 !== "function")
    value2 = constant$7(value2);
  for (var m2 = groups.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value2.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key2);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge2[i2] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m2 = groups.length; ++j < m2; ) {
    for (var group = groups[j], i2 = group.length - 1, next = group[i2], node; --i2 >= 0; ) {
      if (node = group[i2]) {
        if (next && node.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending$1;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m2 = groups.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group[i2]) {
        sortgroup[i2] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i2 = 0, n = group.length; i2 < n; ++i2) {
      var node = group[i2];
      if (node)
        return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
      if (node = group[i2])
        callback.call(node, node.__data__, i2, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value2) {
  return function() {
    this.setAttribute(name, value2);
  };
}
function attrConstantNS$1(fullname, value2) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value2);
  };
}
function attrFunction$1(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value2) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value2 == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value2 === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value2));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value2, priority) {
  return function() {
    this.style.setProperty(name, value2, priority);
  };
}
function styleFunction$1(name, value2, priority) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value2, priority) {
  return arguments.length > 1 ? this.each((value2 == null ? styleRemove$1 : typeof value2 === "function" ? styleFunction$1 : styleConstant$1)(name, value2, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value2) {
  return function() {
    this[name] = value2;
  };
}
function propertyFunction(name, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property(name, value2) {
  return arguments.length > 1 ? this.each((value2 == null ? propertyRemove : typeof value2 === "function" ? propertyFunction : propertyConstant)(name, value2)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
function classedAdd(node, names) {
  var list = classList(node), i2 = -1, n = names.length;
  while (++i2 < n)
    list.add(names[i2]);
}
function classedRemove(node, names) {
  var list = classList(node), i2 = -1, n = names.length;
  while (++i2 < n)
    list.remove(names[i2]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value2) {
  return function() {
    (value2.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value2) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i2 = -1, n = names.length;
    while (++i2 < n)
      if (!list.contains(names[i2]))
        return false;
    return true;
  }
  return this.each((typeof value2 === "function" ? classedFunction : value2 ? classedTrue : classedFalse)(names, value2));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction$1(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value2) {
  return arguments.length ? this.each(value2 == null ? textRemove : (typeof value2 === "function" ? textFunction$1 : textConstant$1)(value2)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value2) {
  return function() {
    this.innerHTML = value2;
  };
}
function htmlFunction(value2) {
  return function() {
    var v = value2.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value2) {
  return arguments.length ? this.each(value2 == null ? htmlRemove : (typeof value2 === "function" ? htmlFunction : htmlConstant)(value2)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower2() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower2);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value2) {
  return arguments.length ? this.property("__data__", value2) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on2 = this.__on;
    if (!on2)
      return;
    for (var j = 0, i2 = -1, m2 = on2.length, o; j < m2; ++j) {
      if (o = on2[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on2[++i2] = o;
      }
    }
    if (++i2)
      on2.length = i2;
    else
      delete this.__on;
  };
}
function onAdd(typename, value2, options2) {
  return function() {
    var on2 = this.__on, o, listener = contextListener(value2);
    if (on2)
      for (var j = 0, m2 = on2.length; j < m2; ++j) {
        if ((o = on2[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options2);
          o.value = value2;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options2);
    o = { type: typename.type, name: typename.name, value: value2, listener, options: options2 };
    if (!on2)
      this.__on = [o];
    else
      on2.push(o);
  };
}
function selection_on(typename, value2, options2) {
  var typenames = parseTypenames$2(typename + ""), i2, n = typenames.length, t2;
  if (arguments.length < 2) {
    var on2 = this.node().__on;
    if (on2)
      for (var j = 0, m2 = on2.length, o; j < m2; ++j) {
        for (i2 = 0, o = on2[j]; i2 < n; ++i2) {
          if ((t2 = typenames[i2]).type === o.type && t2.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on2 = value2 ? onAdd : onRemove;
  for (i2 = 0; i2 < n; ++i2)
    this.each(on2(typenames[i2], value2, options2));
  return this;
}
function dispatchEvent(node, type2, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type2, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type2, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m2 = groups.length; j < m2; ++j) {
    for (var group = groups[j], i2 = 0, n = group.length, node; i2 < n; ++i2) {
      if (node = group[i2])
        yield node;
    }
  }
}
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0)
    node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
function getDefaultExportFromCjs(x22) {
  return x22 && x22.__esModule && Object.prototype.hasOwnProperty.call(x22, "default") ? x22["default"] : x22;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function bisector(f3) {
  let delta = f3;
  let compare1 = f3;
  let compare2 = f3;
  if (f3.length !== 2) {
    delta = (d, x22) => f3(d) - x22;
    compare1 = ascending;
    compare2 = (d, x22) => ascending(f3(d), x22);
  }
  function left2(a, x22, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x22, x22) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x22) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a, x22, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x22, x22) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x22) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a, x22, lo = 0, hi = a.length) {
    const i2 = left2(a, x22, lo, hi - 1);
    return i2 > lo && delta(a[i2 - 1], x22) > -delta(a[i2], x22) ? i2 - 1 : i2;
  }
  return { left: left2, center: center2, right: right2 };
}
function number$3(x22) {
  return x22 === null ? NaN : +x22;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
        yield value2;
      }
    }
  }
}
function count$1(values, valueof) {
  let count2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 != null && (value2 = +value2) >= value2) {
        ++count2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (value2 = +value2) >= value2) {
        ++count2;
      }
    }
  }
  return count2;
}
function extent(values, valueof) {
  let min2;
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null) {
        if (min2 === void 0) {
          if (value2 >= value2)
            min2 = max2 = value2;
        } else {
          if (min2 > value2)
            min2 = value2;
          if (max2 < value2)
            max2 = value2;
        }
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null) {
        if (min2 === void 0) {
          if (value2 >= value2)
            min2 = max2 = value2;
        } else {
          if (min2 > value2)
            min2 = value2;
          if (max2 < value2)
            max2 = value2;
        }
      }
    }
  }
  return [min2, max2];
}
function intern_get({ _intern, _key }, value2) {
  const key2 = _key(value2);
  return _intern.has(key2) ? _intern.get(key2) : value2;
}
function intern_set({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2))
    return _intern.get(key2);
  _intern.set(key2, value2);
  return value2;
}
function intern_delete({ _intern, _key }, value2) {
  const key2 = _key(value2);
  if (_intern.has(key2)) {
    value2 = _intern.get(key2);
    _intern.delete(key2);
  }
  return value2;
}
function keyof(value2) {
  return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
}
function identity$5(x22) {
  return x22;
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a, b) => {
    const x22 = compare(a, b);
    if (x22 || x22 === 0)
      return x22;
    return (compare(b, b) === 0) - (compare(a, a) === 0);
  };
}
function ascendingDefined(a, b) {
  return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
}
function constant$6(x22) {
  return () => x22;
}
function ticks(start2, stop, count2) {
  var reverse, i2 = -1, n, ticks2, step;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
    if (r0 * step < start2)
      ++r0;
    if (r1 * step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i2 < n)
      ticks2[i2] = (r0 + i2) * step;
  } else {
    step = -step;
    let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
    if (r0 / step < start2)
      ++r0;
    if (r1 / step > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i2 < n)
      ticks2[i2] = (r0 + i2) / step;
  }
  if (reverse)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  var step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error2 = step / Math.pow(10, power);
  return power >= 0 ? (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error2 >= e10 ? 10 : error2 >= e5 ? 5 : error2 >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error2 = step0 / step1;
  if (error2 >= e10)
    step1 *= 10;
  else if (error2 >= e5)
    step1 *= 5;
  else if (error2 >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function nice$1(start2, stop, count2) {
  let prestep;
  while (true) {
    const step = tickIncrement(start2, stop, count2);
    if (step === prestep || step === 0 || !isFinite(step)) {
      return [start2, stop];
    } else if (step > 0) {
      start2 = Math.floor(start2 / step) * step;
      stop = Math.ceil(stop / step) * step;
    } else if (step < 0) {
      start2 = Math.ceil(start2 * step) / step;
      stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function thresholdSturges(values) {
  return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
}
function bin() {
  var value2 = identity$5, domain = extent, threshold = thresholdSturges;
  function histogram2(data) {
    if (!Array.isArray(data))
      data = Array.from(data);
    var i2, n = data.length, x22, values = new Array(n);
    for (i2 = 0; i2 < n; ++i2) {
      values[i2] = value2(data[i2], i2, data);
    }
    var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
    if (!Array.isArray(tz)) {
      const max2 = x1, tn = +tz;
      if (domain === extent)
        [x0, x1] = nice$1(x0, x1, tn);
      tz = ticks(x0, x1, tn);
      if (tz[tz.length - 1] >= x1) {
        if (max2 >= x1 && domain === extent) {
          const step = tickIncrement(x0, x1, tn);
          if (isFinite(step)) {
            if (step > 0) {
              x1 = (Math.floor(x1 / step) + 1) * step;
            } else if (step < 0) {
              x1 = (Math.ceil(x1 * -step) + 1) / -step;
            }
          }
        } else {
          tz.pop();
        }
      }
    }
    var m2 = tz.length;
    while (tz[0] <= x0)
      tz.shift(), --m2;
    while (tz[m2 - 1] > x1)
      tz.pop(), --m2;
    var bins = new Array(m2 + 1), bin2;
    for (i2 = 0; i2 <= m2; ++i2) {
      bin2 = bins[i2] = [];
      bin2.x0 = i2 > 0 ? tz[i2 - 1] : x0;
      bin2.x1 = i2 < m2 ? tz[i2] : x1;
    }
    for (i2 = 0; i2 < n; ++i2) {
      x22 = values[i2];
      if (x22 != null && x0 <= x22 && x22 <= x1) {
        bins[bisect(tz, x22, 0, m2)].push(data[i2]);
      }
    }
    return bins;
  }
  histogram2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$6(_), histogram2) : value2;
  };
  histogram2.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant$6([_[0], _[1]]), histogram2) : domain;
  };
  histogram2.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$6(slice$2.call(_)) : constant$6(_), histogram2) : threshold;
  };
  return histogram2;
}
function max$3(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  }
  return max2;
}
function min$3(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  }
  return min2;
}
function quickselect(array2, k, left2 = 0, right2 = array2.length - 1, compare) {
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      const n = right2 - left2 + 1;
      const m2 = k - left2 + 1;
      const z = Math.log(n);
      const s3 = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s3 * (n - s3) / n) * (m2 - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left2, Math.floor(k - m2 * s3 / n + sd));
      const newRight = Math.min(right2, Math.floor(k + (n - m2) * s3 / n + sd));
      quickselect(array2, k, newLeft, newRight, compare);
    }
    const t2 = array2[k];
    let i2 = left2;
    let j = right2;
    swap(array2, left2, k);
    if (compare(array2[right2], t2) > 0)
      swap(array2, left2, right2);
    while (i2 < j) {
      swap(array2, i2, j), ++i2, --j;
      while (compare(array2[i2], t2) < 0)
        ++i2;
      while (compare(array2[j], t2) > 0)
        --j;
    }
    if (compare(array2[left2], t2) === 0)
      swap(array2, left2, j);
    else
      ++j, swap(array2, j, right2);
    if (j <= k)
      left2 = j + 1;
    if (k <= j)
      right2 = j - 1;
  }
  return array2;
}
function swap(array2, i2, j) {
  const t2 = array2[i2];
  array2[i2] = array2[j];
  array2[j] = t2;
}
function quantile(values, p, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n = values.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return min$3(values);
  if (p >= 1)
    return max$3(values);
  var n, i2 = (n - 1) * p, i0 = Math.floor(i2), value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min$3(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i2 - i0);
}
function range(start2, stop, step) {
  start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
  var i2 = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
  while (++i2 < n) {
    range2[i2] = start2 + i2 * step;
  }
  return range2;
}
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function ordinal() {
  var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    let i2 = index2.get(d);
    if (i2 === void 0) {
      if (unknown !== implicit)
        return unknown;
      index2.set(d, i2 = domain.push(d) - 1);
    }
    return range2[i2 % range2.length];
  }
  scale.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = new InternMap();
    for (const value2 of _) {
      if (index2.has(value2))
        continue;
      index2.set(value2, domain.push(value2) - 1);
    }
    return scale;
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse = r1 < r0, start2 = reverse ? r1 : r0, stop = reverse ? r0 : r1;
    step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step = Math.floor(step);
    start2 += (stop - start2 - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i2) {
      return start2 + step * i2;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step;
  };
  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };
  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key2 in definition)
    prototype[key2] = definition[key2];
  return prototype;
}
function Color() {
}
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format22) {
  var m2, l;
  format22 = (format22 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format22)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format22)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format22)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format22)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format22)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format22)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format22)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format22) ? rgbn(named[format22]) : format22 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b, a) {
  if (a <= 0)
    r2 = g = b = NaN;
  return new Rgb(r2, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h2, s3, l, a) {
  if (a <= 0)
    h2 = s3 = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s3 = NaN;
  else if (s3 <= 0)
    h2 = NaN;
  return new Hsl(h2, s3, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h2 = NaN, s3 = max2 - min2, l = (max2 + min2) / 2;
  if (s3) {
    if (r2 === max2)
      h2 = (g - b) / s3 + (g < b) * 6;
    else if (g === max2)
      h2 = (b - r2) / s3 + 2;
    else
      h2 = (r2 - g) / s3 + 4;
    s3 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s3 = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s3, l, o.opacity);
}
function hsl(h2, s3, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s3, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s3, l, opacity) {
  this.h = +h2;
  this.s = +s3;
  this.l = +l;
  this.opacity = +opacity;
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
function linear$1(a, d) {
  return function(t2) {
    return a + t2 * d;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t2) {
    return Math.pow(a + t2 * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$5(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$5(isNaN(a) ? b : a);
}
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i2;
  return function(t2) {
    for (i2 = 0; i2 < n; ++i2)
      c[i2] = a[i2] * (1 - t2) + b[i2] * t2;
    return c;
  };
}
function isNumberArray(x22) {
  return ArrayBuffer.isView(x22) && !(x22 instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x22 = new Array(na), c = new Array(nb), i2;
  for (i2 = 0; i2 < na; ++i2)
    x22[i2] = interpolate$1(a[i2], b[i2]);
  for (; i2 < nb; ++i2)
    c[i2] = b[i2];
  return function(t2) {
    for (i2 = 0; i2 < na; ++i2)
      c[i2] = x22[i2](t2);
    return c;
  };
}
function date$1(a, b) {
  var d = new Date();
  return a = +a, b = +b, function(t2) {
    return d.setTime(a * (1 - t2) + b * t2), d;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t2) {
    return a * (1 - t2) + b * t2;
  };
}
function object(a, b) {
  var i2 = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i2[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t2) {
    for (k in i2)
      c[k] = i2[k](t2);
    return c;
  };
}
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t2) {
    return b(t2) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i2 = -1, s3 = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s3[i2])
        s3[i2] += bs;
      else
        s3[++i2] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s3[i2])
        s3[i2] += bm;
      else
        s3[++i2] = bm;
    } else {
      s3[++i2] = null;
      q.push({ i: i2, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s3[i2])
      s3[i2] += bs;
    else
      s3[++i2] = bs;
  }
  return s3.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
    for (var i22 = 0, o; i22 < b; ++i22)
      s3[(o = q[i22]).i] = o.x(t2);
    return s3.join("");
  });
}
function interpolate$1(a, b) {
  var t2 = typeof b, c;
  return b == null || t2 === "boolean" ? constant$5(b) : (t2 === "number" ? interpolateNumber : t2 === "string" ? (c = color(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
function interpolateRound(a, b) {
  return a = +a, b = +b, function(t2) {
    return Math.round(a * (1 - t2) + b * t2);
  };
}
function decompose(a, b, c, d, e3, f3) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e3,
    translateY: f3,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
function parseCss(value2) {
  const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value2 + "");
  return m2.isIdentity ? identity$4 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
}
function parseSvg(value2) {
  if (value2 == null)
    return identity$4;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value2);
  if (!(value2 = svgNode.transform.baseVal.consolidate()))
    return identity$4;
  value2 = value2.matrix;
  return decompose(value2.a, value2.b, value2.c, value2.d, value2.e, value2.f);
}
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s3) {
    return s3.length ? s3.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s3.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s3.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s3, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s3.push(pop(s3) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s3.push(pop(s3) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s3, q) {
    if (a !== b) {
      q.push({ i: s3.push(pop(s3) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s3.push(pop(s3) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s3, q) {
    if (xa !== xb || ya !== yb) {
      var i2 = s3.push(pop(s3) + "scale(", null, ",", null, ")");
      q.push({ i: i2 - 4, x: interpolateNumber(xa, xb) }, { i: i2 - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s3.push(pop(s3) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s3 = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s3, q);
    rotate(a.rotate, b.rotate, s3, q);
    skewX(a.skewX, b.skewX, s3, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s3, q);
    a = b = null;
    return function(t2) {
      var i2 = -1, n = q.length, o;
      while (++i2 < n)
        s3[(o = q[i2]).i] = o.x(t2);
      return s3.join("");
    };
  };
}
function quantize$1(interpolator, n) {
  var samples = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    samples[i2] = interpolator(i2 / (n - 1));
  return samples;
}
function constants(x22) {
  return function() {
    return x22;
  };
}
function number$2(x22) {
  return +x22;
}
function identity$3(x22) {
  return x22;
}
function normalize2(a, b) {
  return (b -= a = +a) ? function(x22) {
    return (x22 - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t2;
  if (a > b)
    t2 = a, a = b, b = t2;
  return function(x22) {
    return Math.max(a, Math.min(b, x22));
  };
}
function bimap(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize2(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize2(d0, d1), r0 = interpolate2(r0, r1);
  return function(x22) {
    return r0(d0(x22));
  };
}
function polymap(domain, range2, interpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i2 = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i2 < j) {
    d[i2] = normalize2(domain[i2], domain[i2 + 1]);
    r2[i2] = interpolate2(range2[i2], range2[i2 + 1]);
  }
  return function(x22) {
    var i22 = bisect(domain, x22, 1, j) - 1;
    return r2[i22](d[i22](x22));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate2 = interpolate$1, transform, untransform, unknown, clamp2 = identity$3, piecewise, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp2 !== identity$3)
      clamp2 = clamper(domain[0], domain[n - 1]);
    piecewise = n > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x22) {
    return x22 == null || isNaN(x22 = +x22) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate2)))(transform(clamp2(x22)));
  }
  scale.invert = function(y2) {
    return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform), interpolateNumber)))(y2)));
  };
  scale.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$2), rescale()) : domain.slice();
  };
  scale.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$3, rescale()) : clamp2 !== identity$3;
  };
  scale.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, rescale()) : interpolate2;
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };
  return function(t2, u) {
    transform = t2, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity$3, identity$3);
}
function formatDecimal(x22) {
  return Math.abs(x22 = Math.round(x22)) >= 1e21 ? x22.toLocaleString("en").replace(/,/g, "") : x22.toString(10);
}
function formatDecimalParts(x22, p) {
  if ((i2 = (x22 = p ? x22.toExponential(p - 1) : x22.toExponential()).indexOf("e")) < 0)
    return null;
  var i2, coefficient = x22.slice(0, i2);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x22.slice(i2 + 1)
  ];
}
function exponent(x22) {
  return x22 = formatDecimalParts(Math.abs(x22)), x22 ? x22[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value2, width) {
    var i2 = value2.length, t2 = [], j = 0, g = grouping[0], length = 0;
    while (i2 > 0 && g > 0) {
      if (length + g + 1 > width)
        g = Math.max(1, width - length);
      t2.push(value2.substring(i2 -= g, i2 + g));
      if ((length += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value2) {
    return value2.replace(/[0-9]/g, function(i2) {
      return numerals[+i2];
    });
  };
}
function formatSpecifier(specifier) {
  if (!(match2 = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match2;
  return new FormatSpecifier({
    fill: match2[1],
    align: match2[2],
    sign: match2[3],
    symbol: match2[4],
    zero: match2[5],
    width: match2[6],
    comma: match2[7],
    precision: match2[8] && match2[8].slice(1),
    trim: match2[9],
    type: match2[10]
  });
}
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
function formatTrim(s3) {
  out:
    for (var n = s3.length, i2 = 1, i0 = -1, i1; i2 < n; ++i2) {
      switch (s3[i2]) {
        case ".":
          i0 = i1 = i2;
          break;
        case "0":
          if (i0 === 0)
            i0 = i2;
          i1 = i2;
          break;
        default:
          if (!+s3[i2])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
}
function formatPrefixAuto(x22, p) {
  var d = formatDecimalParts(x22, p);
  if (!d)
    return x22 + "";
  var coefficient = d[0], exponent2 = d[1], i2 = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i2 === n ? coefficient : i2 > n ? coefficient + new Array(i2 - n + 1).join("0") : i2 > 0 ? coefficient.slice(0, i2) + "." + coefficient.slice(i2) : "0." + new Array(1 - i2).join("0") + formatDecimalParts(x22, Math.max(0, p + i2 - 1))[0];
}
function formatRounded(x22, p) {
  var d = formatDecimalParts(x22, p);
  if (!d)
    return x22 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
function identity$2(x22) {
  return x22;
}
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format22(value2) {
      var valuePrefix = prefix, valueSuffix = suffix, i2, n, c;
      if (type2 === "c") {
        valueSuffix = formatType(value2) + valueSuffix;
        value2 = "";
      } else {
        value2 = +value2;
        var valueNegative = value2 < 0 || 1 / value2 < 0;
        value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
        if (trim)
          value2 = formatTrim(value2);
        if (valueNegative && +value2 === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i2 = -1, n = value2.length;
          while (++i2 < n) {
            if (c = value2.charCodeAt(i2), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value2.slice(i2 + 1) : value2.slice(i2)) + valueSuffix;
              value2 = value2.slice(0, i2);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value2 = group(value2, Infinity);
      var length = valuePrefix.length + value2.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma && zero2)
        value2 = group(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value2 = valuePrefix + value2 + valueSuffix + padding;
          break;
        case "=":
          value2 = valuePrefix + padding + value2 + valueSuffix;
          break;
        case "^":
          value2 = padding.slice(0, length = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length);
          break;
        default:
          value2 = padding + valuePrefix + value2 + valueSuffix;
          break;
      }
      return numerals(value2);
    }
    format22.toString = function() {
      return specifier + "";
    };
    return format22;
  }
  function formatPrefix2(specifier, value2) {
    var f3 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3, k = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value3) {
      return f3(k * value3) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
function defaultLocale$2(definition) {
  locale$2 = formatLocale$1(definition);
  format$1 = locale$2.format;
  formatPrefix = locale$2.formatPrefix;
  return locale$2;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value2) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value2) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start2, stop, count2, specifier) {
  var step = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value2 = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value2)))
        specifier.precision = precision;
      return formatPrefix(specifier, value2);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$1(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start2) {
      step = start2, start2 = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start2, stop, count2);
      if (step === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous();
  scale.copy = function() {
    return copy(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
  if (x1 < x0) {
    t2 = i0, i0 = i1, i1 = t2;
    t2 = x0, x0 = x1, x1 = t2;
  }
  domain[i0] = interval2.floor(x0);
  domain[i1] = interval2.ceil(x1);
  return domain;
}
function transformLog(x22) {
  return Math.log(x22);
}
function transformExp(x22) {
  return Math.exp(x22);
}
function transformLogn(x22) {
  return -Math.log(-x22);
}
function transformExpn(x22) {
  return -Math.exp(-x22);
}
function pow10(x22) {
  return isFinite(x22) ? +("1e" + x22) : x22 < 0 ? 0 : x22;
}
function powp(base2) {
  return base2 === 10 ? pow10 : base2 === Math.E ? Math.exp : (x22) => Math.pow(base2, x22);
}
function logp(base2) {
  return base2 === Math.E ? Math.log : base2 === 10 && Math.log10 || base2 === 2 && Math.log2 || (base2 = Math.log(base2), (x22) => Math.log(x22) / base2);
}
function reflect(f3) {
  return (x22, k) => -f3(-x22, k);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base2 = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base2), pows = powp(base2);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_) {
    return arguments.length ? (base2 = +_, rescale()) : base2;
  };
  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = (count2) => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r2 = v < u;
    if (r2)
      [u, v] = [v, u];
    let i2 = logs(u);
    let j = logs(v);
    let k;
    let t2;
    const n = count2 == null ? 10 : +count2;
    let z = [];
    if (!(base2 % 1) && j - i2 < n) {
      i2 = Math.floor(i2), j = Math.ceil(j);
      if (u > 0)
        for (; i2 <= j; ++i2) {
          for (k = 1; k < base2; ++k) {
            t2 = i2 < 0 ? k / pows(-i2) : k * pows(i2);
            if (t2 < u)
              continue;
            if (t2 > v)
              break;
            z.push(t2);
          }
        }
      else
        for (; i2 <= j; ++i2) {
          for (k = base2 - 1; k >= 1; --k) {
            t2 = i2 > 0 ? k / pows(-i2) : k * pows(i2);
            if (t2 < u)
              continue;
            if (t2 > v)
              break;
            z.push(t2);
          }
        }
      if (z.length * 2 < n)
        z = ticks(u, v, n);
    } else {
      z = ticks(i2, j, Math.min(j - i2, n)).map(pows);
    }
    return r2 ? z.reverse() : z;
  };
  scale.tickFormat = (count2, specifier) => {
    if (count2 == null)
      count2 = 10;
    if (specifier == null)
      specifier = base2 === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base2 % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format$1(specifier);
    }
    if (count2 === Infinity)
      return specifier;
    const k = Math.max(1, base2 * count2 / scale.ticks().length);
    return (d) => {
      let i2 = d / pows(Math.round(logs(d)));
      if (i2 * base2 < base2 - 0.5)
        i2 *= base2;
      return i2 <= k ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: (x22) => pows(Math.floor(logs(x22))),
      ceil: (x22) => pows(Math.ceil(logs(x22)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}
function quantize() {
  var x0 = 0, x1 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
  function scale(x22) {
    return x22 != null && x22 <= x22 ? range2[bisect(domain, x22, 0, n)] : unknown;
  }
  function rescale() {
    var i2 = -1;
    domain = new Array(n);
    while (++i2 < n)
      domain[i2] = ((i2 + 1) * x1 - (i2 - n) * x0) / (n + 1);
    return scale;
  }
  scale.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale.range = function(_) {
    return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i2 = range2.indexOf(y2);
    return i2 < 0 ? [NaN, NaN] : i2 < 1 ? [x0, domain[0]] : i2 >= n ? [domain[n - 1], x1] : [domain[i2 - 1], domain[i2]];
  };
  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x0, x1]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
function newInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step) {
    return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval2.range = function(start2, stop, step) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step = step == null ? 1 : Math.floor(step);
    if (!(start2 < stop) || !(step > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step) {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end) {
      t0.setTime(+start2), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval2.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step === 0;
      } : function(d) {
        return interval2.count(0, d) % step === 0;
      });
    };
  }
  return interval2;
}
function weekday(i2) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i2) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setDate(date2.getDate() + step * 7);
  }, function(start2, end) {
    return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
function utcWeekday(i2) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i2) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, function(start2, end) {
    return (end - start2) / durationWeek;
  });
}
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [utcSecond, 1, durationSecond],
    [utcSecond, 5, 5 * durationSecond],
    [utcSecond, 15, 15 * durationSecond],
    [utcSecond, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function ticks2(start2, stop, count2) {
    const reverse = stop < start2;
    if (reverse)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i2 = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i2 === tickIntervals.length)
      return year2.every(tickStep(start2 / durationYear, stop / durationYear, count2));
    if (i2 === 0)
      return millisecond$1.every(Math.max(tickStep(start2, stop, count2), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i2 - 1][2] < tickIntervals[i2][2] / target ? i2 - 1 : i2];
    return t2.every(step);
  }
  return [ticks2, tickInterval];
}
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m2, d) {
  return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i2 = -1, j = 0, n = specifier.length, c, pad2, format22;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i2 < n) {
        if (specifier.charCodeAt(i2) === 37) {
          string.push(specifier.slice(j, i2));
          if ((pad2 = pads[c = specifier.charAt(++i2)]) != null)
            c = specifier.charAt(++i2);
          else
            pad2 = c === "e" ? " " : "0";
          if (format22 = formats2[c])
            c = format22(date2, pad2);
          string.push(c);
          j = i2 + 1;
        }
      }
      string.push(specifier.slice(j, i2));
      return string.join("");
    };
  }
  function newParse(specifier, Z2) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i2 = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i2 != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z2 && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i2 = 0, n = specifier.length, m2 = string.length, c, parse;
    while (i2 < n) {
      if (j >= m2)
        return -1;
      c = specifier.charCodeAt(i2++);
      if (c === 37) {
        c = specifier.charAt(i2++);
        parse = parses[c in pads ? specifier.charAt(i2++) : c];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i2) {
    var n = periodRe.exec(string.slice(i2));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i2) {
    var n = shortWeekdayRe.exec(string.slice(i2));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseWeekday(d, string, i2) {
    var n = weekdayRe.exec(string.slice(i2));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i2) {
    var n = shortMonthRe.exec(string.slice(i2));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseMonth(d, string, i2) {
    var n = monthRe.exec(string.slice(i2));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i2 + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i2) {
    return parseSpecifier(d, locale_dateTime, string, i2);
  }
  function parseLocaleDate(d, string, i2) {
    return parseSpecifier(d, locale_date, string, i2);
  }
  function parseLocaleTime(d, string, i2) {
    return parseSpecifier(d, locale_time, string, i2);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f3 = newFormat(specifier += "", formats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f3 = newFormat(specifier += "", utcFormats);
      f3.toString = function() {
        return specifier;
      };
      return f3;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
function pad(value2, fill, width) {
  var sign2 = value2 < 0 ? "-" : "", string = (sign2 ? -value2 : value2) + "", length = string.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s3) {
  return s3.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i2) => [name.toLowerCase(), i2]));
}
function parseWeekdayNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.w = +n[0], i2 + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.u = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.U = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.V = +n[0], i2 + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.W = +n[0], i2 + n[0].length) : -1;
}
function parseFullYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 4));
  return n ? (d.y = +n[0], i2 + n[0].length) : -1;
}
function parseYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i2 + n[0].length) : -1;
}
function parseZone(d, string, i2) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i2, i2 + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i2 + n[0].length) : -1;
}
function parseQuarter(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 1));
  return n ? (d.q = n[0] * 3 - 3, i2 + n[0].length) : -1;
}
function parseMonthNumber(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.m = n[0] - 1, i2 + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.d = +n[0], i2 + n[0].length) : -1;
}
function parseDayOfYear(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.m = 0, d.d = +n[0], i2 + n[0].length) : -1;
}
function parseHour24(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.H = +n[0], i2 + n[0].length) : -1;
}
function parseMinutes(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.M = +n[0], i2 + n[0].length) : -1;
}
function parseSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 2));
  return n ? (d.S = +n[0], i2 + n[0].length) : -1;
}
function parseMilliseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 3));
  return n ? (d.L = +n[0], i2 + n[0].length) : -1;
}
function parseMicroseconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2, i2 + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i2 + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i2) {
  var n = percentRe.exec(string.slice(i2, i2 + 1));
  return n ? i2 + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.Q = +n[0], i2 + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i2) {
  var n = numberRe.exec(string.slice(i2));
  return n ? (d.s = +n[0], i2 + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
function defaultLocale$1(definition) {
  locale$1 = formatLocale(definition);
  timeFormat = locale$1.format;
  return locale$1;
}
function date(t2) {
  return new Date(t2);
}
function number$1(t2) {
  return t2 instanceof Date ? +t2 : +new Date(+t2);
}
function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format22) {
  var scale = continuous(), invert = scale.invert, domain = scale.domain;
  var formatMillisecond = format22(".%L"), formatSecond = format22(":%S"), formatMinute = format22("%I:%M"), formatHour = format22("%I %p"), formatDay = format22("%a %d"), formatWeek = format22("%b %d"), formatMonth = format22("%B"), formatYear2 = format22("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number$1)) : domain().map(date);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format22(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy(scale, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format22));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function Path$1() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path$1() {
  return new Path$1();
}
function constant$4(x22) {
  return function constant2() {
    return x22;
  };
}
function acos(x22) {
  return x22 > 1 ? 0 : x22 < -1 ? pi$1 : Math.acos(x22);
}
function asin(x22) {
  return x22 >= 1 ? halfPi : x22 <= -1 ? -halfPi : Math.asin(x22);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect(x0, y0, x1, y1, x22, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x22, y32 = y3 - y2, t2 = y32 * x10 - x32 * y10;
  if (t2 * t2 < epsilon$2)
    return;
  t2 = (x32 * (y0 - y2) - y32 * (x0 - x22)) / t2;
  return [x0 + t2 * x10, y0 + t2 * y10];
}
function cornerTangents(x0, y0, x1, y1, r1, rc, cw2) {
  var x01 = x0 - x1, y01 = y0 - y1, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r2 = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max$2(0, r2 * r2 * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r2 - 1),
    y11: cy0 * (r1 / r2 - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$4(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc2() {
    var buffer, r2, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs$1(a1 - a0), cw2 = a1 > a0;
    if (!context)
      context = buffer = path$1();
    if (r1 < r0)
      r2 = r1, r1 = r0, r0 = r2;
    if (!(r1 > epsilon$2))
      context.moveTo(0, 0);
    else if (da > tau$1 - epsilon$2) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw2);
      if (r0 > epsilon$2) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw2);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$2 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min$2(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$2) {
        var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon$2)
          p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$2)
          p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon$2) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x00 = r0 * cos(a00), y00 = r0 * sin(a00), oc;
        if (da < pi$1 && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$2(rc, (r0 - lc) / (kc - 1));
          rc1 = min$2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$2))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$2) {
        t02 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw2);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw2);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
      if (!(r0 > epsilon$2) || !(da0 > epsilon$2))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$2) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
        t12 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw2);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw2);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw2);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw2);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw2);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw2);
    }
    context.closePath();
    if (buffer)
      return context = null, buffer + "" || null;
  }
  arc2.centroid = function() {
    var r2 = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$1 / 2;
    return [cos(a) * r2, sin(a) * r2];
  };
  arc2.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$4(+_), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), arc2) : padRadius;
  };
  arc2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : startAngle;
  };
  arc2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : endAngle;
  };
  arc2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), arc2) : padAngle;
  };
  arc2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, arc2) : context;
  };
  return arc2;
}
function array$1(x22) {
  return typeof x22 === "object" && "length" in x22 ? x22 : Array.from(x22);
}
function Linear(context) {
  this._context = context;
}
function curveLinear(context) {
  return new Linear(context);
}
function x$1(p) {
  return p[0];
}
function y$1(p) {
  return p[1];
}
function line(x22, y2) {
  var defined = constant$4(true), context = null, curve = curveLinear, output = null;
  x22 = typeof x22 === "function" ? x22 : x22 === void 0 ? x$1 : constant$4(x22);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$1 : constant$4(y2);
  function line2(data) {
    var i2, n = (data = array$1(data)).length, d, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path$1());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x22(d, i2, data), +y2(d, i2, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line2.x = function(_) {
    return arguments.length ? (x22 = typeof _ === "function" ? _ : constant$4(+_), line2) : x22;
  };
  line2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), line2) : y2;
  };
  line2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), line2) : defined;
  };
  line2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line2) : context;
  };
  return line2;
}
function area(x0, y0, y1) {
  var x1 = null, defined = constant$4(true), context = null, curve = curveLinear, output = null;
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x$1 : constant$4(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$4(0) : constant$4(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y$1 : constant$4(+y1);
  function area2(data) {
    var i2, j, k, n = (data = array$1(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer = path$1());
    for (i2 = 0; i2 <= n; ++i2) {
      if (!(i2 < n && defined(d = data[i2], i2, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i2;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i2 - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i2] = +x0(d, i2, data), y0z[i2] = +y0(d, i2, data);
        output.point(x1 ? +x1(d, i2, data) : x0z[i2], y1 ? +y1(d, i2, data) : y0z[i2]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), x1 = null, area2) : x0;
  };
  area2.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$4(+_), area2) : x0;
  };
  area2.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : x1;
  };
  area2.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), y1 = null, area2) : y0;
  };
  area2.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$4(+_), area2) : y0;
  };
  area2.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$4(+_), area2) : y1;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area2.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area2.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$4(!!_), area2) : defined;
  };
  area2.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area2) : context;
  };
  return area2;
}
function descending(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
function identity$1(d) {
  return d;
}
function pie() {
  var value2 = identity$1, sortValues = descending, sort = null, startAngle = constant$4(0), endAngle = constant$4(tau$1), padAngle = constant$4(0);
  function pie2(data) {
    var i2, n = (data = array$1(data)).length, j, k, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$1, Math.max(-tau$1, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i2 = 0; i2 < n; ++i2) {
      if ((v = arcs[index2[i2] = i2] = +value2(data[i2], i2, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i22, j2) {
        return sortValues(arcs[i22], arcs[j2]);
      });
    else if (sort != null)
      index2.sort(function(i22, j2) {
        return sort(data[i22], data[j2]);
      });
    for (i2 = 0, k = sum2 ? (da - n * pa) / sum2 : 0; i2 < n; ++i2, a0 = a1) {
      j = index2[i2], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i2,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$4(+_), pie2) : value2;
  };
  pie2.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie2) : sortValues;
  };
  pie2.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie2) : sort;
  };
  pie2.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : startAngle;
  };
  pie2.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : endAngle;
  };
  pie2.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$4(+_), pie2) : padAngle;
  };
  return pie2;
}
function Radial(curve) {
  this._curve = curve;
}
function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }
  radial._curve = curve;
  return radial;
}
function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };
  return l;
}
function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}
function bumpX(context) {
  return new Bump(context, true);
}
function linkSource$1(d) {
  return d.source;
}
function linkTarget$1(d) {
  return d.target;
}
function link$1(curve) {
  let source = linkSource$1;
  let target = linkTarget$1;
  let x22 = x$1;
  let y2 = y$1;
  let context = null;
  let output = null;
  function link2() {
    let buffer;
    const argv = slice$1.call(arguments);
    const s3 = source.apply(this, argv);
    const t2 = target.apply(this, argv);
    if (context == null)
      output = curve(buffer = path$1());
    output.lineStart();
    argv[0] = s3, output.point(+x22.apply(this, argv), +y2.apply(this, argv));
    argv[0] = t2, output.point(+x22.apply(this, argv), +y2.apply(this, argv));
    output.lineEnd();
    if (buffer)
      return output = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x22 = typeof _ === "function" ? _ : constant$4(+_), link2) : x22;
  };
  link2.y = function(_) {
    return arguments.length ? (y2 = typeof _ === "function" ? _ : constant$4(+_), link2) : y2;
  };
  link2.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link2) : context;
  };
  return link2;
}
function linkHorizontal$1() {
  return link$1(bumpX);
}
function noop$2() {
}
function point$3(that, x22, y2) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x22) / 6, (that._y0 + 4 * that._y1 + y2) / 6);
}
function Basis(context) {
  this._context = context;
}
function curveBasis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
function curveBasisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
function curveBasisOpen(context) {
  return new BasisOpen(context);
}
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
function point$2(that, x22, y2) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x22), that._y2 + that._k * (that._y1 - y2), that._x2, that._y2);
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
function point$1(that, x22, y2) {
  var x1 = that._x1, y1 = that._y1, x222 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$2) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon$2) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x222 = (x222 * b + that._x1 * that._l23_2a - x22 * that._l12_2a) / m2;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
  }
  that._context.bezierCurveTo(x1, y1, x222, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
function LinearClosed(context) {
  this._context = context;
}
function curveLinearClosed(context) {
  return new LinearClosed(context);
}
function sign(x22) {
  return x22 < 0 ? -1 : 1;
}
function slope3(that, x22, y2) {
  var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
function ReflectContext(context) {
  this._context = context;
}
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
function controlPoints(x22) {
  var i2, n = x22.length - 1, m2, a = new Array(n), b = new Array(n), r2 = new Array(n);
  a[0] = 0, b[0] = 2, r2[0] = x22[0] + 2 * x22[1];
  for (i2 = 1; i2 < n - 1; ++i2)
    a[i2] = 1, b[i2] = 4, r2[i2] = 4 * x22[i2] + 2 * x22[i2 + 1];
  a[n - 1] = 2, b[n - 1] = 7, r2[n - 1] = 8 * x22[n - 1] + x22[n];
  for (i2 = 1; i2 < n; ++i2)
    m2 = a[i2] / b[i2 - 1], b[i2] -= m2, r2[i2] -= m2 * r2[i2 - 1];
  a[n - 1] = r2[n - 1] / b[n - 1];
  for (i2 = n - 2; i2 >= 0; --i2)
    a[i2] = (r2[i2] - a[i2 + 1]) / b[i2];
  b[n - 1] = (x22[n] + a[n - 1]) / 2;
  for (i2 = 0; i2 < n - 1; ++i2)
    b[i2] = 2 * x22[i2 + 1] - a[i2 + 1];
  return [a, b];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function none$1(series, order) {
  if (!((n = series.length) > 1))
    return;
  for (var i2 = 1, j, s0, s1 = series[order[0]], n, m2 = s1.length; i2 < n; ++i2) {
    s0 = s1, s1 = series[order[i2]];
    for (j = 0; j < m2; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function none(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
function stackValue(d, key2) {
  return d[key2];
}
function stackSeries(key2) {
  const series = [];
  series.key = key2;
  return series;
}
function stack() {
  var keys2 = constant$4([]), order = none, offset = none$1, value2 = stackValue;
  function stack2(data) {
    var sz = Array.from(keys2.apply(this, arguments), stackSeries), i2, n = sz.length, j = -1, oz;
    for (const d of data) {
      for (i2 = 0, ++j; i2 < n; ++i2) {
        (sz[i2][j] = [0, +value2(d, sz[i2].key, j, data)]).data = d;
      }
    }
    for (i2 = 0, oz = array$1(order(sz)); i2 < n; ++i2) {
      sz[oz[i2]].index = i2;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_) {
    return arguments.length ? (keys2 = typeof _ === "function" ? _ : constant$4(Array.from(_)), stack2) : keys2;
  };
  stack2.value = function(_) {
    return arguments.length ? (value2 = typeof _ === "function" ? _ : constant$4(+_), stack2) : value2;
  };
  stack2.order = function(_) {
    return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$4(Array.from(_)), stack2) : order;
  };
  stack2.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none$1 : _, stack2) : offset;
  };
  return stack2;
}
function stackOffsetDiverging(series, order) {
  if (!((n = series.length) > 0))
    return;
  for (var i2, j = 0, d, dy, yp, yn, n, m2 = series[order[0]].length; j < m2; ++j) {
    for (yp = yn = 0, i2 = 0; i2 < n; ++i2) {
      if ((dy = (d = series[order[i2]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
function toFloat(value2) {
  return parseFloat(value2) || 0;
}
function getBordersSize(styles) {
  var positions = [], len = arguments.length - 1;
  while (len-- > 0)
    positions[len] = arguments[len + 1];
  return positions.reduce(function(size, position) {
    var value2 = styles["border-" + position + "-width"];
    return size + toFloat(value2);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var i2 = 0, list = positions; i2 < list.length; i2 += 1) {
    var position = list[i2];
    var value2 = styles["padding-" + position];
    paddings[position] = toFloat(value2);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth;
  var clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(ref) {
  var x22 = ref.x;
  var y2 = ref.y;
  var width = ref.width;
  var height = ref.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x22,
    y: y2,
    width,
    height,
    top: y2,
    right: x22 + width,
    bottom: height + y2,
    left: x22
  });
  return rect;
}
function createRectInit(x22, y2, width, height) {
  return { x: x22, y: y2, width, height };
}
function toDate(argument) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number3 = Number(dirtyNumber);
  if (isNaN(number3)) {
    return number3;
  }
  return number3 < 0 ? Math.ceil(number3) : Math.floor(number3);
}
function addDays(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  date2.setDate(date2.getDate() + amount);
  return date2;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function addHours(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR$1);
}
function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date2 = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = Math.ceil(date2.getTimezoneOffset());
  date2.setSeconds(0, 0);
  var millisecondsPartOfTimezoneOffset = date2.getTime() % MILLISECONDS_IN_MINUTE$2;
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE$2 + millisecondsPartOfTimezoneOffset;
}
function startOfDay(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
function addMinutes(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE$1);
}
function getDaysInMonth(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var year2 = date2.getFullYear();
  var monthIndex = date2.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year2, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function addMonths(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  var desiredMonth = date2.getMonth() + amount;
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(date2.getFullYear(), desiredMonth, 1);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date2.setMonth(desiredMonth, Math.min(daysInMonth, date2.getDate()));
  return date2;
}
function addSeconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1e3);
}
function addYears(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function isValid(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  return !isNaN(date2);
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function differenceInDays(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarDays(dateLeft, dateRight));
  dateLeft.setDate(dateLeft.getDate() - sign2 * difference);
  var isLastDayNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastDayNotFull);
  return result === 0 ? 0 : result;
}
function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getTime() - dateRight.getTime();
}
function differenceInHours(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_HOUR;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function differenceInMinutes(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / MILLISECONDS_IN_MINUTE;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  dateLeft.setMonth(dateLeft.getMonth() - sign2 * difference);
  var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastMonthNotFull);
  return result === 0 ? 0 : result;
}
function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1e3;
  return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
}
function differenceInYears(dirtyDateLeft, dirtyDateRight) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign2 = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarYears(dateLeft, dateRight));
  dateLeft.setFullYear(dateLeft.getFullYear() - sign2 * difference);
  var isLastYearNotFull = compareAsc(dateLeft, dateRight) === -sign2;
  var result = sign2 * (difference - isLastYearNotFull);
  return result === 0 ? 0 : result;
}
function formatDistance(token, count2, options2) {
  options2 = options2 || {};
  var result;
  if (typeof formatDistanceLocale[token] === "string") {
    result = formatDistanceLocale[token];
  } else if (count2 === 1) {
    result = formatDistanceLocale[token].one;
  } else {
    result = formatDistanceLocale[token].other.replace("{{count}}", count2);
  }
  if (options2.addSuffix) {
    if (options2.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
}
function buildFormatLongFn(args) {
  return function(dirtyOptions) {
    var options2 = dirtyOptions || {};
    var width = options2.width ? String(options2.width) : args.defaultWidth;
    var format22 = args.formats[width] || args.formats[args.defaultWidth];
    return format22;
  };
}
function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
}
function buildLocalizeFn(args) {
  return function(dirtyIndex, dirtyOptions) {
    var options2 = dirtyOptions || {};
    var context = options2.context ? String(options2.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options2.width ? String(options2.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options2.width ? String(options2.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
function ordinalNumber(dirtyNumber, _dirtyOptions) {
  var number3 = Number(dirtyNumber);
  var rem100 = number3 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number3 + "st";
      case 2:
        return number3 + "nd";
      case 3:
        return number3 + "rd";
    }
  }
  return number3 + "th";
}
function buildMatchPatternFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) {
      return null;
    }
    var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
    return {
      value: value2,
      rest: string.slice(matchedString.length)
    };
  };
}
function buildMatchFn(args) {
  return function(dirtyString, dirtyOptions) {
    var string = String(dirtyString);
    var options2 = dirtyOptions || {};
    var width = options2.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var value2;
    if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
      value2 = findIndex(parsePatterns, function(pattern) {
        return pattern.test(string);
      });
    } else {
      value2 = findKey(parsePatterns, function(pattern) {
        return pattern.test(string);
      });
    }
    value2 = args.valueCallback ? args.valueCallback(value2) : value2;
    value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
    return {
      value: value2,
      rest: string.slice(matchedString.length)
    };
  };
}
function findKey(object2, predicate) {
  for (var key2 in object2) {
    if (object2.hasOwnProperty(key2) && predicate(object2[key2])) {
      return key2;
    }
  }
}
function findIndex(array2, predicate) {
  for (var key2 = 0; key2 < array2.length; key2++) {
    if (predicate(array2[key2])) {
      return key2;
    }
  }
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
function addLeadingZeros(number3, targetLength) {
  var sign2 = number3 < 0 ? "-" : "";
  var output = Math.abs(number3).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign2 + output;
}
function getUTCDayOfYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var timestamp = date2.getTime();
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date2.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var weekStartsOn = 1;
  var date2 = toDate(dirtyDate);
  var day2 = date2.getUTCDay();
  var diff = (day2 < weekStartsOn ? 7 : 0) + day2 - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCISOWeekYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var year2 = date2.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year2 + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year2, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year2 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year2;
  } else {
    return year2 - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var year2 = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year2, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCISOWeek(fourthOfJanuary);
  return date2;
}
function getUTCISOWeek(dirtyDate) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date2).getTime() - startOfUTCISOWeekYear(date2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day2 = date2.getUTCDay();
  var diff = (day2 < weekStartsOn ? 7 : 0) + day2 - weekStartsOn;
  date2.setUTCDate(date2.getUTCDate() - diff);
  date2.setUTCHours(0, 0, 0, 0);
  return date2;
}
function getUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate, dirtyOptions);
  var year2 = date2.getUTCFullYear();
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year2 + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year2, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year2 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year2;
  } else {
    return year2 - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  var year2 = getUTCWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year2, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date2 = startOfUTCWeek(firstWeek, dirtyOptions);
  return date2;
}
function getUTCWeek(dirtyDate, options2) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  var date2 = toDate(dirtyDate);
  var diff = startOfUTCWeek(date2, options2).getTime() - startOfUTCWeekYear(date2, options2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign2 + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign2 + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign2 = offset > 0 ? "-" : "+";
    return sign2 + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign2 = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign2 + hours + delimiter + minutes;
}
function dateLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
}
function timeLongFormatter(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
}
function dateTimeLongFormatter(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/);
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
}
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr");
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr");
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr");
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr");
  }
}
function format2(dirtyDate, dirtyFormatStr, dirtyOptions) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var formatStr = String(dirtyFormatStr);
  var options2 = dirtyOptions || {};
  var locale2 = options2.locale || defaultLocale;
  var localeFirstWeekContainsDate = locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options2.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options2.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var localeWeekStartsOn = locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options2.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options2.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate2 = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong, formatterOptions);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!options2.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring);
      }
      if (!options2.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring);
      }
      return formatter(utcDate2, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function subDays(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function subHours(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addHours(dirtyDate, -amount);
}
function subMinutes(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMinutes(dirtyDate, -amount);
}
function subMonths(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function subSeconds(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addSeconds(dirtyDate, -amount);
}
function subYears(dirtyDate, dirtyAmount) {
  if (arguments.length < 2) {
    throw new TypeError("2 arguments required, but only " + arguments.length + " present");
  }
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
function addSpacingToTimeDomain(domain, spaceToAddToEdges) {
  var startDate = new Date(domain[0]);
  var endDate = new Date(domain[1]);
  if (differenceInYears(endDate, startDate) > 1) {
    return [
      subYears(startDate, spaceToAddToEdges),
      addYears(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInMonths(endDate, startDate) > 1) {
    return [
      subMonths(startDate, spaceToAddToEdges),
      addMonths(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInDays(endDate, startDate) > 1) {
    return [
      subDays(startDate, spaceToAddToEdges),
      addDays(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInHours(endDate, startDate) > 1) {
    return [
      subHours(startDate, spaceToAddToEdges),
      addHours(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInMinutes(endDate, startDate) > 30) {
    return [
      subMinutes(startDate, spaceToAddToEdges * 30),
      addMinutes(endDate, spaceToAddToEdges * 30)
    ];
  }
  if (differenceInMinutes(endDate, startDate) > 1) {
    return [
      subMinutes(startDate, spaceToAddToEdges),
      addMinutes(endDate, spaceToAddToEdges)
    ];
  }
  if (differenceInSeconds(endDate, startDate) > 15) {
    return [
      subSeconds(startDate, spaceToAddToEdges * 15),
      addSeconds(endDate, spaceToAddToEdges * 15)
    ];
  }
  if (differenceInSeconds(endDate, startDate) > 1) {
    return [
      subSeconds(startDate, spaceToAddToEdges),
      addSeconds(endDate, spaceToAddToEdges)
    ];
  }
  return [startDate, endDate];
}
function addSpacingToContinuousDomain(_a22, paddingRatio, scaleType) {
  var lower22 = _a22[0], upper = _a22[1];
  var domainLength = upper - lower22;
  var padding = domainLength * paddingRatio;
  var newUpper = upper <= 0 && upper + padding > 0 ? 0 : upper + padding;
  var newLower = lower22 >= 0 && lower22 - padding < 0 ? 0 : lower22 - padding;
  if (scaleType === ScaleTypes.LOG && newLower <= 0) {
    if (lower22 <= 0) {
      throw Error("Data must have values greater than 0 if log scale type is used.");
    }
    newLower = lower22;
  }
  return [newLower, newUpper];
}
function identity(x22) {
  return x22;
}
function translateX(x22) {
  return "translate(" + x22 + ",0)";
}
function translateY(y2) {
  return "translate(0," + y2 + ")";
}
function number(scale) {
  return (d) => +scale(d);
}
function center(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k = orient === top || orient === left ? -1 : 1, x22 = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format22 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position = (scale.bandwidth ? center : number)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x22 + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x22, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$1).attr("transform", function(d) {
        return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$1).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform(position(d) + offset);
    });
    line2.attr(x22 + "2", k * tickSizeInner);
    text.attr(x22, k * spacing).text(format22);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position;
    });
  }
  axis2.scale = function(_) {
    return arguments.length ? (scale = _, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_) {
    return arguments.length ? (tickFormat2 = _, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis2) : tickPadding;
  };
  axis2.offset = function(_) {
    return arguments.length ? (offset = +_, axis2) : offset;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function flatten(a) {
  return a.reduce(function(result, item) {
    if (Array.isArray(item)) {
      result.push.apply(result, _toConsumableArray$1(flatten(item)));
    } else {
      result.push(item);
    }
    return result;
  }, []);
}
function mixin() {
  for (var _len = arguments.length, mixinfns = new Array(_len), _key = 0; _key < _len; _key++) {
    mixinfns[_key] = arguments[_key];
  }
  return flatten(mixinfns).reduce(function(Class, mixinfn) {
    return mixinfn(Class);
  }, /* @__PURE__ */ function() {
    function _class() {
      _classCallCheck$6(this, _class);
    }
    return _class;
  }());
}
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function createComponent(ToMix) {
  var CreateComponent = /* @__PURE__ */ function(_ToMix) {
    _inherits$5(CreateComponent2, _ToMix);
    var _super = _createSuper$5(CreateComponent2);
    function CreateComponent2(element) {
      var _this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck$5(this, CreateComponent2);
      _this = _super.call(this, element, options2);
      _this.children = [];
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError("DOM element should be given to initialize this widget.");
      }
      _this.element = element;
      _this.options = Object.assign(Object.create(_this.constructor.options), options2);
      _this.constructor.components.set(_this.element, _assertThisInitialized$5(_this));
      return _this;
    }
    _createClass$5(CreateComponent2, [{
      key: "release",
      value: function release() {
        for (var child = this.children.pop(); child; child = this.children.pop()) {
          child.release();
        }
        this.constructor.components.delete(this.element);
        return null;
      }
    }], [{
      key: "create",
      value: function create2(element, options2) {
        return this.components.get(element) || new this(element, options2);
      }
    }]);
    return CreateComponent2;
  }(ToMix);
  return CreateComponent;
}
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _get(target, property2, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target2, property3, receiver2) {
      var base2 = _superPropBase(target2, property3);
      if (!base2)
        return;
      var desc = Object.getOwnPropertyDescriptor(base2, property3);
      if (desc.get) {
        return desc.get.call(receiver2);
      }
      return desc.value;
    };
  }
  return _get(target, property2, receiver || target);
}
function _superPropBase(object2, property2) {
  while (!Object.prototype.hasOwnProperty.call(object2, property2)) {
    object2 = _getPrototypeOf$4(object2);
    if (object2 === null)
      break;
  }
  return object2;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function handles(ToMix) {
  var Handles = /* @__PURE__ */ function(_ToMix) {
    _inherits$4(Handles2, _ToMix);
    var _super = _createSuper$4(Handles2);
    function Handles2() {
      var _this;
      _classCallCheck$4(this, Handles2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.handles = /* @__PURE__ */ new Set();
      return _this;
    }
    _createClass$4(Handles2, [{
      key: "manage",
      value: function manage(handle2) {
        this.handles.add(handle2);
        return handle2;
      }
    }, {
      key: "unmanage",
      value: function unmanage(handle2) {
        this.handles.delete(handle2);
        return handle2;
      }
    }, {
      key: "release",
      value: function release() {
        var _this2 = this;
        this.handles.forEach(function(handle2) {
          handle2.release();
          _this2.handles.delete(handle2);
        });
        return _get(_getPrototypeOf$4(Handles2.prototype), "release", this).call(this);
      }
    }]);
    return Handles2;
  }(ToMix);
  return Handles;
}
function on(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  element.addEventListener.apply(element, args);
  return {
    release: function release() {
      element.removeEventListener.apply(element, args);
      return null;
    }
  };
}
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function eventedState(ToMix) {
  var EventedState = /* @__PURE__ */ function(_ToMix) {
    _inherits$3(EventedState2, _ToMix);
    var _super = _createSuper$3(EventedState2);
    function EventedState2() {
      _classCallCheck$3(this, EventedState2);
      return _super.apply(this, arguments);
    }
    _createClass$3(EventedState2, [{
      key: "_changeState",
      value: function _changeState() {
        throw new Error("_changeState() should be overriden to perform actual change in state.");
      }
    }, {
      key: "changeState",
      value: function changeState() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var state = typeof args[0] === "string" ? args.shift() : void 0;
        var detail = Object(args[0]) === args[0] && typeof args[0] !== "function" ? args.shift() : void 0;
        var callback = typeof args[0] === "function" ? args.shift() : void 0;
        if (typeof this.shouldStateBeChanged === "function" && !this.shouldStateBeChanged(state, detail)) {
          if (callback) {
            callback(null, true);
          }
          return;
        }
        var data = {
          group: detail && detail.group,
          state
        };
        var eventNameSuffix = [data.group, state].filter(Boolean).join("-").split("-").map(function(item) {
          return item[0].toUpperCase() + item.substr(1);
        }).join("");
        var eventStart = new CustomEvent(this.options["eventBefore".concat(eventNameSuffix)], {
          bubbles: true,
          cancelable: true,
          detail
        });
        var fireOnNode = detail && detail.delegatorNode || this.element;
        var canceled = !fireOnNode.dispatchEvent(eventStart);
        if (canceled) {
          if (callback) {
            var error2 = new Error("Changing state (".concat(JSON.stringify(data), ") has been canceled."));
            error2.canceled = true;
            callback(error2);
          }
        } else {
          var changeStateArgs = [state, detail].filter(Boolean);
          this._changeState.apply(this, _toConsumableArray(changeStateArgs).concat([function() {
            fireOnNode.dispatchEvent(new CustomEvent(_this.options["eventAfter".concat(eventNameSuffix)], {
              bubbles: true,
              cancelable: true,
              detail
            }));
            if (callback) {
              callback();
            }
          }]));
        }
      }
    }]);
    return EventedState2;
  }(ToMix);
  return EventedState;
}
function eventMatches(event, selector2) {
  var target = event.target, currentTarget = event.currentTarget;
  if (typeof target.matches === "function") {
    if (target.matches(selector2)) {
      return target;
    }
    if (target.matches("".concat(selector2, " *"))) {
      var closest = target.closest(selector2);
      if ((currentTarget.nodeType === Node.DOCUMENT_NODE ? currentTarget.documentElement : currentTarget).contains(closest)) {
        return closest;
      }
    }
  }
  return void 0;
}
function getLaunchingDetails(evt) {
  if (!evt || typeof evt === "function") {
    return {
      launchingElement: null,
      launchingEvent: null
    };
  }
  var launchingElement = evt.delegateTarget || evt.currentTarget || evt;
  var launchingEvent = evt.currentTarget && evt;
  if (launchingElement && !launchingElement.nodeType) {
    throw new TypeError("DOM Node should be given for launching element.");
  }
  if (launchingEvent && !launchingEvent.type) {
    throw new TypeError("DOM event should be given for launching event.");
  }
  return {
    launchingElement,
    launchingEvent
  };
}
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function eventedShowHideState(ToMix) {
  var EventedShowHideState = /* @__PURE__ */ function(_ToMix) {
    _inherits$2(EventedShowHideState2, _ToMix);
    var _super = _createSuper$2(EventedShowHideState2);
    function EventedShowHideState2() {
      _classCallCheck$2(this, EventedShowHideState2);
      return _super.apply(this, arguments);
    }
    _createClass$2(EventedShowHideState2, [{
      key: "show",
      value: function show(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === "function") {
          callback = evtOrElem;
        }
        this.changeState("shown", getLaunchingDetails(evtOrElem), callback);
      }
    }, {
      key: "hide",
      value: function hide(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === "function") {
          callback = evtOrElem;
        }
        this.changeState("hidden", getLaunchingDetails(evtOrElem), callback);
      }
    }]);
    return EventedShowHideState2;
  }(ToMix);
  return EventedShowHideState;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function initComponentByLauncher(ToMix) {
  var InitComponentByLauncher = /* @__PURE__ */ function(_ToMix) {
    _inherits$1(InitComponentByLauncher2, _ToMix);
    var _super = _createSuper$1(InitComponentByLauncher2);
    function InitComponentByLauncher2() {
      _classCallCheck$1(this, InitComponentByLauncher2);
      return _super.apply(this, arguments);
    }
    _createClass$1(InitComponentByLauncher2, null, [{
      key: "init",
      value: function init22() {
        var _this = this;
        var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var effectiveOptions = Object.assign(Object.create(this.options), options2);
        if (!target || target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new TypeError("DOM document or DOM element should be given to search for and initialize this widget.");
        }
        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options2);
        } else {
          var handles2 = effectiveOptions.initEventNames.map(function(name) {
            return on(target, name, function(event) {
              var launcher = eventMatches(event, "[".concat(effectiveOptions.attribInitTarget, "]"));
              if (launcher) {
                event.delegateTarget = launcher;
                var elements = launcher.ownerDocument.querySelectorAll(launcher.getAttribute(effectiveOptions.attribInitTarget));
                if (elements.length > 1) {
                  throw new Error("Target widget must be unique.");
                }
                if (elements.length === 1) {
                  if (launcher.tagName === "A") {
                    event.preventDefault();
                  }
                  var component = _this.create(elements[0], options2);
                  if (typeof component.createdByLauncher === "function") {
                    component.createdByLauncher(event);
                  }
                }
              }
            });
          });
          return {
            release: function release() {
              for (var handle2 = handles2.pop(); handle2; handle2 = handles2.pop()) {
                handle2.release();
              }
            }
          };
        }
        return "";
      }
    }]);
    InitComponentByLauncher2.forLazyInit = true;
    return InitComponentByLauncher2;
  }(ToMix);
  return InitComponentByLauncher;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function isTickPrimary(tick, i2, allTicks, interval2, showDayName) {
  var isFirstTick = i2 === 0;
  var hasANewWeekStarted = Number(format2(new Date(tick), "c")) === 2;
  var isFirstQuarter = Number(format2(new Date(tick), "q")) === 1;
  var previousTick = i2 !== 0 ? allTicks[i2 - 1] : null;
  switch (interval2) {
    case "15seconds":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "minute":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "30minutes":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "hourly":
      return isFirstTick || isDayOfMonthChanged(tick) || isMonthChanged(tick, previousTick) || isYearChanged(tick);
    case "daily":
      if (!showDayName) {
        return isFirstTick || isMonthChanged(tick, previousTick) || isYearChanged(tick);
      } else {
        return isFirstTick || hasANewWeekStarted || isYearChanged(tick);
      }
    case "monthly":
      return isFirstTick || isYearChanged(tick);
    case "quarterly":
      return isFirstTick || isFirstQuarter;
    case "yearly":
      return false;
    default:
      throw new Error(interval2 + " is not a valid time interval.");
  }
}
function formatTick(tick, i2, allTicks, interval2, timeScaleOptions) {
  var showDayName = timeScaleOptions.showDayName;
  var intervalConsideringAlsoShowDayNameOption = interval2 === "daily" && showDayName ? "weekly" : interval2;
  var date2 = new Date(tick);
  var formats = Tools.getProperty(timeScaleOptions, "timeIntervalFormats")[intervalConsideringAlsoShowDayNameOption];
  var primary = Tools.getProperty(formats, "primary");
  var secondary = Tools.getProperty(formats, "secondary");
  var formatString = isTickPrimary(tick, i2, allTicks, interval2, showDayName) ? primary : secondary;
  var locale2 = timeScaleOptions.localeObject;
  return format2(date2, formatString, { locale: locale2 });
}
function getTimeformats(timestamp) {
  var date2 = new Date(timestamp);
  return {
    M: date2.getMonth() + 1,
    d: date2.getDate(),
    H: date2.getHours(),
    m: date2.getMinutes(),
    s: date2.getSeconds()
  };
}
function getConsecutiveDifferences(elements) {
  if (!elements) {
    return;
  }
  return elements.slice(1).map(function(elem, i2) {
    return elem - elements[i2];
  });
}
function closestTimeIntervalName(duration) {
  var index2 = TIME_INTERVALS.reduce(function(nearestIndex, _a22, i2) {
    _a22[0];
    var delta = _a22[1];
    var deltaNearest = TIME_INTERVALS[nearestIndex][1];
    var oldNearestSpan = Math.abs(deltaNearest - duration);
    var currentSpan = Math.abs(delta - duration);
    return oldNearestSpan < currentSpan ? nearestIndex : i2;
  }, 0);
  return TIME_INTERVALS[index2][0];
}
function computeTimeIntervalName(ticks2) {
  if (ticks2.length === 1) {
    return "15seconds";
  }
  var differences = getConsecutiveDifferences(ticks2);
  var minDifference = min$3(differences);
  return closestTimeIntervalName(minDifference);
}
function isDayOfMonthChanged(timestamp) {
  var _a22 = getTimeformats(timestamp), s3 = _a22.s, m2 = _a22.m, H = _a22.H;
  return H === 0 && m2 === 0 && s3 === 0;
}
function isMonthChanged(timestamp, previousTimestamp) {
  var currentMonth = getTimeformats(timestamp).M;
  var previousMonth = getTimeformats(previousTimestamp).M;
  return currentMonth !== previousMonth;
}
function isYearChanged(timestamp) {
  var _a22 = getTimeformats(timestamp), M = _a22.M, d = _a22.d, s3 = _a22.s, m2 = _a22.m, H = _a22.H;
  return M === 1 && d === 1 && H === 0 && m2 === 0 && s3 === 0;
}
function arcTween(a, arcFunc) {
  var _this = this;
  var i2 = interpolate$1(this._current, a);
  return function(t2) {
    _this._current = i2(t2);
    return arcFunc(_this._current);
  };
}
function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children2) {
  return children2.reduce(meanXReduce, 0) / children2.length;
}
function meanXReduce(x22, c) {
  return x22 + c.x;
}
function maxY(children2) {
  return 1 + children2.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c) {
  return Math.max(y2, c.y);
}
function leafLeft(node) {
  var children2;
  while (children2 = node.children)
    node = children2[0];
  return node;
}
function leafRight(node) {
  var children2;
  while (children2 = node.children)
    node = children2[children2.length - 1];
  return node;
}
function d3Cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
  function cluster(root2) {
    var previousNode, x22 = 0;
    root2.eachAfter(function(node) {
      var children2 = node.children;
      if (children2) {
        node.x = meanX(children2);
        node.y = maxY(children2);
      } else {
        node.x = previousNode ? x22 += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root2.x) * dx;
      node.y = (root2.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
    });
  }
  cluster.separation = function(x22) {
    return arguments.length ? (separation = x22, cluster) : separation;
  };
  cluster.size = function(x22) {
    return arguments.length ? (nodeSize = false, dx = +x22[0], dy = +x22[1], cluster) : nodeSize ? null : [dx, dy];
  };
  cluster.nodeSize = function(x22) {
    return arguments.length ? (nodeSize = true, dx = +x22[0], dy = +x22[1], cluster) : nodeSize ? [dx, dy] : null;
  };
  return cluster;
}
function count(node) {
  var sum2 = 0, children2 = node.children, i2 = children2 && children2.length;
  if (!i2)
    sum2 = 1;
  else
    while (--i2 >= 0)
      sum2 += children2[i2].value;
  node.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children2, i2, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i2 = children2.length - 1; i2 >= 0; --i2) {
        nodes.push(children2[i2]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children2, i2, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i2 = 0, n = children2.length; i2 < n; ++i2) {
        nodes.push(children2[i2]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum(value2) {
  return this.eachAfter(function(node) {
    var sum2 = +value2(node.data) || 0, children2 = node.children, i2 = children2 && children2.length;
    while (--i2 >= 0)
      sum2 += children2[i2].value;
    node.value = sum2;
  });
}
function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
function node_path(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children2, i2, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i2 = 0, n = children2.length; i2 < n; ++i2) {
          next.push(children2[i2]);
        }
      }
    }
  } while (next.length);
}
function hierarchy(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0)
      children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node$2(data), node, nodes = [root2], child, childs, i2, n;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i2 = n - 1; i2 >= 0; --i2) {
        nodes.push(child = childs[i2] = new Node$2(childs[i2]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node$2(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
function array(x22) {
  return typeof x22 === "object" && "length" in x22 ? x22 : Array.from(x22);
}
function shuffle(array2) {
  var m2 = array2.length, t2, i2;
  while (m2) {
    i2 = Math.random() * m2-- | 0;
    t2 = array2[m2];
    array2[m2] = array2[i2];
    array2[i2] = t2;
  }
  return array2;
}
function enclose(circles) {
  var i2 = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e3;
  while (i2 < n) {
    p = circles[i2];
    if (e3 && enclosesWeak(e3, p))
      ++i2;
    else
      e3 = encloseBasis(B = extendBasis(B, p)), i2 = 0;
  }
  return e3;
}
function extendBasis(B, p) {
  var i2, j;
  if (enclosesWeakAll(p, B))
    return [p];
  for (i2 = 0; i2 < B.length; ++i2) {
    if (enclosesNot(p, B[i2]) && enclosesWeakAll(encloseBasis2(B[i2], p), B)) {
      return [B[i2], p];
    }
  }
  for (i2 = 0; i2 < B.length - 1; ++i2) {
    for (j = i2 + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i2], B[j]), p) && enclosesNot(encloseBasis2(B[i2], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i2]) && enclosesWeakAll(encloseBasis3(B[i2], B[j], p), B)) {
        return [B[i2], B[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
  for (var i2 = 0; i2 < B.length; ++i2) {
    if (!enclosesWeak(a, B[i2])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x22 = b.x, y2 = b.y, r2 = b.r, x21 = x22 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x22 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x22 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x22, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x22 * x22 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A2 = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r4 = -(A2 ? (B + Math.sqrt(B * B - 4 * A2 * C)) / (2 * A2) : C / B);
  return {
    x: x1 + xa + xb * r4,
    y: y1 + ya + yb * r4,
    r: r4
  };
}
function place(b, a, c) {
  var dx = b.x - a.x, x22, a2, dy = b.y - a.y, y2, b2, d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x22 = (d2 + b2 - a2) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b2 / d2 - x22 * x22));
      c.x = b.x - x22 * dx - y2 * dy;
      c.y = b.y - x22 * dy + y2 * dx;
    } else {
      x22 = (d2 + a2 - b2) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a2 / d2 - x22 * x22));
      c.x = a.x + x22 * dx - y2 * dy;
      c.y = a.y + x22 * dy + y2 * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array(circles)).length))
    return 0;
  var a, b, c, n, aa, ca, i2, j, k, sj, sk;
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1))
    return a.r;
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2))
    return a.r + b.r;
  place(b, a, c = circles[2]);
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;
  pack:
    for (i2 = 3; i2 < n; ++i2) {
      place(a._, b._, c = circles[i2]), c = new Node$1(c);
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i2;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i2;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c.previous = a, c.next = b, a.next = b.previous = b = c;
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }
  a = [b._], c = b;
  while ((c = c.next) !== b)
    a.push(c._);
  c = enclose(a);
  for (i2 = 0; i2 < n; ++i2)
    a = circles[i2], a.x -= c.x, a.y -= c.y;
  return c.r;
}
function optional(f3) {
  return f3 == null ? null : required(f3);
}
function required(f3) {
  if (typeof f3 !== "function")
    throw new Error();
  return f3;
}
function constantZero() {
  return 0;
}
function constant$3(x22) {
  return function() {
    return x22;
  };
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function D3Pack() {
  var radius = null, dx = 1, dy = 1, padding = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x22) {
    return arguments.length ? (radius = optional(x22), pack) : radius;
  };
  pack.size = function(x22) {
    return arguments.length ? (dx = +x22[0], dy = +x22[1], pack) : [dx, dy];
  };
  pack.padding = function(x22) {
    return arguments.length ? (padding = typeof x22 === "function" ? x22 : constant$3(+x22), pack) : padding;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding, k) {
  return function(node) {
    if (children2 = node.children) {
      var children2, i2, n = children2.length, r2 = padding(node) * k || 0, e3;
      if (r2)
        for (i2 = 0; i2 < n; ++i2)
          children2[i2].r += r2;
      e3 = packEnclose(children2);
      if (r2)
        for (i2 = 0; i2 < n; ++i2)
          children2[i2].r -= r2;
      node.r = e3 + r2;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}
function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i2 = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i2 < n) {
    node = nodes[i2], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children2 = v.children;
  return children2 ? children2[0] : v.t;
}
function nextRight(v) {
  var children2 = v.children;
  return children2 ? children2[children2.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children2 = v.children, i2 = children2.length, w;
  while (--i2 >= 0) {
    w = children2[i2];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i2) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i2;
}
function treeRoot(root2) {
  var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children2, i2, n;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n = children2.length);
      for (i2 = n - 1; i2 >= 0; --i2) {
        nodes.push(child = node.children[i2] = new TreeNode(children2[i2], i2));
        child.parent = node;
      }
    }
  }
  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}
function d3Tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree(root2) {
    var t2 = treeRoot(root2);
    t2.eachAfter(firstWalk), t2.parent.m = -t2.z;
    t2.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom2.depth)
          bottom2 = node;
      });
      var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx = dx / (right2.x + s3 + tx), ky = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children2 = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
    if (children2) {
      executeShifts(v);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree.separation = function(x22) {
    return arguments.length ? (separation = x22, tree) : separation;
  };
  tree.size = function(x22) {
    return arguments.length ? (nodeSize = false, dx = +x22[0], dy = +x22[1], tree) : nodeSize ? null : [dx, dy];
  };
  tree.nodeSize = function(x22) {
    return arguments.length ? (nodeSize = true, dx = +x22[0], dy = +x22[1], tree) : nodeSize ? [dx, dy] : null;
  };
  return tree;
}
function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i2 = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i2 < n) {
    node = nodes[i2], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else
      treemapSlice(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
function d3Treemap() {
  var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode);
    paddingStack = [0];
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap.round = function(x22) {
    return arguments.length ? (round = !!x22, treemap) : round;
  };
  treemap.size = function(x22) {
    return arguments.length ? (dx = +x22[0], dy = +x22[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x22) {
    return arguments.length ? (tile = required(x22), treemap) : tile;
  };
  treemap.padding = function(x22) {
    return arguments.length ? treemap.paddingInner(x22).paddingOuter(x22) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x22) {
    return arguments.length ? (paddingInner = typeof x22 === "function" ? x22 : constant$3(+x22), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x22) {
    return arguments.length ? treemap.paddingTop(x22).paddingRight(x22).paddingBottom(x22).paddingLeft(x22) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x22) {
    return arguments.length ? (paddingTop = typeof x22 === "function" ? x22 : constant$3(+x22), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x22) {
    return arguments.length ? (paddingRight = typeof x22 === "function" ? x22 : constant$3(+x22), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x22) {
    return arguments.length ? (paddingBottom = typeof x22 === "function" ? x22 : constant$3(+x22), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x22) {
    return arguments.length ? (paddingLeft = typeof x22 === "function" ? x22 : constant$3(+x22), treemap) : paddingLeft;
  };
  return treemap;
}
function radialLabelPlacement(angleRadians) {
  var angle = mod(radToDeg(angleRadians), 360);
  if (isInRange(angle, [0, 10]) || isInRange(angle, [350, 0])) {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.MIDDLE
    };
  } else if (isInRange(angle, [10, 80])) {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [80, 100])) {
    return {
      textAnchor: TextAnchor.MIDDLE,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [100, 170])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.HANGING
    };
  } else if (isInRange(angle, [170, 190])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.MIDDLE
    };
  } else if (isInRange(angle, [190, 260])) {
    return {
      textAnchor: TextAnchor.END,
      dominantBaseline: DominantBaseline.BASELINE
    };
  } else if (isInRange(angle, [260, 280])) {
    return {
      textAnchor: TextAnchor.MIDDLE,
      dominantBaseline: DominantBaseline.BASELINE
    };
  } else {
    return {
      textAnchor: TextAnchor.START,
      dominantBaseline: DominantBaseline.BASELINE
    };
  }
}
function mod(n, m2) {
  return (n % m2 + m2) % m2;
}
function isInRange(x22, _a22) {
  var min2 = _a22[0], max2 = _a22[1];
  return x22 >= min2 && x22 <= max2;
}
function radToDeg(rad) {
  return rad * (180 / Math.PI);
}
function polarToCartesianCoords(a, r2, t2) {
  if (t2 === void 0) {
    t2 = { x: 0, y: 0 };
  }
  var x22 = r2 * Math.cos(a) + t2.x;
  var y2 = r2 * Math.sin(a) + t2.y;
  return { x: isNaN(x22) ? 0 : x22, y: isNaN(y2) ? 0 : y2 };
}
function distanceBetweenPointOnCircAndVerticalDiameter(a, r2) {
  return r2 * Math.sin(a - Math.PI / 2);
}
function dispatch$2() {
  for (var i2 = 0, n = arguments.length, _ = {}, t2; i2 < n; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _ || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types2.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
function get$2(type2, name) {
  for (var i2 = 0, n = type2.length, c; i2 < n; ++i2) {
    if ((c = type2[i2]).name === name) {
      return c.value;
    }
  }
}
function set$2(type2, name, callback) {
  for (var i2 = 0, n = type2.length; i2 < n; ++i2) {
    if (type2[i2].name === name) {
      type2[i2] = noop$1, type2 = type2.slice(0, i2).concat(type2.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
function cloudText(d) {
  return d.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d) {
  return Math.sqrt(d.value);
}
function cloudRotate() {
  return (~~(Math.random() * 6) - 3) * 30;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x22 = 0, y2 = 0, maxh = 0, n = data.length;
  --di;
  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio, h2 = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h2 * cr, hsr = h2 * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h2 = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h2 > maxh)
      maxh = h2;
    if (x22 + w >= cw << 5) {
      x22 = 0;
      y2 += maxh;
      maxh = 0;
    }
    if (y2 + h2 >= ch)
      break;
    c.translate((x22 + (w >> 1)) / ratio, (y2 + (h2 >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding)
      c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);
    c.restore();
    d.width = w;
    d.height = h2;
    d.xoff = x22;
    d.yoff = y2;
    d.x1 = w >> 1;
    d.y1 = h2 >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x22 += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data[di];
    if (!d.hasText)
      continue;
    var w = d.width, w32 = w >> 5, h2 = d.y1 - d.y0;
    for (var i2 = 0; i2 < h2 * w32; i2++)
      sprite[i2] = 0;
    x22 = d.xoff;
    if (x22 == null)
      return;
    y2 = d.yoff;
    var seen = 0, seenRow = -1;
    for (var j = 0; j < h2; j++) {
      for (var i2 = 0; i2 < w; i2++) {
        var k = w32 * j + (i2 >> 5), m2 = pixels[(y2 + j) * (cw << 5) + (x22 + i2) << 2] ? 1 << 31 - i2 % 32 : 0;
        sprite[k] |= m2;
        seen |= m2;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h2--;
        j--;
        y2++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x22 = (tag.y + tag.y0) * sw + (lx >> 5), last2;
  for (var j = 0; j < h2; j++) {
    last2 = 0;
    for (var i2 = 0; i2 <= w; i2++) {
      if ((last2 << msx | (i2 < w ? (last2 = sprite[j * w + i2]) >>> sx : 0)) & board[x22 + i2])
        return true;
    }
    x22 += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b0 = bounds[0], b1 = bounds[1];
  if (d.x + d.x0 < b0.x)
    b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y)
    b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x)
    b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y)
    b1.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size) {
  var e3 = size[0] / size[1];
  return function(t2) {
    return [e3 * (t2 *= 0.1) * Math.cos(t2), t2 * Math.sin(t2)];
  };
}
function rectangularSpiral(size) {
  var dy = 4, dx = dy * size[0] / size[1], x22 = 0, y2 = 0;
  return function(t2) {
    var sign2 = t2 < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign2 * t2) - sign2 & 3) {
      case 0:
        x22 += dx;
        break;
      case 1:
        y2 += dy;
        break;
      case 2:
        x22 -= dx;
        break;
      default:
        y2 -= dy;
        break;
    }
    return [x22, y2];
  };
}
function zeroArray(n) {
  var a = [], i2 = -1;
  while (++i2 < n)
    a[i2] = 0;
  return a;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d) {
  return typeof d === "function" ? d : function() {
    return d;
  };
}
function max$1(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (max2 < value2 || max2 === void 0 && value2 >= value2)) {
        max2 = value2;
      }
    }
  }
  return max2;
}
function min$1(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value2 of values) {
      if (value2 != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if ((value2 = valueof(value2, ++index2, values)) != null && (min2 > value2 || min2 === void 0 && value2 >= value2)) {
        min2 = value2;
      }
    }
  }
  return min2;
}
function sum(values, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value2 of values) {
      if (value2 = +value2) {
        sum2 += value2;
      }
    }
  } else {
    let index2 = -1;
    for (let value2 of values) {
      if (value2 = +valueof(value2, ++index2, values)) {
        sum2 += value2;
      }
    }
  }
  return sum2;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function constant$2(x22) {
  return function() {
    return x22;
  };
}
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  const node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths({ nodes }) {
  for (const node of nodes) {
    let y0 = node.y0;
    let y1 = y0;
    for (const link2 of node.sourceLinks) {
      link2.y0 = y0 + link2.width / 2;
      y0 += link2.width;
    }
    for (const link2 of node.targetLinks) {
      link2.y1 = y1 + link2.width / 2;
      y1 += link2.width;
    }
  }
}
function Sankey() {
  let x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  let dx = 24;
  let dy = 8, py;
  let id2 = defaultId;
  let align = justify;
  let sort;
  let linkSort;
  let nodes = defaultNodes;
  let links = defaultLinks;
  let iterations = 6;
  function sankey() {
    const graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant$2(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant$2(_), sankey) : align;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant$2(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant$2(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [[x0, y0], [x1, y1]];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks({ nodes: nodes2, links: links2 }) {
    for (const [i2, node] of nodes2.entries()) {
      node.index = i2;
      node.sourceLinks = [];
      node.targetLinks = [];
    }
    const nodeById = new Map(nodes2.map((d, i2) => [id2(d, i2, nodes2), d]));
    for (const [i2, link2] of links2.entries()) {
      link2.index = i2;
      let { source, target } = link2;
      if (typeof source !== "object")
        source = link2.source = find(nodeById, source);
      if (typeof target !== "object")
        target = link2.target = find(nodeById, target);
      source.sourceLinks.push(link2);
      target.targetLinks.push(link2);
    }
    if (linkSort != null) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues({ nodes: nodes2 }) {
    for (const node of nodes2) {
      node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x22 = 0;
    while (current.size) {
      for (const node of current) {
        node.depth = x22;
        for (const { target } of node.sourceLinks) {
          next.add(target);
        }
      }
      if (++x22 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeHeights({ nodes: nodes2 }) {
    const n = nodes2.length;
    let current = new Set(nodes2);
    let next = /* @__PURE__ */ new Set();
    let x22 = 0;
    while (current.size) {
      for (const node of current) {
        node.height = x22;
        for (const { source } of node.targetLinks) {
          next.add(source);
        }
      }
      if (++x22 > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers({ nodes: nodes2 }) {
    const x22 = max$1(nodes2, (d) => d.depth) + 1;
    const kx = (x1 - x0 - dx) / (x22 - 1);
    const columns = new Array(x22);
    for (const node of nodes2) {
      const i2 = Math.max(0, Math.min(x22 - 1, Math.floor(align.call(null, node, x22))));
      node.layer = i2;
      node.x0 = x0 + i2 * kx;
      node.x1 = node.x0 + dx;
      if (columns[i2])
        columns[i2].push(node);
      else
        columns[i2] = [node];
    }
    if (sort)
      for (const column of columns) {
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    const ky = min$1(columns, (c) => (y1 - y0 - (c.length - 1) * py) / sum(c, value));
    for (const nodes2 of columns) {
      let y2 = y0;
      for (const node of nodes2) {
        node.y0 = y2;
        node.y1 = y2 + node.value * ky;
        y2 = node.y1 + py;
        for (const link2 of node.sourceLinks) {
          link2.width = link2.value * ky;
        }
      }
      y2 = (y1 - y2 + py) / (nodes2.length + 1);
      for (let i2 = 0; i2 < nodes2.length; ++i2) {
        const node = nodes2[i2];
        node.y0 += y2 * (i2 + 1);
        node.y1 += y2 * (i2 + 1);
      }
      reorderLinks(nodes2);
    }
  }
  function computeNodeBreadths(graph) {
    const columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (max$1(columns, (c) => c.length) - 1));
    initializeNodeBreadths(columns);
    for (let i2 = 0; i2 < iterations; ++i2) {
      const alpha = Math.pow(0.99, i2);
      const beta = Math.max(1 - alpha, (i2 + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (let i2 = 1, n = columns.length; i2 < n; ++i2) {
      const column = columns[i2];
      for (const target of column) {
        let y2 = 0;
        let w = 0;
        for (const { source, value: value2 } of target.targetLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += targetTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        let dy2 = (y2 / w - target.y0) * alpha;
        target.y0 += dy2;
        target.y1 += dy2;
        reorderNodeLinks(target);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (let n = columns.length, i2 = n - 2; i2 >= 0; --i2) {
      const column = columns[i2];
      for (const source of column) {
        let y2 = 0;
        let w = 0;
        for (const { target, value: value2 } of source.sourceLinks) {
          let v = value2 * (target.layer - source.layer);
          y2 += sourceTop(source, target) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        let dy2 = (y2 / w - source.y0) * alpha;
        source.y0 += dy2;
        source.y1 += dy2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    const i2 = nodes2.length >> 1;
    const subject = nodes2[i2];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i2 - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i2 + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y2, i2, alpha) {
    for (; i2 < nodes2.length; ++i2) {
      const node = nodes2[i2];
      const dy2 = (y2 - node.y0) * alpha;
      if (dy2 > 1e-6)
        node.y0 += dy2, node.y1 += dy2;
      y2 = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y2, i2, alpha) {
    for (; i2 >= 0; --i2) {
      const node = nodes2[i2];
      const dy2 = (node.y1 - y2) * alpha;
      if (dy2 > 1e-6)
        node.y0 -= dy2, node.y1 -= dy2;
      y2 = node.y0 - py;
    }
  }
  function reorderNodeLinks({ sourceLinks, targetLinks }) {
    if (linkSort === void 0) {
      for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
        sourceLinks2.sort(ascendingTargetBreadth);
      }
      for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
        targetLinks2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (const { sourceLinks, targetLinks } of nodes2) {
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 += width + py;
    }
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 -= width;
    }
    return y2;
  }
  function sourceTop(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * py / 2;
    for (const { source: node, width } of target.targetLinks) {
      if (node === source)
        break;
      y2 += width + py;
    }
    for (const { target: node, width } of source.sourceLinks) {
      if (node === target)
        break;
      y2 -= width;
    }
    return y2;
  }
  return sankey;
}
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
function constant$1(x22) {
  return function constant2() {
    return x22;
  };
}
function x2(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x$12 = x2, y$12 = y, context = null;
  function link2() {
    var buffer, argv = slice.call(arguments), s3 = source.apply(this, argv), t2 = target.apply(this, argv);
    if (!context)
      context = buffer = path();
    curve(context, +x$12.apply(this, (argv[0] = s3, argv)), +y$12.apply(this, argv), +x$12.apply(this, (argv[0] = t2, argv)), +y$12.apply(this, argv));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  link2.source = function(_) {
    return arguments.length ? (source = _, link2) : source;
  };
  link2.target = function(_) {
    return arguments.length ? (target = _, link2) : target;
  };
  link2.x = function(_) {
    return arguments.length ? (x$12 = typeof _ === "function" ? _ : constant$1(+_), link2) : x$12;
  };
  link2.y = function(_) {
    return arguments.length ? (y$12 = typeof _ === "function" ? _ : constant$1(+_), link2) : y$12;
  };
  link2.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}
function linkHorizontal() {
  return link(curveHorizontal);
}
function horizontalSource(d) {
  return [d.source.x1, d.y0];
}
function horizontalTarget(d) {
  return [d.target.x0, d.y1];
}
function sankeyLinkHorizontal() {
  return linkHorizontal().source(horizontalSource).target(horizontalTarget);
}
function dispatch() {
  for (var i2 = 0, n = arguments.length, _ = {}, t2; i2 < n; ++i2) {
    if (!(t2 = arguments[i2] + "") || t2 in _ || /[\s.]/.test(t2))
      throw new Error("illegal type: " + t2);
    _[t2] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i2 = t2.indexOf(".");
    if (i2 >= 0)
      name = t2.slice(i2 + 1), t2 = t2.slice(0, i2);
    if (t2 && !types2.hasOwnProperty(t2))
      throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
function get$1(type2, name) {
  for (var i2 = 0, n = type2.length, c; i2 < n; ++i2) {
    if ((c = type2[i2]).name === name) {
      return c.value;
    }
  }
}
function set$1(type2, name, callback) {
  for (var i2 = 0, n = type2.length; i2 < n; ++i2) {
    if (type2[i2].name === name) {
      type2[i2] = noop3, type2 = type2.slice(0, i2).concat(type2.slice(i2 + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name, value: callback });
  return type2;
}
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
function timer(callback, delay, time2) {
  var t2 = new Timer();
  t2.restart(callback, delay, time2);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e3;
  while (t2) {
    if ((e3 = clockNow - t2._time) >= 0)
      t2._call.call(void 0, e3);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t2, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time)
        time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t2 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t2 : taskHead = t2;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time2) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t2;
}
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules)
    node.__transition = {};
  else if (id2 in schedules)
    return;
  create(node, id2, {
    name,
    index: index2,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init2(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self2) {
  var schedules = node.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i2, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i2 in schedules) {
      o = schedules[i2];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i2];
      } else if (+i2 < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i2];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node, node.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i2 = 0, j = -1; i2 < n; ++i2) {
      if (o = self2.tween[i2].value.call(node, node.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i2 = -1, n = tween.length;
    while (++i2 < n) {
      tween[i2].call(node, t2);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node, node.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i2 in schedules)
      return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = true, i2;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i2 in schedules) {
    if ((schedule2 = schedules[i2]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i2];
  }
  if (empty2)
    delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i2 = 0, n = tween1.length; i2 < n; ++i2) {
        if (tween1[i2].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i2, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value2) {
  var tween0, tween1;
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value: value2 }, i2 = 0, n = tween1.length; i2 < n; ++i2) {
        if (tween1[i2].name === name) {
          tween1[i2] = t2;
          break;
        }
      }
      if (i2 === n)
        tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value2) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i2 = 0, n = tween.length, t2; i2 < n; ++i2) {
      if ((t2 = tween[i2]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value2 == null ? tweenRemove : tweenFunction)(id2, name, value2));
}
function tweenValue(transition, name, value2) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value2.apply(this, arguments);
  });
  return function(node) {
    return get(node, id2).value[name];
  };
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value2(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value2) {
  var fullname = namespace(name), i2 = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value2 === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i2, tweenValue(this, "attr." + name, value2)) : value2 == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i2, value2));
}
function attrInterpolate(name, i2) {
  return function(t2) {
    this.setAttribute(name, i2.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i2) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i2.call(this, t2));
  };
}
function attrTweenNS(fullname, value2) {
  var t02, i0;
  function tween() {
    var i2 = value2.apply(this, arguments);
    if (i2 !== i0)
      t02 = (i0 = i2) && attrInterpolateNS(fullname, i2);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function attrTween(name, value2) {
  var t02, i0;
  function tween() {
    var i2 = value2.apply(this, arguments);
    if (i2 !== i0)
      t02 = (i0 = i2) && attrInterpolate(name, i2);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function transition_attrTween(name, value2) {
  var key2 = "attr." + name;
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  var fullname = namespace(name);
  return this.tween(key2, (fullname.local ? attrTweenNS : attrTween)(fullname, value2));
}
function delayFunction(id2, value2) {
  return function() {
    init2(this, id2).delay = +value2.apply(this, arguments);
  };
}
function delayConstant(id2, value2) {
  return value2 = +value2, function() {
    init2(this, id2).delay = value2;
  };
}
function transition_delay(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? delayFunction : delayConstant)(id2, value2)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value2) {
  return function() {
    set(this, id2).duration = +value2.apply(this, arguments);
  };
}
function durationConstant(id2, value2) {
  return value2 = +value2, function() {
    set(this, id2).duration = value2;
  };
}
function transition_duration(value2) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value2 === "function" ? durationFunction : durationConstant)(id2, value2)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return function() {
    set(this, id2).ease = value2;
  };
}
function transition_ease(value2) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value2)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value2) {
  return function() {
    var v = value2.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set(this, id2).ease = v;
  };
}
function transition_easeVarying(value2) {
  if (typeof value2 !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value2));
}
function transition_filter(match2) {
  if (typeof match2 !== "function")
    match2 = matcher(match2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i2 = 0; i2 < n; ++i2) {
      if ((node = group[i2]) && match2.call(node, node.__data__, i2, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node, i2 = 0; i2 < n; ++i2) {
      if (node = group0[i2] || group1[i2]) {
        merge2[i2] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i2 = t2.indexOf(".");
    if (i2 >= 0)
      t2 = t2.slice(0, i2);
    return !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init2 : set;
  return function() {
    var schedule2 = sit(this, id2), on2 = schedule2.on;
    if (on2 !== on0)
      (on1 = (on0 = on2).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i2 in this.__transition)
      if (+i2 !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i2 = 0; i2 < n; ++i2) {
      if ((node = group[i2]) && (subnode = select2.call(node, node.__data__, i2, group))) {
        if ("__data__" in node)
          subnode.__data__ = node.__data__;
        subgroup[i2] = subnode;
        schedule(subgroup[i2], name, id2, i2, subgroup, get(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m2 = groups.length, subgroups = [], parents = [], j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group[i2]) {
        for (var children2 = select2.call(node, node.__data__, i2, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value2(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key2 = "style." + name, event = "end." + key2, remove2;
  return function() {
    var schedule2 = set(this, id2), on2 = schedule2.on, listener = schedule2.value[key2] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on2 !== on0 || listener0 !== listener)
      (on1 = (on0 = on2).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value2, priority) {
  var i2 = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value2 == null ? this.styleTween(name, styleNull(name, i2)).on("end.style." + name, styleRemove(name)) : typeof value2 === "function" ? this.styleTween(name, styleFunction(name, i2, tweenValue(this, "style." + name, value2))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i2, value2), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i2, priority) {
  return function(t2) {
    this.style.setProperty(name, i2.call(this, t2), priority);
  };
}
function styleTween(name, value2, priority) {
  var t2, i0;
  function tween() {
    var i2 = value2.apply(this, arguments);
    if (i2 !== i0)
      t2 = (i0 = i2) && styleInterpolate(name, i2, priority);
    return t2;
  }
  tween._value = value2;
  return tween;
}
function transition_styleTween(name, value2, priority) {
  var key2 = "style." + (name += "");
  if (arguments.length < 2)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key2, styleTween(name, value2, priority == null ? "" : priority));
}
function textConstant(value2) {
  return function() {
    this.textContent = value2;
  };
}
function textFunction(value2) {
  return function() {
    var value1 = value2(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value2) {
  return this.tween("text", typeof value2 === "function" ? textFunction(tweenValue(this, "text", value2)) : textConstant(value2 == null ? "" : value2 + ""));
}
function textInterpolate(i2) {
  return function(t2) {
    this.textContent = i2.call(this, t2);
  };
}
function textTween(value2) {
  var t02, i0;
  function tween() {
    var i2 = value2.apply(this, arguments);
    if (i2 !== i0)
      t02 = (i0 = i2) && textInterpolate(i2);
    return t02;
  }
  tween._value = value2;
  return tween;
}
function transition_textTween(value2) {
  var key2 = "text";
  if (arguments.length < 1)
    return (key2 = this.tween(key2)) && key2._value;
  if (value2 == null)
    return this.tween(key2, null);
  if (typeof value2 !== "function")
    throw new Error();
  return this.tween(key2, textTween(value2));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group[i2]) {
        var inherit2 = get(node, id0);
        schedule(node, name, id1, i2, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve2, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve2();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on2 = schedule2.on;
      if (on2 !== on0) {
        on1 = (on0 = on2).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve2();
  });
}
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m2 = groups.length, j = 0; j < m2; ++j) {
    for (var group = groups[j], n = group.length, node, i2 = 0; i2 < n; ++i2) {
      if (node = group[i2]) {
        schedule(node, name, id2, i2, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
function BrushEvent(type2, {
  sourceEvent: sourceEvent2,
  target,
  selection: selection2,
  mode,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type2, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    selection: { value: selection2, enumerable: true, configurable: true },
    mode: { value: mode, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function number1(e3) {
  return [+e3[0], +e3[1]];
}
function number2(e3) {
  return [number1(e3[0]), number1(e3[1])];
}
function type(t2) {
  return { type: t2 };
}
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  if (svg.hasAttribute("viewBox")) {
    svg = svg.viewBox.baseVal;
    return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
  }
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node) {
  while (!node.__brush)
    if (!(node = node.parentNode))
      return;
  return node.__brush;
}
function empty(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushX() {
  return brush(X);
}
function brush(dim) {
  var extent2 = defaultExtent, filter2 = defaultFilter, touchable = defaultTouchable, keys2 = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local(this).extent;
      select(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle2 = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle2.exit().remove();
    handle2.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection2, event) {
    if (group.tween) {
      group.on("start.brush", function(event2) {
        emitter(this, arguments).beforestart().start(event2);
      }).on("interrupt.brush end.brush", function(event2) {
        emitter(this, arguments).end(event2);
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i2 = interpolate$1(selection0, selection1);
        function tween(t2) {
          state.selection = t2 === 1 && selection1 === null ? null : i2(t2);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start(event).brush(event).end(event);
      });
    }
  };
  brush2.clear = function(group, event) {
    brush2.move(group, null, event);
  };
  function redraw() {
    var group = select(this), selection2 = local(this).selection;
    if (selection2) {
      group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function(event, mode) {
      if (this.starting)
        this.starting = false, this.emit("start", event, mode);
      else
        this.emit("brush", event);
      return this;
    },
    brush: function(event, mode) {
      this.emit("brush", event, mode);
      return this;
    },
    end: function(event, mode) {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end", event, mode);
      return this;
    },
    emit: function(type2, event, mode) {
      var d = select(this.that).datum();
      listeners.call(type2, this.that, new BrushEvent(type2, {
        sourceEvent: event,
        target: brush2,
        selection: dim.output(this.state.selection),
        mode,
        dispatch: listeners
      }), d);
    }
  };
  function started(event) {
    if (touchending && !event.touches)
      return;
    if (!filter2.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode = (keys2 && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys2 && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E = extent3[1][0], e0, e1, S2 = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys2 && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t2) => {
      const i2 = t2.identifier;
      t2 = pointer(t2, that);
      t2.point0 = t2.slice();
      t2.identifier = i2;
      return t2;
    });
    interrupt(that);
    var emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      const pts = [points[0], points[1] || points[0]];
      state.selection = selection2 = [[
        w0 = dim === Y ? W : min(pts[0][0], pts[1][0]),
        n0 = dim === X ? N : min(pts[0][1], pts[1][1])
      ], [
        e0 = dim === Y ? E : max(pts[0][0], pts[1][0]),
        s0 = dim === X ? S2 : max(pts[0][1], pts[1][1])
      ]];
      if (points.length > 1)
        move(event);
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys2)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      dragDisable(event.view);
    }
    redraw.call(that);
    emit.start(event, mode.name);
    function moved(event2) {
      for (const p of event2.changedTouches || [event2]) {
        for (const d of points)
          if (d.identifier === p.identifier)
            d.cur = pointer(p, that);
      }
      if (shifting && !lockX && !lockY && points.length === 1) {
        const point2 = points[0];
        if (abs(point2.cur[0] - point2[0]) > abs(point2.cur[1] - point2[1]))
          lockY = true;
        else
          lockX = true;
      }
      for (const point2 of points)
        if (point2.cur)
          point2[0] = point2.cur[0], point2[1] = point2.cur[1];
      moving = true;
      noevent(event2);
      move(event2);
    }
    function move(event2) {
      const point2 = points[0], point0 = point2.point0;
      var t2;
      dx = point2[0] - point0[0];
      dy = point2[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = max(W - w0, min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = max(N - n0, min(S2 - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (points[1]) {
            if (signX)
              w1 = max(W, min(E, points[0][0])), e1 = max(W, min(E, points[1][0])), signX = 1;
            if (signY)
              n1 = max(N, min(S2, points[0][1])), s1 = max(N, min(S2, points[1][1])), signY = 1;
          } else {
            if (signX < 0)
              dx = max(W - w0, min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
            else if (signX > 0)
              dx = max(W - e0, min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0)
              dy = max(N - n0, min(S2 - n0, dy)), n1 = n0 + dy, s1 = s0;
            else if (signY > 0)
              dy = max(N - s0, min(S2 - s0, dy)), n1 = n0, s1 = s0 + dy;
          }
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = max(W, min(E, w0 - dx * signX)), e1 = max(W, min(E, e0 + dx * signX));
          if (signY)
            n1 = max(N, min(S2, n0 - dy * signY)), s1 = max(N, min(S2, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t2 = w0, w0 = e0, e0 = t2;
        t2 = w1, w1 = e1, e1 = t2;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t2 = n0, n0 = s0, s0 = t2;
        t2 = n1, n1 = s1, s1 = t2;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush(event2, mode.name);
      }
    }
    function ended(event2) {
      nopropagation(event2);
      if (event2.touches) {
        if (event2.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event2.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty(selection2))
        state.selection = null, redraw.call(that);
      emit.end(event2, mode.name);
    }
    function keydowned(event2) {
      switch (event2.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent(event2);
    }
    function keyupped(event2) {
      switch (event2.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move(event2);
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode = MODE_HANDLE;
            move(event2);
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event2.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move(event2);
          }
          break;
        }
        default:
          return;
      }
      noevent(event2);
    }
  }
  function touchmoved(event) {
    emitter(this, arguments).moved(event);
  }
  function touchended(event) {
    emitter(this, arguments).ended(event);
  }
  function initialize() {
    var state = this.__brush || { selection: null };
    state.extent = number2(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_) {
    return arguments.length ? (extent2 = typeof _ === "function" ? _ : constant(number2(_)), brush2) : extent2;
  };
  brush2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), brush2) : filter2;
  };
  brush2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), brush2) : touchable;
  };
  brush2.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_) {
    return arguments.length ? (keys2 = !!_, brush2) : keys2;
  };
  brush2.on = function() {
    var value2 = listeners.on.apply(listeners, arguments);
    return value2 === listeners ? brush2 : value2;
  };
  return brush2;
}
function pointIsWithinThreshold(dx, x22) {
  return dx > x22 - THRESHOLD && dx < x22 + THRESHOLD;
}
var Roles, Chart$1, Modal$2, Model, Toolbar$1, ZoomBar$1, ZoomDomain, CanvasZoom$1, Axis$1, Area$1, WordCloud$1, Pie$1, Gauge$1, Bar$1, Boxplot$1, Scatter$1, Line$1, Radar$1, Tree$1, Treemap$1, Tooltip$1, Threshold$1, Legend$1, CirclePack$1, Alluvial$1, Meter$1, Heatmap$1, EventEnums, Events$1, RenderTypes, ChartTheme, ColorClassNameTypes, AxisPositions, ZoomBarTypes, TruncationTypes, CartesianOrientations, ScaleTypes, LegendPositions, Alignments, LegendOrientations, TreeTypes, LayoutDirection, LayoutGrowth, LayoutAlignItems, CalloutDirections, Skeletons, TextAnchor, DominantBaseline, GaugeTypes, ArrowDirections, Statuses, TickRotations, ChartTypes, ToolbarControlTypes, AxisTitleOrientations, LegendItemType, ColorLegendType, DividerStatus, AxisFlavor, linear$2, _a$2, area$1, axis$1, canvasZoomSettings, circlePack, color$1, boxplot, histogram, legend$1, lines, meter, pie$1, radar, alluvial, heatmap, spacers, tooltips, transitions, toolbar, zoomBar, defaultLegendAdditionalItems, freeGlobal, freeGlobal$1, freeSelf, root$1, root$2, Symbol$1, Symbol$2, objectProto$h, hasOwnProperty$e, nativeObjectToString$1, symToStringTag$1, objectProto$g, nativeObjectToString, nullTag, undefinedTag, symToStringTag, symbolTag$3, isArray, isArray$1, INFINITY$3, symbolProto$2, symbolToString, reWhitespace, reTrimStart, NAN, reIsBadHex, reIsBinary, reIsOctal, freeParseInt, asyncTag, funcTag$2, genTag$1, proxyTag, coreJsData, coreJsData$1, maskSrcKey, funcProto$2, funcToString$2, reRegExpChar, reIsHostCtor, funcProto$1, objectProto$f, funcToString$1, hasOwnProperty$d, reIsNative, WeakMap$1, WeakMap$2, objectCreate, baseCreate, baseCreate$1, HOT_COUNT, HOT_SPAN, nativeNow, defineProperty, defineProperty$1, baseSetToString, baseSetToString$1, setToString, setToString$1, MAX_SAFE_INTEGER$1, reIsUint, objectProto$e, hasOwnProperty$c, nativeMax$1, MAX_SAFE_INTEGER, objectProto$d, argsTag$3, objectProto$c, hasOwnProperty$b, propertyIsEnumerable$1, isArguments, isArguments$1, freeExports$2, freeModule$2, moduleExports$2, Buffer$1, nativeIsBuffer, isBuffer, isBuffer$1, argsTag$2, arrayTag$2, boolTag$3, dateTag$3, errorTag$2, funcTag$1, mapTag$6, numberTag$3, objectTag$4, regexpTag$3, setTag$6, stringTag$3, weakMapTag$2, arrayBufferTag$3, dataViewTag$4, float32Tag$2, float64Tag$2, int8Tag$2, int16Tag$2, int32Tag$2, uint8Tag$2, uint8ClampedTag$2, uint16Tag$2, uint32Tag$2, typedArrayTags, freeExports$1, freeModule$1, moduleExports$1, freeProcess, nodeUtil, nodeUtil$1, nodeIsTypedArray, isTypedArray, isTypedArray$1, objectProto$b, hasOwnProperty$a, nativeKeys, nativeKeys$1, objectProto$a, hasOwnProperty$9, objectProto$9, hasOwnProperty$8, reIsDeepProp, reIsPlainProp, nativeCreate, nativeCreate$1, HASH_UNDEFINED$2, objectProto$8, hasOwnProperty$7, objectProto$7, hasOwnProperty$6, HASH_UNDEFINED$1, arrayProto, splice, Map$1, Map$2, FUNC_ERROR_TEXT$1, MAX_MEMOIZE_SIZE, rePropName, reEscapeChar, stringToPath, stringToPath$1, INFINITY$2, spreadableSymbol, getPrototype, getPrototype$1, objectTag$3, funcProto, objectProto$6, funcToString, hasOwnProperty$5, objectCtorString, rsAstralRange$2, rsComboMarksRange$3, reComboHalfMarksRange$3, rsComboSymbolsRange$3, rsComboRange$3, rsVarRange$2, rsZWJ$2, reHasUnicode, rsAstralRange$1, rsComboMarksRange$2, reComboHalfMarksRange$2, rsComboSymbolsRange$2, rsComboRange$2, rsVarRange$1, rsAstral, rsCombo$2, rsFitz$1, rsModifier$1, rsNonAstral$1, rsRegional$1, rsSurrPair$1, rsZWJ$1, reOptMod$1, rsOptVar$1, rsOptJoin$1, rsSeq$1, rsSymbol, reUnicode, upperFirst, upperFirst$1, deburredLetters, deburrLetter, deburrLetter$1, reLatin, rsComboMarksRange$1, reComboHalfMarksRange$1, rsComboSymbolsRange$1, rsComboRange$1, rsCombo$1, reComboMark, reAsciiWord, reHasUnicodeWord, rsAstralRange, rsComboMarksRange, reComboHalfMarksRange, rsComboSymbolsRange, rsComboRange, rsDingbatRange, rsLowerRange, rsMathOpRange, rsNonCharRange, rsPunctuationRange, rsSpaceRange, rsUpperRange, rsVarRange, rsBreakRange, rsApos$1, rsBreak, rsCombo, rsDigits, rsDingbat, rsLower, rsMisc, rsFitz, rsModifier, rsNonAstral, rsRegional, rsSurrPair, rsUpper, rsZWJ, rsMiscLower, rsMiscUpper, rsOptContrLower, rsOptContrUpper, reOptMod, rsOptVar, rsOptJoin, rsOrdLower, rsOrdUpper, rsSeq, rsEmoji, reUnicodeWord, rsApos, reApos, camelCase, lodashCamelCase, LARGE_ARRAY_SIZE$1, freeExports, freeModule, moduleExports, Buffer2, allocUnsafe, objectProto$5, propertyIsEnumerable, nativeGetSymbols$1, getSymbols, getSymbols$1, nativeGetSymbols, getSymbolsIn, getSymbolsIn$1, DataView$1, DataView$2, Promise$1, Promise$2, Set$1, Set$2, mapTag$5, objectTag$2, promiseTag, setTag$5, weakMapTag$1, dataViewTag$3, dataViewCtorString, mapCtorString, promiseCtorString, setCtorString, weakMapCtorString, getTag, getTag$1, objectProto$4, hasOwnProperty$4, Uint8Array$1, Uint8Array$2, reFlags, symbolProto$1, symbolValueOf$1, boolTag$2, dateTag$2, mapTag$4, numberTag$2, regexpTag$2, setTag$4, stringTag$2, symbolTag$2, arrayBufferTag$2, dataViewTag$2, float32Tag$1, float64Tag$1, int8Tag$1, int16Tag$1, int32Tag$1, uint8Tag$1, uint8ClampedTag$1, uint16Tag$1, uint32Tag$1, mapTag$3, nodeIsMap, isMap, isMap$1, setTag$3, nodeIsSet, isSet, isSet$1, CLONE_DEEP_FLAG$1, CLONE_FLAT_FLAG, CLONE_SYMBOLS_FLAG$1, argsTag$1, arrayTag$1, boolTag$1, dateTag$1, errorTag$1, funcTag, genTag, mapTag$2, numberTag$1, objectTag$1, regexpTag$1, setTag$2, stringTag$1, symbolTag$1, weakMapTag, arrayBufferTag$1, dataViewTag$1, float32Tag, float64Tag, int8Tag, int16Tag, int32Tag, uint8Tag, uint8ClampedTag, uint16Tag, uint32Tag, cloneableTags, CLONE_DEEP_FLAG, CLONE_SYMBOLS_FLAG, HASH_UNDEFINED, COMPARE_PARTIAL_FLAG$5, COMPARE_UNORDERED_FLAG$3, COMPARE_PARTIAL_FLAG$4, COMPARE_UNORDERED_FLAG$2, boolTag, dateTag, errorTag, mapTag$1, numberTag, regexpTag, setTag$1, stringTag, symbolTag, arrayBufferTag, dataViewTag, symbolProto, symbolValueOf, COMPARE_PARTIAL_FLAG$3, objectProto$3, hasOwnProperty$3, COMPARE_PARTIAL_FLAG$2, argsTag, arrayTag, objectTag, objectProto$2, hasOwnProperty$2, COMPARE_PARTIAL_FLAG$1, COMPARE_UNORDERED_FLAG$1, COMPARE_PARTIAL_FLAG, COMPARE_UNORDERED_FLAG, baseFor, baseFor$1, baseEach, baseEach$1, now$1, now$2, FUNC_ERROR_TEXT, nativeMax, nativeMin, INFINITY$1, objectProto$1, hasOwnProperty$1, groupBy, lodashGroupBy, mapTag, setTag, objectProto, hasOwnProperty, kebabCase, lodashKebabCase, merge, lodashMerge, INFINITY, createSet, createSet$1, LARGE_ARRAY_SIZE, unionBy, lodashUnionBy, xhtml, namespaces, find$1, filter, root, Tools, enUS, formatDistance$1, formatLong$2, buildFormatLongFn$1, formatRelative$1, localize$2, buildLocalizeFn$1, match$2, buildMatchPatternFn$1, buildMatchFn$1, enUSLocaleObject, __spreadArrays$k, standardTruncationOptions, legend, grid, ruler, baseTooltip, axes, timeScale, isFullScreenEnabled, chart, axisChart, baseBarChart, simpleBarChart, groupedBarChart, stackedBarChart, boxplotChart, scatterChart, lollipopChart, lineChart, areaChart, stackedAreaChart, bubbleChart, bulletChart, histogramChart, wordCloudChart, pieChart, gaugeChart, donutChart, meterChart, proportionalMeterChart, radarChart, comboChart, treeChart, treemapChart, circlePackChart, alluvialChart, heatmapChart, options, Configuration, ascendingBisect, bisectRight, bisect, InternMap, array$2, slice$2, e10, e5, e2, implicit, darker, brighter, reI, reN, reP, reHex, reRgbInteger, reRgbPercent, reRgbaInteger, reRgbaPercent, reHslPercent, reHslaPercent, named, constant$5, interpolateRgb, reA, reB, degrees, identity$4, svgNode, interpolateTransformCss, interpolateTransformSvg, unit, re, prefixExponent, formatTypes, map, prefixes, locale$2, format$1, formatPrefix, t0, t1, millisecond, millisecond$1, durationSecond, durationMinute, durationHour, durationDay, durationWeek, durationMonth, durationYear, second, utcSecond, minute, timeMinute, hour, timeHour, day, timeDay, sunday, monday, thursday, month, timeMonth, year, timeYear, utcMinute, utcMinute$1, utcHour, utcHour$1, utcDay, utcDay$1, utcSunday, utcMonday, utcThursday, utcMonth, utcMonth$1, utcYear, utcYear$1, timeTicks, timeTickInterval, pads, numberRe, percentRe, requoteRe, locale$1, timeFormat, pi$2, tau$2, epsilon$3, tauEpsilon$1, abs$1, atan2, cos, max$2, min$2, sin, sqrt, epsilon$2, pi$1, halfPi, tau$1, slice$1, curveRadialLinear, Bump, curveBundle, curveCardinal, curveCardinalClosed, curveCardinalOpen, curveCatmullRom, curveCatmullRomClosed, curveCatmullRomOpen, __assign$3, ChartModel, Service, settings, settings_1, settings$1, MapShim, isBrowser, global$1, requestAnimationFrame$1, trailingTimeout, throttle, REFRESH_DELAY, transitionKeys, mutationObserverSupported, ResizeObserverController, defineConfigurable, getWindowOf, emptyRect, isSVGGraphicsElement, ResizeObservation, ResizeObserverEntry, ResizeObserverSPI, observers, ResizeObserver, index, domToImage$1, domToImage, __extends$1y, CSS_VERIFIER_ELEMENT_CLASSNAME, DOMUtils, __extends$1x, Events, __extends$1w, Files, __extends$1v, Transitions, __extends$1u, GradientUtils, MILLISECONDS_IN_HOUR$1, MILLISECONDS_IN_MINUTE$2, MILLISECONDS_IN_DAY$1, MILLISECONDS_IN_MINUTE$1, MILLISECONDS_IN_HOUR, MILLISECONDS_IN_MINUTE, formatDistanceLocale, dateFormats, timeFormats, dateTimeFormats, formatLong, formatLong$1, formatRelativeLocale, eraValues, quarterValues, monthValues, dayValues, dayPeriodValues, formattingDayPeriodValues, localize, localize$1, matchOrdinalNumberPattern, parseOrdinalNumberPattern, matchEraPatterns, parseEraPatterns, matchQuarterPatterns, parseQuarterPatterns, matchMonthPatterns, parseMonthPatterns, matchDayPatterns, parseDayPatterns, matchDayPeriodPatterns, parseDayPeriodPatterns, match, match$1, locale, defaultLocale, formatters$2, formatters$3, MILLISECONDS_IN_DAY, MILLISECONDS_IN_WEEK$1, MILLISECONDS_IN_WEEK, dayPeriodEnum, formatters, formatters$1, longFormatters, longFormatters$1, protectedDayOfYearTokens, protectedWeekYearTokens, formattingTokensRegExp, longFormattingTokensRegExp, escapedStringRegExp, doubleQuoteRegExp, unescapedLatinCharacterRegExp, __extends$1t, __rest$1, __spreadArrays$j, CartesianScales, __extends$1s, Curves, __extends$1r, Zoom, __extends$1q, CanvasZoom, Component, __extends$1p, Legend, top, right, bottom, left, epsilon$1, __extends$1o, ColorScaleLegend, exports$1, eventedShowHideState$1, __DEV__, warning, warning_1, Modal$1, CarbonModalComponent, __extends$1n, Modal, _a$1, PLACEMENTS, defaultPositions, windowRef, Position, TIME_INTERVALS, __extends$1m, Threshold, __extends$1l, Title, __extends$1k, MeterTitle, __extends$1j, Tooltip, __extends$1i, __spreadArrays$i, AxisChartsTooltip, __extends$1h, ChartClip, __extends$1g, CanvasChartClip, __extends$1f, __rest, Highlight, __extends$1e, Area, __extends$1d, StackedArea, __extends$1c, Bar, __extends$1b, SimpleBar, __extends$1a, GroupedBar, __extends$19, StackedBar, __extends$18, Boxplot, __extends$17, Scatter, __extends$16, Bubble, __extends$15, Bullet, __extends$14, Histogram, __extends$13, Line, __extends$12, Lollipop, __extends$11, StackedScatter, __extends$10, Pie, __extends$$, ARROW_UP_PATH_STRING, ARROW_DOWN_PATH_STRING, Gauge, __extends$_, Donut, __extends$Z, Skeleton, __extends$Y, SkeletonLines, phi, squarify, __extends$X, NODE_OFFSET, Tree, black, white, yellow10, yellow20, yellow30, yellow40, yellow50, yellow60, yellow70, yellow80, yellow90, yellow100, unstable_yellow, orange10, orange20, orange30, orange40, orange50, orange60, orange70, orange80, orange90, orange100, unstable_orange, red10, red20, red30, red40, red50, red60, red70, red80, red90, red100, red, magenta10, magenta20, magenta30, magenta40, magenta50, magenta60, magenta70, magenta80, magenta90, magenta100, magenta, purple10, purple20, purple30, purple40, purple50, purple60, purple70, purple80, purple90, purple100, purple, blue10, blue20, blue30, blue40, blue50, blue60, blue70, blue80, blue90, blue100, blue, cyan10, cyan20, cyan30, cyan40, cyan50, cyan60, cyan70, cyan80, cyan90, cyan100, cyan, teal10, teal20, teal30, teal40, teal50, teal60, teal70, teal80, teal90, teal100, teal, green10, green20, green30, green40, green50, green60, green70, green80, green90, green100, green, coolGray10, coolGray20, coolGray30, coolGray40, coolGray50, coolGray60, coolGray70, coolGray80, coolGray90, coolGray100, coolGray, gray10, gray20, gray30, gray40, gray50, gray60, gray70, gray80, gray90, gray100, gray, warmGray10, warmGray20, warmGray30, warmGray40, warmGray50, warmGray60, warmGray70, warmGray80, warmGray90, warmGray100, warmGray, colors, __extends$W, findColorShade, textFillColor, uidCounter, Treemap, __extends$V, Radar, __extends$U, __spreadArrays$h, CirclePack, noop$1, src, require$$0, dispatch$1, cloudRadians, cw, ch, d3Cloud, spirals, __extends$T, WordCloud, pi, tau, epsilon, tauEpsilon, slice, __extends$S, Alluvial, __extends$R, Heatmap, __extends$Q, Spacer, __extends$P, LayoutComponent, __extends$O, Axis, __extends$N, __assign$2, HoverAxis, __extends$M, TwoDimensionalAxes, noop3, nonpassivecapture, frame, timeout$1, interval, pokeDelay, taskHead, taskTail, clockLast, clockNow, clockSkew, clock, setFrame, emptyOn, emptyTween, CREATED, SCHEDULED, STARTING, STARTED, RUNNING, ENDING, ENDED, Selection, id, selection_prototype, defaultTiming, constant, MODE_DRAG, MODE_SPACE, MODE_HANDLE, MODE_CENTER, abs, max, min, X, Y, cursors, flipX, flipY, signsX, signsY, __extends$L, ChartBrush, __extends$K, Grid, __extends$J, THRESHOLD, Ruler, __extends$I, __spreadArrays$g, BinnedRuler, __extends$H, StackedRuler, __extends$G, Toolbar, __extends$F, ZeroLine, __extends$E, ZoomBar, __spreadArrays$f, Chart, __extends$D, __spreadArrays$e, ChartModelCartesian, __extends$C, __spreadArrays$d, AxisChart, __extends$B, __extends$A, __extends$z, __extends$y, __extends$x, __extends$w, __spreadArrays$c, BoxplotChartModel, __extends$v, __extends$u, __extends$t, __spreadArrays$b, BulletChartModel, __extends$s, __extends$r, __spreadArrays$a, ChartModelBinned, __extends$q, __extends$p, LineChart, __extends$o, __extends$n, __extends$m, __spreadArrays$9, PieChartModel, __extends$l, PieChart, __extends$k, __extends$j, __spreadArrays$8, MeterChartModel, __extends$i, __assign$1, Meter, __extends$h, __spreadArrays$7, __extends$g, __spreadArrays$6, RadarChartModel, __extends$f, __extends$e, __spreadArrays$5, GaugeChartModel, __extends$d, GaugeChart, __extends$c, __spreadArrays$4, _a4, graphComponentsMap, __extends$b, TreeChartModel, __extends$a, __extends$9, TreemapChartModel, __extends$8, __extends$7, __assign, CirclePackChartModel, __extends$6, __extends$5, __spreadArrays$3, WordCloudModel, __extends$4, __extends$3, __spreadArrays$2, AlluvialChartModel, __extends$2, __extends$1, __spreadArrays$1, HeatmapModel, __extends, __spreadArrays, BaseChart, LineChart_1, GaugeChart_1, Dashboard;
var init_dashboard_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/dashboard.svelte.js"() {
    init_index_a93c14e4();
    (function(Roles2) {
      Roles2["GRAPHICS_DOCUMENT"] = "graphics-document";
      Roles2["GRAPHICS_OBJECT"] = "graphics-object";
      Roles2["GRAPHICS_SYMBOL"] = "graphics-symbol";
      Roles2["GROUP"] = "group";
      Roles2["DOCUMENT"] = "document";
      Roles2["CHECKBOX"] = "checkbox";
      Roles2["BUTTON"] = "button";
      Roles2["MENU"] = "menu";
      Roles2["MENU_ITEM"] = "menuitem";
      Roles2["IMG"] = "img";
    })(Roles || (Roles = {}));
    (function(Chart2) {
      Chart2["RENDER_FINISHED"] = "render-finished";
      Chart2["RESIZE"] = "chart-resize";
      Chart2["MOUSEOVER"] = "chart-mouseover";
      Chart2["MOUSEOUT"] = "chart-mouseout";
    })(Chart$1 || (Chart$1 = {}));
    (function(Modal2) {
      Modal2["SHOW"] = "show-modal";
      Modal2["HIDE"] = "hide-modal";
    })(Modal$2 || (Modal$2 = {}));
    (function(Model2) {
      Model2["UPDATE"] = "model-update";
    })(Model || (Model = {}));
    (function(Toolbar2) {
      Toolbar2["SHOW_OVERFLOW_MENU"] = "show-toolbar-overflow-menu";
      Toolbar2["HIDE_OVERFLOW_MENU"] = "hide-toolbar-overflow-menu";
      Toolbar2["BUTTON_CLICK"] = "toolbar-button-click";
    })(Toolbar$1 || (Toolbar$1 = {}));
    (function(ZoomBar2) {
      ZoomBar2["UPDATE"] = "zoom-bar-update";
      ZoomBar2["SELECTION_START"] = "zoom-bar-selection-start";
      ZoomBar2["SELECTION_IN_PROGRESS"] = "zoom-bar-selection-in-progress";
      ZoomBar2["SELECTION_END"] = "zoom-bar-selection-end";
    })(ZoomBar$1 || (ZoomBar$1 = {}));
    (function(ZoomDomain2) {
      ZoomDomain2["CHANGE"] = "zoom-domain-change";
    })(ZoomDomain || (ZoomDomain = {}));
    (function(CanvasZoom2) {
      CanvasZoom2["CANVAS_ZOOM_IN"] = "canvas-zoom-in";
      CanvasZoom2["CANVAS_ZOOM_OUT"] = "canvas-zoom-out";
    })(CanvasZoom$1 || (CanvasZoom$1 = {}));
    (function(Axis2) {
      Axis2["LABEL_MOUSEOVER"] = "axis-label-mouseover";
      Axis2["LABEL_MOUSEMOVE"] = "axis-label-mousemove";
      Axis2["LABEL_CLICK"] = "axis-label-click";
      Axis2["LABEL_MOUSEOUT"] = "axis-label-mouseout";
      Axis2["LABEL_FOCUS"] = "axis-label-focus";
      Axis2["LABEL_BLUR"] = "axis-label-blur";
      Axis2["RENDER_COMPLETE"] = "axis-render-complete";
    })(Axis$1 || (Axis$1 = {}));
    (function(Area2) {
      Area2["POINT_MOUSEOVER"] = "scatter-mouseover";
      Area2["POINT_MOUSEMOVE"] = "scatter-mousemove";
      Area2["POINT_CLICK"] = "scatter-click";
      Area2["POINT_MOUSEOUT"] = "scatter-mouseout";
    })(Area$1 || (Area$1 = {}));
    (function(WordCloud2) {
      WordCloud2["WORD_MOUSEOVER"] = "wordcloud-word-mouseover";
      WordCloud2["WORD_MOUSEMOVE"] = "wordcloud-word-mousemove";
      WordCloud2["WORD_CLICK"] = "wordcloud-word-click";
      WordCloud2["WORD_MOUSEOUT"] = "wordcloud-word-mouseout";
    })(WordCloud$1 || (WordCloud$1 = {}));
    (function(Pie2) {
      Pie2["SLICE_MOUSEOVER"] = "pie-slice-mouseover";
      Pie2["SLICE_MOUSEMOVE"] = "pie-slice-mousemove";
      Pie2["SLICE_CLICK"] = "pie-slice-click";
      Pie2["SLICE_MOUSEOUT"] = "pie-slice-mouseout";
    })(Pie$1 || (Pie$1 = {}));
    (function(Gauge2) {
      Gauge2["ARC_MOUSEOVER"] = "gauge-arc-mouseover";
      Gauge2["ARC_MOUSEMOVE"] = "gauge-arc-mousemove";
      Gauge2["ARC_CLICK"] = "gauge-arc-click";
      Gauge2["ARC_MOUSEOUT"] = "gauge-arc-mouseout";
    })(Gauge$1 || (Gauge$1 = {}));
    (function(Bar2) {
      Bar2["BAR_MOUSEOVER"] = "bar-mouseover";
      Bar2["BAR_MOUSEMOVE"] = "bar-mousemove";
      Bar2["BAR_CLICK"] = "bar-click";
      Bar2["BAR_MOUSEOUT"] = "bar-mouseout";
    })(Bar$1 || (Bar$1 = {}));
    (function(Boxplot2) {
      Boxplot2["BOX_MOUSEOVER"] = "box-mouseover";
      Boxplot2["BOX_MOUSEMOVE"] = "box-mousemove";
      Boxplot2["BOX_CLICK"] = "box-click";
      Boxplot2["BOX_MOUSEOUT"] = "box-mouseout";
      Boxplot2["OUTLIER_MOUSEOVER"] = "outlier-mouseover";
      Boxplot2["OUTLIER_MOUSEMOVE"] = "outlier-mousemove";
      Boxplot2["OUTLIER_CLICK"] = "outlier-click";
      Boxplot2["OUTLIER_MOUSEOUT"] = "outlier-mouseout";
    })(Boxplot$1 || (Boxplot$1 = {}));
    (function(Scatter2) {
      Scatter2["SCATTER_MOUSEOVER"] = "scatter-mouseover";
      Scatter2["SCATTER_MOUSEMOVE"] = "scatter-mousemove";
      Scatter2["SCATTER_CLICK"] = "scatter-click";
      Scatter2["SCATTER_MOUSEOUT"] = "scatter-mouseout";
    })(Scatter$1 || (Scatter$1 = {}));
    (function(Line2) {
      Line2["POINT_MOUSEOVER"] = "scatter-mouseover";
      Line2["POINT_MOUSEMOVE"] = "scatter-mousemove";
      Line2["POINT_CLICK"] = "scatter-click";
      Line2["POINT_MOUSEOUT"] = "scatter-mouseout";
    })(Line$1 || (Line$1 = {}));
    (function(Radar2) {
      Radar2["X_AXIS_MOUSEOVER"] = "radar-x-axis-mouseover";
      Radar2["X_AXIS_MOUSEMOVE"] = "radar-x-axis-mousemove";
      Radar2["X_AXIS_CLICK"] = "radar-x-axis-click";
      Radar2["X_AXIS_MOUSEOUT"] = "radar-x-axis-mouseout";
    })(Radar$1 || (Radar$1 = {}));
    (function(Tree2) {
      Tree2["NODE_MOUSEOVER"] = "tree-node-mouseover";
      Tree2["NODE_CLICK"] = "tree-node-click";
      Tree2["NODE_MOUSEOUT"] = "tree-node-mouseout";
    })(Tree$1 || (Tree$1 = {}));
    (function(Treemap2) {
      Treemap2["LEAF_MOUSEOVER"] = "leaf-mouseover";
      Treemap2["LEAF_MOUSEMOVE"] = "leaf-mousemove";
      Treemap2["LEAF_CLICK"] = "leaf-click";
      Treemap2["LEAF_MOUSEOUT"] = "leaf-mouseout";
    })(Treemap$1 || (Treemap$1 = {}));
    (function(Tooltip2) {
      Tooltip2["SHOW"] = "show-tooltip";
      Tooltip2["MOVE"] = "move-tooltip";
      Tooltip2["HIDE"] = "hide-tooltip";
    })(Tooltip$1 || (Tooltip$1 = {}));
    (function(Threshold2) {
      Threshold2["SHOW"] = "show-threshold";
      Threshold2["HIDE"] = "hide-threshold";
    })(Threshold$1 || (Threshold$1 = {}));
    (function(Legend2) {
      Legend2["ITEM_HOVER"] = "legend-item-onhover";
      Legend2["ITEM_CLICK"] = "legend-item-onclick";
      Legend2["ITEM_MOUSEOUT"] = "legend-item-onmouseout";
      Legend2["ITEMS_UPDATE"] = "legend-items-update";
    })(Legend$1 || (Legend$1 = {}));
    (function(CirclePack2) {
      CirclePack2["CIRCLE_MOUSEOVER"] = "circle-leaf-mouseover";
      CirclePack2["CIRCLE_CLICK"] = "circle-leaf-click";
      CirclePack2["CIRCLE_MOUSEOUT"] = "circle-leaf-mouseout";
      CirclePack2["CIRCLE_MOUSEMOVE"] = "circle-leaf-mousemove";
    })(CirclePack$1 || (CirclePack$1 = {}));
    (function(Alluvial2) {
      Alluvial2["NODE_MOUSEOVER"] = "alluvial-node-mouseover";
      Alluvial2["NODE_CLICK"] = "alluvial-node-click";
      Alluvial2["NODE_MOUSEOUT"] = "alluvial-node-mouseout";
      Alluvial2["NODE_MOUSEMOVE"] = "alluvial-node-mousemove";
      Alluvial2["LINE_MOUSEOVER"] = "alluvial-line-mouseover";
      Alluvial2["LINE_CLICK"] = "alluvial-line-click";
      Alluvial2["LINE_MOUSEOUT"] = "alluvial-line-mouseout";
      Alluvial2["LINE_MOUSEMOVE"] = "alluvial-line-mousemove";
    })(Alluvial$1 || (Alluvial$1 = {}));
    (function(Meter2) {
      Meter2["METER_MOUSEOVER"] = "meter-mouseover";
      Meter2["METER_CLICK"] = "meter-click";
      Meter2["METER_MOUSEOUT"] = "meter-mouseout";
      Meter2["METER_MOUSEMOVE"] = "meter-mousemove";
    })(Meter$1 || (Meter$1 = {}));
    (function(Heatmap2) {
      Heatmap2["HEATMAP_MOUSEOVER"] = "heatmap-mouseover";
      Heatmap2["HEATMAP_CLICK"] = "heatmap-click";
      Heatmap2["HEATMAP_MOUSEOUT"] = "heatmap-mouseout";
      Heatmap2["HEATMAP_MOUSEMOVE"] = "hetmap-mousemove";
    })(Heatmap$1 || (Heatmap$1 = {}));
    EventEnums = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      get Chart() {
        return Chart$1;
      },
      get Modal() {
        return Modal$2;
      },
      get Model() {
        return Model;
      },
      get Toolbar() {
        return Toolbar$1;
      },
      get ZoomBar() {
        return ZoomBar$1;
      },
      get ZoomDomain() {
        return ZoomDomain;
      },
      get CanvasZoom() {
        return CanvasZoom$1;
      },
      get Axis() {
        return Axis$1;
      },
      get Area() {
        return Area$1;
      },
      get WordCloud() {
        return WordCloud$1;
      },
      get Pie() {
        return Pie$1;
      },
      get Gauge() {
        return Gauge$1;
      },
      get Bar() {
        return Bar$1;
      },
      get Boxplot() {
        return Boxplot$1;
      },
      get Scatter() {
        return Scatter$1;
      },
      get Line() {
        return Line$1;
      },
      get Radar() {
        return Radar$1;
      },
      get Tree() {
        return Tree$1;
      },
      get Treemap() {
        return Treemap$1;
      },
      get Tooltip() {
        return Tooltip$1;
      },
      get Threshold() {
        return Threshold$1;
      },
      get Legend() {
        return Legend$1;
      },
      get CirclePack() {
        return CirclePack$1;
      },
      get Alluvial() {
        return Alluvial$1;
      },
      get Meter() {
        return Meter$1;
      },
      get Heatmap() {
        return Heatmap$1;
      }
    }, Symbol.toStringTag, { value: "Module" }));
    Events$1 = EventEnums;
    (function(RenderTypes2) {
      RenderTypes2["HTML"] = "html";
      RenderTypes2["SVG"] = "svg";
    })(RenderTypes || (RenderTypes = {}));
    (function(ChartTheme2) {
      ChartTheme2["DEFAULT"] = "default";
      ChartTheme2["G100"] = "g100";
      ChartTheme2["G90"] = "g90";
      ChartTheme2["G10"] = "g10";
    })(ChartTheme || (ChartTheme = {}));
    (function(ColorClassNameTypes2) {
      ColorClassNameTypes2["BACKGROUND"] = "background";
      ColorClassNameTypes2["FILL"] = "fill";
      ColorClassNameTypes2["STROKE"] = "stroke";
      ColorClassNameTypes2["TOOLTIP"] = "tooltip";
    })(ColorClassNameTypes || (ColorClassNameTypes = {}));
    (function(AxisPositions2) {
      AxisPositions2["LEFT"] = "left";
      AxisPositions2["RIGHT"] = "right";
      AxisPositions2["TOP"] = "top";
      AxisPositions2["BOTTOM"] = "bottom";
    })(AxisPositions || (AxisPositions = {}));
    (function(ZoomBarTypes2) {
      ZoomBarTypes2["GRAPH_VIEW"] = "graph_view";
      ZoomBarTypes2["SLIDER_VIEW"] = "slider_view";
    })(ZoomBarTypes || (ZoomBarTypes = {}));
    (function(TruncationTypes2) {
      TruncationTypes2["END_LINE"] = "end_line";
      TruncationTypes2["MID_LINE"] = "mid_line";
      TruncationTypes2["FRONT_LINE"] = "front_line";
      TruncationTypes2["NONE"] = "none";
    })(TruncationTypes || (TruncationTypes = {}));
    (function(CartesianOrientations2) {
      CartesianOrientations2["VERTICAL"] = "vertical";
      CartesianOrientations2["HORIZONTAL"] = "horizontal";
    })(CartesianOrientations || (CartesianOrientations = {}));
    (function(ScaleTypes2) {
      ScaleTypes2["TIME"] = "time";
      ScaleTypes2["LINEAR"] = "linear";
      ScaleTypes2["LOG"] = "log";
      ScaleTypes2["LABELS"] = "labels";
      ScaleTypes2["LABELS_RATIO"] = "labels-ratio";
    })(ScaleTypes || (ScaleTypes = {}));
    (function(LegendPositions2) {
      LegendPositions2["RIGHT"] = "right";
      LegendPositions2["LEFT"] = "left";
      LegendPositions2["TOP"] = "top";
      LegendPositions2["BOTTOM"] = "bottom";
    })(LegendPositions || (LegendPositions = {}));
    (function(Alignments2) {
      Alignments2["LEFT"] = "left";
      Alignments2["CENTER"] = "center";
      Alignments2["RIGHT"] = "right";
    })(Alignments || (Alignments = {}));
    (function(LegendOrientations2) {
      LegendOrientations2["HORIZONTAL"] = "horizontal";
      LegendOrientations2["VERTICAL"] = "vertical";
    })(LegendOrientations || (LegendOrientations = {}));
    (function(TreeTypes2) {
      TreeTypes2["TREE"] = "tree";
      TreeTypes2["DENDROGRAM"] = "dendrogram";
    })(TreeTypes || (TreeTypes = {}));
    (function(LayoutDirection2) {
      LayoutDirection2["ROW"] = "row";
      LayoutDirection2["COLUMN"] = "column";
      LayoutDirection2["ROW_REVERSE"] = "row-reverse";
      LayoutDirection2["COLUMN_REVERSE"] = "column-reverse";
    })(LayoutDirection || (LayoutDirection = {}));
    (function(LayoutGrowth2) {
      LayoutGrowth2["FIXED"] = "fixed";
      LayoutGrowth2["PREFERRED"] = "preferred";
      LayoutGrowth2["STRETCH"] = "stretch";
    })(LayoutGrowth || (LayoutGrowth = {}));
    (function(LayoutAlignItems2) {
      LayoutAlignItems2["CENTER"] = "center";
    })(LayoutAlignItems || (LayoutAlignItems = {}));
    (function(CalloutDirections2) {
      CalloutDirections2["LEFT"] = "left";
      CalloutDirections2["RIGHT"] = "right";
    })(CalloutDirections || (CalloutDirections = {}));
    (function(Skeletons2) {
      Skeletons2["GRID"] = "grid";
      Skeletons2["VERT_OR_HORIZ"] = "vertOrHoriz";
      Skeletons2["PIE"] = "pie";
      Skeletons2["DONUT"] = "donut";
    })(Skeletons || (Skeletons = {}));
    (function(TextAnchor2) {
      TextAnchor2["START"] = "start";
      TextAnchor2["MIDDLE"] = "middle";
      TextAnchor2["END"] = "end";
    })(TextAnchor || (TextAnchor = {}));
    (function(DominantBaseline2) {
      DominantBaseline2["BASELINE"] = "baseline";
      DominantBaseline2["MIDDLE"] = "middle";
      DominantBaseline2["HANGING"] = "hanging";
    })(DominantBaseline || (DominantBaseline = {}));
    (function(GaugeTypes2) {
      GaugeTypes2["SEMI"] = "semi";
      GaugeTypes2["FULL"] = "full";
    })(GaugeTypes || (GaugeTypes = {}));
    (function(ArrowDirections2) {
      ArrowDirections2["UP"] = "up";
      ArrowDirections2["DOWN"] = "down";
    })(ArrowDirections || (ArrowDirections = {}));
    (function(Statuses2) {
      Statuses2["SUCCESS"] = "success";
      Statuses2["WARNING"] = "warning";
      Statuses2["DANGER"] = "danger";
    })(Statuses || (Statuses = {}));
    (function(TickRotations2) {
      TickRotations2["ALWAYS"] = "always";
      TickRotations2["AUTO"] = "auto";
      TickRotations2["NEVER"] = "never";
    })(TickRotations || (TickRotations = {}));
    (function(ChartTypes2) {
      ChartTypes2["SCATTER"] = "scatter";
      ChartTypes2["LINE"] = "line";
      ChartTypes2["SIMPLE_BAR"] = "simple-bar";
      ChartTypes2["STACKED_BAR"] = "stacked-bar";
      ChartTypes2["GROUPED_BAR"] = "grouped-bar";
      ChartTypes2["AREA"] = "area";
      ChartTypes2["STACKED_AREA"] = "stacked-area";
    })(ChartTypes || (ChartTypes = {}));
    (function(ToolbarControlTypes2) {
      ToolbarControlTypes2["EXPORT_CSV"] = "Export as CSV";
      ToolbarControlTypes2["EXPORT_PNG"] = "Export as PNG";
      ToolbarControlTypes2["EXPORT_JPG"] = "Export as JPG";
      ToolbarControlTypes2["ZOOM_IN"] = "Zoom in";
      ToolbarControlTypes2["ZOOM_OUT"] = "Zoom out";
      ToolbarControlTypes2["RESET_ZOOM"] = "Reset zoom";
      ToolbarControlTypes2["MAKE_FULLSCREEN"] = "Make fullscreen";
      ToolbarControlTypes2["SHOW_AS_DATATABLE"] = "Show as data-table";
      ToolbarControlTypes2["CUSTOM"] = "Custom";
    })(ToolbarControlTypes || (ToolbarControlTypes = {}));
    (function(AxisTitleOrientations2) {
      AxisTitleOrientations2["LEFT"] = "left";
      AxisTitleOrientations2["RIGHT"] = "right";
    })(AxisTitleOrientations || (AxisTitleOrientations = {}));
    (function(LegendItemType2) {
      LegendItemType2["CHECKBOX"] = "checkbox";
      LegendItemType2["RADIUS"] = "radius";
      LegendItemType2["AREA"] = "area";
      LegendItemType2["SIZE"] = "size";
      LegendItemType2["LINE"] = "line";
      LegendItemType2["QUARTILE"] = "quartile";
      LegendItemType2["ZOOM"] = "zoom";
    })(LegendItemType || (LegendItemType = {}));
    (function(ColorLegendType2) {
      ColorLegendType2["LINEAR"] = "linear";
      ColorLegendType2["QUANTIZE"] = "quantize";
    })(ColorLegendType || (ColorLegendType = {}));
    (function(DividerStatus2) {
      DividerStatus2["ON"] = "on";
      DividerStatus2["AUTO"] = "auto";
      DividerStatus2["OFF"] = "off";
    })(DividerStatus || (DividerStatus = {}));
    (function(AxisFlavor2) {
      AxisFlavor2["DEFAULT"] = "default";
      AxisFlavor2["HOVERABLE"] = "hoverable";
    })(AxisFlavor || (AxisFlavor = {}));
    linear$2 = (t2) => +t2;
    area$1 = {
      opacity: {
        unselected: 0.05,
        selected: 0.4
      }
    };
    axis$1 = {
      ticks: {
        number: 7,
        rotateIfSmallerThan: 30,
        verticalSpaceRatio: 2.5,
        horizontalSpaceRatio: 3.5
      },
      ratio: {
        reference: "value",
        compareTo: "marker"
      },
      paddingRatio: 0.1,
      hover: {
        rectanglePadding: 4
      }
    };
    canvasZoomSettings = {
      duration: 1e3,
      ease: cubicInOut,
      zoomLevel: 3
    };
    circlePack = {
      circles: {
        fillOpacity: 0.3,
        hover: {
          stroke: "#FFF"
        }
      },
      padding: {
        mainGroup: 4,
        children: 2
      },
      hierarchyLevel: 2
    };
    color$1 = {
      pairingOptions: {
        "1-color": 4,
        "2-color": 5,
        "3-color": 5,
        "4-color": 3,
        "5-color": 2,
        "14-color": 1
      }
    };
    boxplot = {
      circle: {
        radius: 4,
        opacity: {
          hovered: 1,
          default: 0.3
        }
      },
      box: {
        opacity: {
          hovered: 0.5,
          default: 0.3
        }
      },
      strokeWidth: {
        default: 1,
        thicker: 2
      }
    };
    histogram = {
      defaultBins: 10
    };
    legend$1 = {
      items: {
        status: {
          ACTIVE: 1,
          DISABLED: 0
        },
        horizontalSpace: 12,
        verticalSpace: 24,
        textYOffset: 8,
        spaceAfter: 4
      },
      checkbox: {
        radius: 6.5
      },
      radius: {
        iconData: [
          { cx: 7, cy: 7, r: 6.5 },
          { cx: 7, cy: 10, r: 3.5 }
        ],
        fill: null,
        stroke: "#8c8c8c"
      },
      line: {
        yPosition: 6,
        width: 24,
        strokeWidth: 1.4,
        fill: null,
        stroke: "#999999"
      },
      area: {
        width: 24,
        height: 14,
        fill: "#6f6f6f",
        stroke: null
      },
      size: {
        iconData: [
          { width: 23, height: 12 },
          { width: 13, height: 6 }
        ],
        fill: null,
        stroke: "#8D8D8D"
      },
      quartile: {
        iconData: [
          { x: 0, y: 0, width: 24, height: 13 },
          { x: 11, y: 4, width: 1, height: 4 }
        ]
      },
      zoom: {
        iconData: [{ x: 0, y: 0, width: 12, height: 12 }],
        color: "#8D8D8D"
      },
      color: {
        barWidth: 300,
        barHeight: 8,
        axisYTranslation: 10
      }
    };
    lines = {
      opacity: {
        unselected: 0.3,
        selected: 1
      },
      weight: {
        selected: 2,
        unselected: 1
      }
    };
    meter = {
      statusBar: {
        paddingRight: 5
      },
      status: {
        indicatorSize: 16,
        paddingLeft: 15
      },
      total: {
        paddingLeft: 36,
        paddingRight: 24
      },
      height: {
        default: 8,
        proportional: 16
      },
      dividerWidth: 2
    };
    pie$1 = {
      radiusOffset: -15,
      innerRadius: 2,
      padAngle: 7e-3,
      hoverArc: {
        outerRadiusOffset: 3
      },
      xOffset: 30,
      yOffset: 20,
      yOffsetCallout: 10,
      callout: {
        minSliceDegree: 5,
        offsetX: 15,
        offsetY: 12,
        horizontalLineLength: 8,
        textMargin: 2
      }
    };
    radar = {
      opacity: {
        unselected: 0.1,
        selected: 0.3
      },
      xLabelPadding: 10,
      yLabelPadding: 8,
      yTicksNumber: 4,
      minRange: 10,
      xAxisRectHeight: 50,
      dotsRadius: 5
    };
    alluvial = {
      nodeWidth: 4,
      nodeHoveredWidth: 8,
      minNodePadding: 24,
      opacity: {
        unfocus: 0.3,
        default: 0.8,
        selected: 1
      }
    };
    heatmap = {
      minCellDividerDimension: 16,
      chartPadding: 0.5
    };
    spacers = {
      default: {
        size: 24
      }
    };
    tooltips = {
      horizontalOffset: 10
    };
    transitions = {
      default: {
        duration: 300
      },
      pie_slice_mouseover: {
        duration: 100
      },
      pie_chart_titles: {
        duration: 375
      },
      graph_element_mouseover_fill_update: {
        duration: 100
      },
      graph_element_mouseout_fill_update: {
        duration: 100
      }
    };
    toolbar = {
      buttonSize: 32,
      iconSize: 20,
      height: 32,
      spacerHeight: 10,
      iconPadding: 6
    };
    zoomBar = {
      height: (_a$2 = {}, _a$2[ZoomBarTypes.GRAPH_VIEW] = 32, _a$2[ZoomBarTypes.SLIDER_VIEW] = 10, _a$2),
      spacerHeight: 8,
      handleWidth: 5,
      handleBarWidth: 1,
      handleBarHeight: 12
    };
    defaultLegendAdditionalItems = [
      {
        type: LegendItemType.RADIUS,
        name: "Radius"
      },
      {
        type: LegendItemType.AREA,
        name: "Poor area"
      },
      {
        type: LegendItemType.AREA,
        name: "Satisfactory area"
      },
      {
        type: LegendItemType.AREA,
        name: "Great area"
      },
      {
        type: LegendItemType.QUARTILE,
        name: "Quartiles"
      }
    ];
    freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    freeGlobal$1 = freeGlobal;
    freeSelf = typeof self == "object" && self && self.Object === Object && self;
    root$1 = freeGlobal$1 || freeSelf || Function("return this")();
    root$2 = root$1;
    Symbol$1 = root$2.Symbol;
    Symbol$2 = Symbol$1;
    objectProto$h = Object.prototype;
    hasOwnProperty$e = objectProto$h.hasOwnProperty;
    nativeObjectToString$1 = objectProto$h.toString;
    symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
    objectProto$g = Object.prototype;
    nativeObjectToString = objectProto$g.toString;
    nullTag = "[object Null]";
    undefinedTag = "[object Undefined]";
    symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
    symbolTag$3 = "[object Symbol]";
    isArray = Array.isArray;
    isArray$1 = isArray;
    INFINITY$3 = 1 / 0;
    symbolProto$2 = Symbol$2 ? Symbol$2.prototype : void 0;
    symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
    reWhitespace = /\s/;
    reTrimStart = /^\s+/;
    NAN = 0 / 0;
    reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    reIsBinary = /^0b[01]+$/i;
    reIsOctal = /^0o[0-7]+$/i;
    freeParseInt = parseInt;
    asyncTag = "[object AsyncFunction]";
    funcTag$2 = "[object Function]";
    genTag$1 = "[object GeneratorFunction]";
    proxyTag = "[object Proxy]";
    coreJsData = root$2["__core-js_shared__"];
    coreJsData$1 = coreJsData;
    maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    funcProto$2 = Function.prototype;
    funcToString$2 = funcProto$2.toString;
    reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    reIsHostCtor = /^\[object .+?Constructor\]$/;
    funcProto$1 = Function.prototype;
    objectProto$f = Object.prototype;
    funcToString$1 = funcProto$1.toString;
    hasOwnProperty$d = objectProto$f.hasOwnProperty;
    reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$d).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    WeakMap$1 = getNative(root$2, "WeakMap");
    WeakMap$2 = WeakMap$1;
    objectCreate = Object.create;
    baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    baseCreate$1 = baseCreate;
    HOT_COUNT = 800;
    HOT_SPAN = 16;
    nativeNow = Date.now;
    defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e3) {
      }
    }();
    defineProperty$1 = defineProperty;
    baseSetToString = !defineProperty$1 ? identity$6 : function(func, string) {
      return defineProperty$1(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant$8(string),
        "writable": true
      });
    };
    baseSetToString$1 = baseSetToString;
    setToString = shortOut(baseSetToString$1);
    setToString$1 = setToString;
    MAX_SAFE_INTEGER$1 = 9007199254740991;
    reIsUint = /^(?:0|[1-9]\d*)$/;
    objectProto$e = Object.prototype;
    hasOwnProperty$c = objectProto$e.hasOwnProperty;
    nativeMax$1 = Math.max;
    MAX_SAFE_INTEGER = 9007199254740991;
    objectProto$d = Object.prototype;
    argsTag$3 = "[object Arguments]";
    objectProto$c = Object.prototype;
    hasOwnProperty$b = objectProto$c.hasOwnProperty;
    propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
    isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty$b.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
    };
    isArguments$1 = isArguments;
    freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    Buffer$1 = moduleExports$2 ? root$2.Buffer : void 0;
    nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
    isBuffer = nativeIsBuffer || stubFalse;
    isBuffer$1 = isBuffer;
    argsTag$2 = "[object Arguments]";
    arrayTag$2 = "[object Array]";
    boolTag$3 = "[object Boolean]";
    dateTag$3 = "[object Date]";
    errorTag$2 = "[object Error]";
    funcTag$1 = "[object Function]";
    mapTag$6 = "[object Map]";
    numberTag$3 = "[object Number]";
    objectTag$4 = "[object Object]";
    regexpTag$3 = "[object RegExp]";
    setTag$6 = "[object Set]";
    stringTag$3 = "[object String]";
    weakMapTag$2 = "[object WeakMap]";
    arrayBufferTag$3 = "[object ArrayBuffer]";
    dataViewTag$4 = "[object DataView]";
    float32Tag$2 = "[object Float32Array]";
    float64Tag$2 = "[object Float64Array]";
    int8Tag$2 = "[object Int8Array]";
    int16Tag$2 = "[object Int16Array]";
    int32Tag$2 = "[object Int32Array]";
    uint8Tag$2 = "[object Uint8Array]";
    uint8ClampedTag$2 = "[object Uint8ClampedArray]";
    uint16Tag$2 = "[object Uint16Array]";
    uint32Tag$2 = "[object Uint32Array]";
    typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$6] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$4] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$6] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    freeProcess = moduleExports$1 && freeGlobal$1.process;
    nodeUtil = function() {
      try {
        var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    nodeUtil$1 = nodeUtil;
    nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
    isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    isTypedArray$1 = isTypedArray;
    objectProto$b = Object.prototype;
    hasOwnProperty$a = objectProto$b.hasOwnProperty;
    nativeKeys = overArg(Object.keys, Object);
    nativeKeys$1 = nativeKeys;
    objectProto$a = Object.prototype;
    hasOwnProperty$9 = objectProto$a.hasOwnProperty;
    objectProto$9 = Object.prototype;
    hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    reIsPlainProp = /^\w*$/;
    nativeCreate = getNative(Object, "create");
    nativeCreate$1 = nativeCreate;
    HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    objectProto$8 = Object.prototype;
    hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    objectProto$7 = Object.prototype;
    hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    arrayProto = Array.prototype;
    splice = arrayProto.splice;
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    Map$1 = getNative(root$2, "Map");
    Map$2 = Map$1;
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    FUNC_ERROR_TEXT$1 = "Expected a function";
    memoize.Cache = MapCache;
    MAX_MEMOIZE_SIZE = 500;
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    reEscapeChar = /\\(\\)?/g;
    stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number3, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match2);
      });
      return result;
    });
    stringToPath$1 = stringToPath;
    INFINITY$2 = 1 / 0;
    spreadableSymbol = Symbol$2 ? Symbol$2.isConcatSpreadable : void 0;
    getPrototype = overArg(Object.getPrototypeOf, Object);
    getPrototype$1 = getPrototype;
    objectTag$3 = "[object Object]";
    funcProto = Function.prototype;
    objectProto$6 = Object.prototype;
    funcToString = funcProto.toString;
    hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    objectCtorString = funcToString.call(Object);
    rsAstralRange$2 = "\\ud800-\\udfff";
    rsComboMarksRange$3 = "\\u0300-\\u036f";
    reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange$3 = "\\u20d0-\\u20ff";
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;
    rsVarRange$2 = "\\ufe0e\\ufe0f";
    rsZWJ$2 = "\\u200d";
    reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
    rsAstralRange$1 = "\\ud800-\\udfff";
    rsComboMarksRange$2 = "\\u0300-\\u036f";
    reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange$2 = "\\u20d0-\\u20ff";
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
    rsVarRange$1 = "\\ufe0e\\ufe0f";
    rsAstral = "[" + rsAstralRange$1 + "]";
    rsCombo$2 = "[" + rsComboRange$2 + "]";
    rsFitz$1 = "\\ud83c[\\udffb-\\udfff]";
    rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")";
    rsNonAstral$1 = "[^" + rsAstralRange$1 + "]";
    rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsZWJ$1 = "\\u200d";
    reOptMod$1 = rsModifier$1 + "?";
    rsOptVar$1 = "[" + rsVarRange$1 + "]?";
    rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*";
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1;
    rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")";
    reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
    upperFirst = createCaseFirst("toUpperCase");
    upperFirst$1 = upperFirst;
    deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    deburrLetter = basePropertyOf(deburredLetters);
    deburrLetter$1 = deburrLetter;
    reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    rsComboMarksRange$1 = "\\u0300-\\u036f";
    reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
    rsCombo$1 = "[" + rsComboRange$1 + "]";
    reComboMark = RegExp(rsCombo$1, "g");
    reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    rsAstralRange = "\\ud800-\\udfff";
    rsComboMarksRange = "\\u0300-\\u036f";
    reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    rsComboSymbolsRange = "\\u20d0-\\u20ff";
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    rsDingbatRange = "\\u2700-\\u27bf";
    rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    rsPunctuationRange = "\\u2000-\\u206f";
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    rsVarRange = "\\ufe0e\\ufe0f";
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    rsApos$1 = "['\u2019]";
    rsBreak = "[" + rsBreakRange + "]";
    rsCombo = "[" + rsComboRange + "]";
    rsDigits = "\\d+";
    rsDingbat = "[" + rsDingbatRange + "]";
    rsLower = "[" + rsLowerRange + "]";
    rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    rsFitz = "\\ud83c[\\udffb-\\udfff]";
    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    rsNonAstral = "[^" + rsAstralRange + "]";
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsUpper = "[" + rsUpperRange + "]";
    rsZWJ = "\\u200d";
    rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?";
    rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?";
    reOptMod = rsModifier + "?";
    rsOptVar = "[" + rsVarRange + "]?";
    rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    rsSeq = rsOptVar + reOptMod + rsOptJoin;
    rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    rsApos = "['\u2019]";
    reApos = RegExp(rsApos, "g");
    camelCase = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize(word) : word);
    });
    lodashCamelCase = camelCase;
    LARGE_ARRAY_SIZE$1 = 200;
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    moduleExports = freeModule && freeModule.exports === freeExports;
    Buffer2 = moduleExports ? root$2.Buffer : void 0;
    allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    objectProto$5 = Object.prototype;
    propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
    nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    getSymbols = !nativeGetSymbols$1 ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    getSymbols$1 = getSymbols;
    nativeGetSymbols = Object.getOwnPropertySymbols;
    getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush(result, getSymbols$1(object2));
        object2 = getPrototype$1(object2);
      }
      return result;
    };
    getSymbolsIn$1 = getSymbolsIn;
    DataView$1 = getNative(root$2, "DataView");
    DataView$2 = DataView$1;
    Promise$1 = getNative(root$2, "Promise");
    Promise$2 = Promise$1;
    Set$1 = getNative(root$2, "Set");
    Set$2 = Set$1;
    mapTag$5 = "[object Map]";
    objectTag$2 = "[object Object]";
    promiseTag = "[object Promise]";
    setTag$5 = "[object Set]";
    weakMapTag$1 = "[object WeakMap]";
    dataViewTag$3 = "[object DataView]";
    dataViewCtorString = toSource(DataView$2);
    mapCtorString = toSource(Map$2);
    promiseCtorString = toSource(Promise$2);
    setCtorString = toSource(Set$2);
    weakMapCtorString = toSource(WeakMap$2);
    getTag = baseGetTag;
    if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$3 || Map$2 && getTag(new Map$2()) != mapTag$5 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$5 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) {
      getTag = function(value2) {
        var result = baseGetTag(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$3;
            case mapCtorString:
              return mapTag$5;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$5;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    getTag$1 = getTag;
    objectProto$4 = Object.prototype;
    hasOwnProperty$4 = objectProto$4.hasOwnProperty;
    Uint8Array$1 = root$2.Uint8Array;
    Uint8Array$2 = Uint8Array$1;
    reFlags = /\w*$/;
    symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0;
    symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
    boolTag$2 = "[object Boolean]";
    dateTag$2 = "[object Date]";
    mapTag$4 = "[object Map]";
    numberTag$2 = "[object Number]";
    regexpTag$2 = "[object RegExp]";
    setTag$4 = "[object Set]";
    stringTag$2 = "[object String]";
    symbolTag$2 = "[object Symbol]";
    arrayBufferTag$2 = "[object ArrayBuffer]";
    dataViewTag$2 = "[object DataView]";
    float32Tag$1 = "[object Float32Array]";
    float64Tag$1 = "[object Float64Array]";
    int8Tag$1 = "[object Int8Array]";
    int16Tag$1 = "[object Int16Array]";
    int32Tag$1 = "[object Int32Array]";
    uint8Tag$1 = "[object Uint8Array]";
    uint8ClampedTag$1 = "[object Uint8ClampedArray]";
    uint16Tag$1 = "[object Uint16Array]";
    uint32Tag$1 = "[object Uint32Array]";
    mapTag$3 = "[object Map]";
    nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
    isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    isMap$1 = isMap;
    setTag$3 = "[object Set]";
    nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
    isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    isSet$1 = isSet;
    CLONE_DEEP_FLAG$1 = 1;
    CLONE_FLAT_FLAG = 2;
    CLONE_SYMBOLS_FLAG$1 = 4;
    argsTag$1 = "[object Arguments]";
    arrayTag$1 = "[object Array]";
    boolTag$1 = "[object Boolean]";
    dateTag$1 = "[object Date]";
    errorTag$1 = "[object Error]";
    funcTag = "[object Function]";
    genTag = "[object GeneratorFunction]";
    mapTag$2 = "[object Map]";
    numberTag$1 = "[object Number]";
    objectTag$1 = "[object Object]";
    regexpTag$1 = "[object RegExp]";
    setTag$2 = "[object Set]";
    stringTag$1 = "[object String]";
    symbolTag$1 = "[object Symbol]";
    weakMapTag = "[object WeakMap]";
    arrayBufferTag$1 = "[object ArrayBuffer]";
    dataViewTag$1 = "[object DataView]";
    float32Tag = "[object Float32Array]";
    float64Tag = "[object Float64Array]";
    int8Tag = "[object Int8Array]";
    int16Tag = "[object Int16Array]";
    int32Tag = "[object Int32Array]";
    uint8Tag = "[object Uint8Array]";
    uint8ClampedTag = "[object Uint8ClampedArray]";
    uint16Tag = "[object Uint16Array]";
    uint32Tag = "[object Uint32Array]";
    cloneableTags = {};
    cloneableTags[argsTag$1] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$1] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$2] = cloneableTags[numberTag$1] = cloneableTags[objectTag$1] = cloneableTags[regexpTag$1] = cloneableTags[setTag$2] = cloneableTags[stringTag$1] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    CLONE_DEEP_FLAG = 1;
    CLONE_SYMBOLS_FLAG = 4;
    HASH_UNDEFINED = "__lodash_hash_undefined__";
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    COMPARE_PARTIAL_FLAG$5 = 1;
    COMPARE_UNORDERED_FLAG$3 = 2;
    COMPARE_PARTIAL_FLAG$4 = 1;
    COMPARE_UNORDERED_FLAG$2 = 2;
    boolTag = "[object Boolean]";
    dateTag = "[object Date]";
    errorTag = "[object Error]";
    mapTag$1 = "[object Map]";
    numberTag = "[object Number]";
    regexpTag = "[object RegExp]";
    setTag$1 = "[object Set]";
    stringTag = "[object String]";
    symbolTag = "[object Symbol]";
    arrayBufferTag = "[object ArrayBuffer]";
    dataViewTag = "[object DataView]";
    symbolProto = Symbol$2 ? Symbol$2.prototype : void 0;
    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    COMPARE_PARTIAL_FLAG$3 = 1;
    objectProto$3 = Object.prototype;
    hasOwnProperty$3 = objectProto$3.hasOwnProperty;
    COMPARE_PARTIAL_FLAG$2 = 1;
    argsTag = "[object Arguments]";
    arrayTag = "[object Array]";
    objectTag = "[object Object]";
    objectProto$2 = Object.prototype;
    hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    COMPARE_PARTIAL_FLAG$1 = 1;
    COMPARE_UNORDERED_FLAG$1 = 2;
    COMPARE_PARTIAL_FLAG = 1;
    COMPARE_UNORDERED_FLAG = 2;
    baseFor = createBaseFor();
    baseFor$1 = baseFor;
    baseEach = createBaseEach(baseForOwn);
    baseEach$1 = baseEach;
    now$1 = function() {
      return root$2.Date.now();
    };
    now$2 = now$1;
    FUNC_ERROR_TEXT = "Expected a function";
    nativeMax = Math.max;
    nativeMin = Math.min;
    INFINITY$1 = 1 / 0;
    objectProto$1 = Object.prototype;
    hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    groupBy = createAggregator(function(result, value2, key2) {
      if (hasOwnProperty$1.call(result, key2)) {
        result[key2].push(value2);
      } else {
        baseAssignValue(result, key2, [value2]);
      }
    });
    lodashGroupBy = groupBy;
    mapTag = "[object Map]";
    setTag = "[object Set]";
    objectProto = Object.prototype;
    hasOwnProperty = objectProto.hasOwnProperty;
    kebabCase = createCompounder(function(result, word, index2) {
      return result + (index2 ? "-" : "") + word.toLowerCase();
    });
    lodashKebabCase = kebabCase;
    merge = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    lodashMerge = merge;
    INFINITY = 1 / 0;
    createSet = !(Set$2 && 1 / setToArray(new Set$2([, -0]))[1] == INFINITY) ? noop$3 : function(values) {
      return new Set$2(values);
    };
    createSet$1 = createSet;
    LARGE_ARRAY_SIZE = 200;
    unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = void 0;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
    });
    lodashUnionBy = unionBy;
    xhtml = "http://www.w3.org/1999/xhtml";
    namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };
    find$1 = Array.prototype.find;
    filter = Array.prototype.filter;
    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) {
        return this._parent.insertBefore(child, this._next);
      },
      insertBefore: function(child, next) {
        return this._parent.insertBefore(child, next);
      },
      querySelector: function(selector2) {
        return this._parent.querySelector(selector2);
      },
      querySelectorAll: function(selector2) {
        return this._parent.querySelectorAll(selector2);
      }
    };
    ClassList.prototype = {
      add: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i2 = this._names.indexOf(name);
        if (i2 >= 0) {
          this._names.splice(i2, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };
    root = [null];
    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };
    (function(Tools2) {
      Tools2.debounce = debounce;
      Tools2.clone = cloneDeep;
      Tools2.merge = lodashMerge;
      Tools2.unionBy = lodashUnionBy;
      Tools2.removeArrayDuplicates = uniq;
      Tools2.clamp = clamp;
      Tools2.flatten = flatten$1;
      Tools2.groupBy = lodashGroupBy;
      Tools2.camelCase = lodashCamelCase;
      Tools2.isEmpty = isEmpty;
      Tools2.isEqual = isEqual;
      Tools2.flatMapDeep = flatMapDeep;
      Tools2.kebabCase = lodashKebabCase;
      Tools2.fromPairs = fromPairs;
      Tools2.some = some;
      function debounceWithD3MousePosition(fn, delay, holder) {
        var timer2 = null;
        return function() {
          var context = this;
          var args = arguments;
          context.mousePosition = pointer(args[0], holder);
          clearTimeout(timer2);
          timer2 = setTimeout(function() {
            fn.apply(context, args);
          }, delay);
        };
      }
      Tools2.debounceWithD3MousePosition = debounceWithD3MousePosition;
      function mergeDefaultChartOptions(defaultOptions, providedOptions) {
        var _a22, _b;
        var clonedDefaultOptions = Tools2.clone(defaultOptions);
        var providedAxesNames = Object.keys(providedOptions.axes || {});
        if ((_b = (_a22 = providedOptions) === null || _a22 === void 0 ? void 0 : _a22.toolbar) === null || _b === void 0 ? void 0 : _b.controls) {
          delete clonedDefaultOptions.toolbar.controls;
        }
        if (providedAxesNames.length === 0) {
          delete clonedDefaultOptions.axes;
        }
        for (var axisName in clonedDefaultOptions.axes) {
          if (providedAxesNames.includes(axisName)) {
            var providedAxisOptions = providedOptions.axes[axisName];
            if (providedAxisOptions["primary"] || providedAxisOptions["secondary"]) {
              console.warn("`primary` & `secondary` are no longer needed for axis configurations. Read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format");
            }
            var identifier = providedAxisOptions["mapsTo"];
            if (identifier === void 0 || identifier === null) {
              var scaleType = providedAxisOptions["scaleType"];
              if (scaleType === void 0 || scaleType === null) {
                providedAxisOptions["mapsTo"] = "value";
              } else if (scaleType === ScaleTypes.TIME) {
                providedAxisOptions["mapsTo"] = "date";
              } else if (scaleType === ScaleTypes.LABELS) {
                providedAxisOptions["mapsTo"] = "key";
              }
            }
          } else {
            delete clonedDefaultOptions.axes[axisName];
          }
        }
        updateLegendAdditionalItems(clonedDefaultOptions, providedOptions);
        return Tools2.merge(clonedDefaultOptions, providedOptions);
      }
      Tools2.mergeDefaultChartOptions = mergeDefaultChartOptions;
      function getDimensions(el) {
        return {
          width: parseFloat(el.style.width.replace("px", "") || el.offsetWidth),
          height: parseFloat(el.style.height.replace("px", "") || el.offsetHeight)
        };
      }
      Tools2.getDimensions = getDimensions;
      function getTranslationValues(elementRef) {
        if (!elementRef) {
          return;
        }
        var translateRegex = /translate\([0-9]+\.?[0-9]*,[0-9]+\.?[0-9]*\)/;
        var transformStr = elementRef.getAttribute("transform").match(translateRegex);
        if (!transformStr) {
          return null;
        }
        if (transformStr[0]) {
          var transforms = transformStr[0].replace(/translate\(/, "").replace(/\)/, "").split(",");
          return {
            tx: transforms[0],
            ty: transforms[1]
          };
        }
        return null;
      }
      Tools2.getTranslationValues = getTranslationValues;
      function getTranformOffsets(string) {
        var regExp = /\(([^)]+)\)/;
        var match2 = regExp.exec(string)[1];
        var xyString = match2.split(",");
        return {
          x: parseFloat(xyString[0]),
          y: parseFloat(xyString[1])
        };
      }
      Tools2.getTranformOffsets = getTranformOffsets;
      function formatWidthHeightValues(value2) {
        var stringValue = value2.toString();
        if (stringValue.match(/[a-z]/i)) {
          return stringValue;
        }
        return stringValue + "px";
      }
      Tools2.formatWidthHeightValues = formatWidthHeightValues;
      function capitalizeFirstLetter(string) {
        return string[0].toUpperCase() + string.slice(1);
      }
      Tools2.capitalizeFirstLetter = capitalizeFirstLetter;
      function convertValueToPercentage(item, fullData, key2) {
        if (key2 === void 0) {
          key2 = "value";
        }
        var percentage = item / fullData.reduce(function(accum, val) {
          return accum + val[key2];
        }, 0) * 100;
        return percentage % 1 !== 0 ? parseFloat(percentage.toFixed(1)) : percentage;
      }
      Tools2.convertValueToPercentage = convertValueToPercentage;
      function truncateLabel(fullText, truncationType, numCharacter) {
        if (numCharacter > fullText.length) {
          return fullText;
        }
        if (truncationType === TruncationTypes.MID_LINE) {
          return fullText.substr(0, numCharacter / 2) + "..." + fullText.substr(-numCharacter / 2);
        } else if (truncationType === TruncationTypes.FRONT_LINE) {
          return "..." + fullText.substr(-numCharacter);
        } else if (truncationType === TruncationTypes.END_LINE) {
          return fullText.substr(0, numCharacter) + "...";
        }
      }
      Tools2.truncateLabel = truncateLabel;
      function updateLegendAdditionalItems(defaultOptions, providedOptions) {
        var defaultAdditionalItems = Tools2.getProperty(defaultOptions, "legend", "additionalItems");
        var userProvidedAdditionalItems = Tools2.getProperty(providedOptions, "legend", "additionalItems");
        if (defaultAdditionalItems && userProvidedAdditionalItems) {
          var providedTypes_1 = userProvidedAdditionalItems.map(function(item) {
            return item.type;
          });
          var defaultTypes_1 = defaultAdditionalItems.map(function(item) {
            return item.type;
          });
          var updatedDefaultItems = defaultLegendAdditionalItems.filter(function(item) {
            return defaultTypes_1.includes(item.type) && !providedTypes_1.includes(item.type);
          });
          defaultOptions.legend.additionalItems = updatedDefaultItems;
          providedOptions.legend.additionalItems = Tools2.unionBy(updatedDefaultItems, userProvidedAdditionalItems, "name");
        }
      }
      Tools2.updateLegendAdditionalItems = updateLegendAdditionalItems;
      function arrayDifferences(oldArray, newArray) {
        var difference = {
          missing: [],
          added: []
        };
        oldArray.forEach(function(element) {
          if (newArray.indexOf(element) === -1) {
            difference.missing.push(element);
          }
        });
        newArray.forEach(function(element) {
          if (oldArray.indexOf(element) === -1) {
            difference.added.push(element);
          }
        });
        return difference;
      }
      Tools2.arrayDifferences = arrayDifferences;
      function getDuplicateValues(arr) {
        var values = [];
        var duplicateValues = [];
        arr.forEach(function(value2) {
          if (values.indexOf(value2) !== -1 && duplicateValues.indexOf(value2) === -1) {
            duplicateValues.push(value2);
          }
          values.push(value2);
        });
        return duplicateValues;
      }
      Tools2.getDuplicateValues = getDuplicateValues;
      function moveToFront(element) {
        return element.each(function() {
          this.parentNode.appendChild(this);
        });
      }
      Tools2.moveToFront = moveToFront;
      Tools2.getProperty = function(object2) {
        var propPath = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          propPath[_i - 1] = arguments[_i];
        }
        var position = object2;
        if (position) {
          for (var _a22 = 0, propPath_1 = propPath; _a22 < propPath_1.length; _a22++) {
            var prop = propPath_1[_a22];
            if (position[prop] !== null && position[prop] !== void 0) {
              position = position[prop];
            } else {
              return null;
            }
          }
          return position;
        }
        return null;
      };
      Tools2.flipSVGCoordinatesBasedOnOrientation = function(verticalCoordinates, orientation) {
        if (orientation === CartesianOrientations.HORIZONTAL) {
          return {
            y0: verticalCoordinates.x0,
            y1: verticalCoordinates.x1,
            x0: verticalCoordinates.y0,
            x1: verticalCoordinates.y1
          };
        }
        return verticalCoordinates;
      };
      Tools2.generateSVGPathString = function(verticalCoordinates, orientation) {
        var _a22 = Tools2.flipSVGCoordinatesBasedOnOrientation(verticalCoordinates, orientation), x0 = _a22.x0, x1 = _a22.x1, y0 = _a22.y0, y1 = _a22.y1;
        return "M" + x0 + "," + y0 + "L" + x0 + "," + y1 + "L" + x1 + "," + y1 + "L" + x1 + "," + y0 + "L" + x0 + "," + y0;
      };
      function flipDomainAndRangeBasedOnOrientation(domain, range2, orientation) {
        return orientation === CartesianOrientations.VERTICAL ? [domain, range2] : [range2, domain];
      }
      Tools2.flipDomainAndRangeBasedOnOrientation = flipDomainAndRangeBasedOnOrientation;
      Tools2.compareNumeric = function(a, b) {
        return Number(a) === Number(b);
      };
    })(Tools || (Tools = {}));
    enUS = { exports: {} };
    formatDistance$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = formatDistance2;
      var formatDistanceLocale2 = {
        lessThanXSeconds: {
          one: "less than a second",
          other: "less than {{count}} seconds"
        },
        xSeconds: {
          one: "1 second",
          other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
          one: "less than a minute",
          other: "less than {{count}} minutes"
        },
        xMinutes: {
          one: "1 minute",
          other: "{{count}} minutes"
        },
        aboutXHours: {
          one: "about 1 hour",
          other: "about {{count}} hours"
        },
        xHours: {
          one: "1 hour",
          other: "{{count}} hours"
        },
        xDays: {
          one: "1 day",
          other: "{{count}} days"
        },
        aboutXMonths: {
          one: "about 1 month",
          other: "about {{count}} months"
        },
        xMonths: {
          one: "1 month",
          other: "{{count}} months"
        },
        aboutXYears: {
          one: "about 1 year",
          other: "about {{count}} years"
        },
        xYears: {
          one: "1 year",
          other: "{{count}} years"
        },
        overXYears: {
          one: "over 1 year",
          other: "over {{count}} years"
        },
        almostXYears: {
          one: "almost 1 year",
          other: "almost {{count}} years"
        }
      };
      function formatDistance2(token, count2, options2) {
        options2 = options2 || {};
        var result;
        if (typeof formatDistanceLocale2[token] === "string") {
          result = formatDistanceLocale2[token];
        } else if (count2 === 1) {
          result = formatDistanceLocale2[token].one;
        } else {
          result = formatDistanceLocale2[token].other.replace("{{count}}", count2);
        }
        if (options2.addSuffix) {
          if (options2.comparison > 0) {
            return "in " + result;
          } else {
            return result + " ago";
          }
        }
        return result;
      }
      module2.exports = exports2.default;
    })(formatDistance$1, formatDistance$1.exports);
    formatLong$2 = { exports: {} };
    buildFormatLongFn$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = buildFormatLongFn2;
      function buildFormatLongFn2(args) {
        return function(dirtyOptions) {
          var options2 = dirtyOptions || {};
          var width = options2.width ? String(options2.width) : args.defaultWidth;
          var format22 = args.formats[width] || args.formats[args.defaultWidth];
          return format22;
        };
      }
      module2.exports = exports2.default;
    })(buildFormatLongFn$1, buildFormatLongFn$1.exports);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _index = _interopRequireDefault(buildFormatLongFn$1.exports);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var dateFormats2 = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
      };
      var timeFormats2 = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      };
      var dateTimeFormats2 = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
      };
      var formatLong2 = {
        date: (0, _index.default)({
          formats: dateFormats2,
          defaultWidth: "full"
        }),
        time: (0, _index.default)({
          formats: timeFormats2,
          defaultWidth: "full"
        }),
        dateTime: (0, _index.default)({
          formats: dateTimeFormats2,
          defaultWidth: "full"
        })
      };
      var _default = formatLong2;
      exports2.default = _default;
      module2.exports = exports2.default;
    })(formatLong$2, formatLong$2.exports);
    formatRelative$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = formatRelative2;
      var formatRelativeLocale2 = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
      };
      function formatRelative2(token, _date, _baseDate, _options) {
        return formatRelativeLocale2[token];
      }
      module2.exports = exports2.default;
    })(formatRelative$1, formatRelative$1.exports);
    localize$2 = { exports: {} };
    buildLocalizeFn$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = buildLocalizeFn2;
      function buildLocalizeFn2(args) {
        return function(dirtyIndex, dirtyOptions) {
          var options2 = dirtyOptions || {};
          var context = options2.context ? String(options2.context) : "standalone";
          var valuesArray;
          if (context === "formatting" && args.formattingValues) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            var width = options2.width ? String(options2.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
          } else {
            var _defaultWidth = args.defaultWidth;
            var _width = options2.width ? String(options2.width) : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
          }
          var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
          return valuesArray[index2];
        };
      }
      module2.exports = exports2.default;
    })(buildLocalizeFn$1, buildLocalizeFn$1.exports);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _index = _interopRequireDefault(buildLocalizeFn$1.exports);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var eraValues2 = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
      };
      var quarterValues2 = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
      };
      var monthValues2 = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
      };
      var dayValues2 = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      };
      var dayPeriodValues2 = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        }
      };
      var formattingDayPeriodValues2 = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        }
      };
      function ordinalNumber2(dirtyNumber, _dirtyOptions) {
        var number3 = Number(dirtyNumber);
        var rem100 = number3 % 100;
        if (rem100 > 20 || rem100 < 10) {
          switch (rem100 % 10) {
            case 1:
              return number3 + "st";
            case 2:
              return number3 + "nd";
            case 3:
              return number3 + "rd";
          }
        }
        return number3 + "th";
      }
      var localize2 = {
        ordinalNumber: ordinalNumber2,
        era: (0, _index.default)({
          values: eraValues2,
          defaultWidth: "wide"
        }),
        quarter: (0, _index.default)({
          values: quarterValues2,
          defaultWidth: "wide",
          argumentCallback: function(quarter) {
            return Number(quarter) - 1;
          }
        }),
        month: (0, _index.default)({
          values: monthValues2,
          defaultWidth: "wide"
        }),
        day: (0, _index.default)({
          values: dayValues2,
          defaultWidth: "wide"
        }),
        dayPeriod: (0, _index.default)({
          values: dayPeriodValues2,
          defaultWidth: "wide",
          formattingValues: formattingDayPeriodValues2,
          defaultFormattingWidth: "wide"
        })
      };
      var _default = localize2;
      exports2.default = _default;
      module2.exports = exports2.default;
    })(localize$2, localize$2.exports);
    match$2 = { exports: {} };
    buildMatchPatternFn$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = buildMatchPatternFn2;
      function buildMatchPatternFn2(args) {
        return function(dirtyString, dirtyOptions) {
          var string = String(dirtyString);
          var options2 = dirtyOptions || {};
          var matchResult = string.match(args.matchPattern);
          if (!matchResult) {
            return null;
          }
          var matchedString = matchResult[0];
          var parseResult = string.match(args.parsePattern);
          if (!parseResult) {
            return null;
          }
          var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
          value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
          return {
            value: value2,
            rest: string.slice(matchedString.length)
          };
        };
      }
      module2.exports = exports2.default;
    })(buildMatchPatternFn$1, buildMatchPatternFn$1.exports);
    buildMatchFn$1 = { exports: {} };
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = buildMatchFn2;
      function buildMatchFn2(args) {
        return function(dirtyString, dirtyOptions) {
          var string = String(dirtyString);
          var options2 = dirtyOptions || {};
          var width = options2.width;
          var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
          var matchResult = string.match(matchPattern);
          if (!matchResult) {
            return null;
          }
          var matchedString = matchResult[0];
          var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
          var value2;
          if (Object.prototype.toString.call(parsePatterns) === "[object Array]") {
            value2 = findIndex2(parsePatterns, function(pattern) {
              return pattern.test(string);
            });
          } else {
            value2 = findKey2(parsePatterns, function(pattern) {
              return pattern.test(string);
            });
          }
          value2 = args.valueCallback ? args.valueCallback(value2) : value2;
          value2 = options2.valueCallback ? options2.valueCallback(value2) : value2;
          return {
            value: value2,
            rest: string.slice(matchedString.length)
          };
        };
      }
      function findKey2(object2, predicate) {
        for (var key2 in object2) {
          if (object2.hasOwnProperty(key2) && predicate(object2[key2])) {
            return key2;
          }
        }
      }
      function findIndex2(array2, predicate) {
        for (var key2 = 0; key2 < array2.length; key2++) {
          if (predicate(array2[key2])) {
            return key2;
          }
        }
      }
      module2.exports = exports2.default;
    })(buildMatchFn$1, buildMatchFn$1.exports);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _index = _interopRequireDefault(buildMatchPatternFn$1.exports);
      var _index2 = _interopRequireDefault(buildMatchFn$1.exports);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var matchOrdinalNumberPattern2 = /^(\d+)(th|st|nd|rd)?/i;
      var parseOrdinalNumberPattern2 = /\d+/i;
      var matchEraPatterns2 = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
      };
      var parseEraPatterns2 = {
        any: [/^b/i, /^(a|c)/i]
      };
      var matchQuarterPatterns2 = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
      };
      var parseQuarterPatterns2 = {
        any: [/1/i, /2/i, /3/i, /4/i]
      };
      var matchMonthPatterns2 = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
      };
      var parseMonthPatterns2 = {
        narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
        any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
      };
      var matchDayPatterns2 = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
      };
      var parseDayPatterns2 = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
      };
      var matchDayPeriodPatterns2 = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
      };
      var parseDayPeriodPatterns2 = {
        any: {
          am: /^a/i,
          pm: /^p/i,
          midnight: /^mi/i,
          noon: /^no/i,
          morning: /morning/i,
          afternoon: /afternoon/i,
          evening: /evening/i,
          night: /night/i
        }
      };
      var match2 = {
        ordinalNumber: (0, _index.default)({
          matchPattern: matchOrdinalNumberPattern2,
          parsePattern: parseOrdinalNumberPattern2,
          valueCallback: function(value2) {
            return parseInt(value2, 10);
          }
        }),
        era: (0, _index2.default)({
          matchPatterns: matchEraPatterns2,
          defaultMatchWidth: "wide",
          parsePatterns: parseEraPatterns2,
          defaultParseWidth: "any"
        }),
        quarter: (0, _index2.default)({
          matchPatterns: matchQuarterPatterns2,
          defaultMatchWidth: "wide",
          parsePatterns: parseQuarterPatterns2,
          defaultParseWidth: "any",
          valueCallback: function(index2) {
            return index2 + 1;
          }
        }),
        month: (0, _index2.default)({
          matchPatterns: matchMonthPatterns2,
          defaultMatchWidth: "wide",
          parsePatterns: parseMonthPatterns2,
          defaultParseWidth: "any"
        }),
        day: (0, _index2.default)({
          matchPatterns: matchDayPatterns2,
          defaultMatchWidth: "wide",
          parsePatterns: parseDayPatterns2,
          defaultParseWidth: "any"
        }),
        dayPeriod: (0, _index2.default)({
          matchPatterns: matchDayPeriodPatterns2,
          defaultMatchWidth: "any",
          parsePatterns: parseDayPeriodPatterns2,
          defaultParseWidth: "any"
        })
      };
      var _default = match2;
      exports2.default = _default;
      module2.exports = exports2.default;
    })(match$2, match$2.exports);
    (function(module2, exports2) {
      Object.defineProperty(exports2, "__esModule", {
        value: true
      });
      exports2.default = void 0;
      var _index = _interopRequireDefault(formatDistance$1.exports);
      var _index2 = _interopRequireDefault(formatLong$2.exports);
      var _index3 = _interopRequireDefault(formatRelative$1.exports);
      var _index4 = _interopRequireDefault(localize$2.exports);
      var _index5 = _interopRequireDefault(match$2.exports);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var locale2 = {
        code: "en-US",
        formatDistance: _index.default,
        formatLong: _index2.default,
        formatRelative: _index3.default,
        localize: _index4.default,
        match: _index5.default,
        options: {
          weekStartsOn: 0,
          firstWeekContainsDate: 1
        }
      };
      var _default = locale2;
      exports2.default = _default;
      module2.exports = exports2.default;
    })(enUS, enUS.exports);
    enUSLocaleObject = /* @__PURE__ */ getDefaultExportFromCjs(enUS.exports);
    __spreadArrays$k = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    standardTruncationOptions = {
      type: TruncationTypes.END_LINE,
      threshold: 16,
      numCharacter: 14
    };
    legend = {
      enabled: true,
      position: LegendPositions.BOTTOM,
      clickable: true,
      truncation: standardTruncationOptions,
      alignment: Alignments.LEFT,
      order: null,
      additionalItems: []
    };
    grid = {
      x: {
        enabled: true,
        numberOfTicks: 15,
        alignWithAxisTicks: false
      },
      y: {
        enabled: true,
        numberOfTicks: 5,
        alignWithAxisTicks: false
      }
    };
    ruler = {
      enabled: true
    };
    baseTooltip = {
      enabled: true,
      showTotal: true,
      truncation: standardTruncationOptions,
      groupLabel: "Group"
    };
    axes = {
      top: {
        visible: true,
        includeZero: true,
        truncation: standardTruncationOptions
      },
      bottom: {
        visible: true,
        includeZero: true,
        truncation: standardTruncationOptions
      },
      left: {
        visible: true,
        includeZero: true,
        truncation: standardTruncationOptions
      },
      right: {
        visible: true,
        includeZero: true,
        truncation: standardTruncationOptions
      }
    };
    timeScale = {
      addSpaceOnEdges: 1,
      showDayName: false,
      localeObject: enUSLocaleObject,
      timeIntervalFormats: {
        "15seconds": { primary: "MMM d, pp", secondary: "pp" },
        minute: { primary: "MMM d, p", secondary: "p" },
        "30minutes": { primary: "MMM d, p", secondary: "p" },
        hourly: { primary: "MMM d, hh a", secondary: "hh a" },
        daily: { primary: "MMM d", secondary: "d" },
        weekly: { primary: "eee, MMM d", secondary: "eee" },
        monthly: { primary: "MMM yyyy", secondary: "MMM" },
        quarterly: { primary: "QQQ ''yy", secondary: "QQQ" },
        yearly: { primary: "yyyy", secondary: "yyyy" }
      }
    };
    isFullScreenEnabled = typeof document !== "undefined" && (document["fullscreenEnabled"] || document["webkitFullscreenEnabled"] || document["mozFullScreenEnabled"] || document["msFullscreenEnabled"]);
    chart = {
      width: null,
      height: null,
      resizable: true,
      tooltip: baseTooltip,
      legend,
      style: {
        prefix: "cc"
      },
      data: {
        groupMapsTo: "group",
        loading: false,
        selectedGroups: []
      },
      color: {
        scale: null,
        pairing: {
          numberOfVariants: null,
          option: 1
        },
        gradient: {
          enabled: false
        }
      },
      toolbar: {
        enabled: true,
        numberOfIcons: 3,
        controls: __spreadArrays$k([
          {
            type: ToolbarControlTypes.SHOW_AS_DATATABLE
          }
        ], isFullScreenEnabled ? [
          {
            type: ToolbarControlTypes.MAKE_FULLSCREEN
          }
        ] : [], [
          {
            type: ToolbarControlTypes.EXPORT_CSV
          },
          {
            type: ToolbarControlTypes.EXPORT_PNG
          },
          {
            type: ToolbarControlTypes.EXPORT_JPG
          }
        ])
      }
    };
    axisChart = Tools.merge({}, chart, {
      axes,
      timeScale,
      grid,
      ruler,
      zoomBar: {
        zoomRatio: 0.4,
        minZoomRatio: 0.01,
        top: {
          enabled: false,
          type: ZoomBarTypes.GRAPH_VIEW
        }
      }
    });
    baseBarChart = Tools.merge({}, axisChart, {
      bars: {
        maxWidth: 16,
        spacingFactor: 0.25
      },
      timeScale: Tools.merge(timeScale, {
        addSpaceOnEdges: 1
      })
    });
    simpleBarChart = Tools.merge({}, baseBarChart, {});
    groupedBarChart = Tools.merge({}, baseBarChart, {});
    stackedBarChart = Tools.merge({}, baseBarChart, {
      bars: Tools.merge({}, baseBarChart.bars, {
        dividerSize: 1.5
      })
    });
    boxplotChart = Tools.merge({}, baseBarChart, {});
    scatterChart = Tools.merge({}, axisChart, {
      points: {
        radius: 4,
        fillOpacity: 0.3,
        filled: true,
        enabled: true
      }
    });
    lollipopChart = scatterChart;
    lineChart = Tools.merge({}, scatterChart, {
      points: {
        radius: 3,
        filled: false,
        enabled: true
      }
    });
    areaChart = Tools.merge({}, lineChart, {
      timeScale: Tools.merge(timeScale, {
        addSpaceOnEdges: 0
      })
    });
    stackedAreaChart = areaChart;
    bubbleChart = Tools.merge({}, axisChart, {
      bubble: {
        radiusMapsTo: "radius",
        radiusLabel: "Radius",
        radiusRange: function(chartSize, data) {
          var smallerChartDimension = Math.min(chartSize.width, chartSize.height);
          return [
            smallerChartDimension * 3 / 400,
            smallerChartDimension * 25 / 400
          ];
        },
        fillOpacity: 0.2,
        enabled: true
      },
      points: {
        filled: true
      },
      legend: {
        additionalItems: [
          {
            type: LegendItemType.RADIUS,
            name: "Radius"
          }
        ]
      }
    });
    bulletChart = Tools.merge({}, axisChart, {
      bullet: {
        performanceAreaTitles: ["Poor", "Satisfactory", "Great"]
      },
      grid: {
        x: {
          enabled: false
        },
        y: {
          enabled: false
        }
      },
      legend: {
        additionalItems: [
          {
            type: LegendItemType.AREA,
            name: "Poor area"
          },
          {
            type: LegendItemType.AREA,
            name: "Satisfactory area"
          },
          {
            type: LegendItemType.AREA,
            name: "Great area"
          },
          {
            type: LegendItemType.QUARTILE,
            name: "Quartiles"
          }
        ]
      }
    });
    histogramChart = Tools.merge({}, baseBarChart, {
      bars: {
        dividerSize: 1.5
      },
      timeScale: Tools.merge(timeScale, {
        addSpaceOnEdges: 0
      })
    });
    wordCloudChart = Tools.merge({}, chart, {
      tooltip: Tools.merge({}, baseTooltip, {
        wordLabel: "Word",
        valueLabel: "Value"
      }),
      wordCloud: {
        fontSizeMapsTo: "value",
        fontSizeRange: function(chartSize, data) {
          var smallerChartDimension = Math.min(chartSize.width, chartSize.height);
          return [
            smallerChartDimension * 20 / 400,
            smallerChartDimension * 75 / 400
          ];
        },
        wordMapsTo: "word"
      }
    });
    pieChart = Tools.merge({}, chart, {
      pie: {
        labels: {
          formatter: null,
          enabled: true
        },
        alignment: Alignments.LEFT,
        sortFunction: null,
        valueMapsTo: "value"
      }
    });
    gaugeChart = Tools.merge({}, chart, {
      legend: {
        enabled: false
      },
      gauge: {
        type: GaugeTypes.SEMI,
        arcWidth: 16,
        deltaArrow: {
          size: function(radius) {
            return radius / 8;
          },
          enabled: true
        },
        showPercentageSymbol: true,
        status: null,
        numberSpacing: 10,
        deltaFontSize: function(radius) {
          return radius / 8;
        },
        valueFontSize: function(radius) {
          return radius / 2.5;
        },
        numberFormatter: function(number3) {
          return number3.toFixed(2) % 1 !== 0 ? number3.toFixed(2).toLocaleString() : number3.toFixed().toLocaleString();
        },
        alignment: Alignments.LEFT
      }
    });
    donutChart = Tools.merge({}, pieChart, {
      donut: {
        center: {
          numberFontSize: function(radius) {
            return Math.min(radius / 100 * 24, 24) + "px";
          },
          titleFontSize: function(radius) {
            return Math.min(radius / 100 * 15, 15) + "px";
          },
          titleYPosition: function(radius) {
            return Math.min(radius / 80 * 20, 20);
          },
          numberFormatter: function(number3) {
            return Math.floor(number3).toLocaleString();
          }
        },
        alignment: Alignments.LEFT
      }
    });
    meterChart = Tools.merge({}, chart, {
      legend: {
        enabled: false,
        clickable: false
      },
      meter: {
        showLabels: true,
        proportional: null,
        statusBar: {
          percentageIndicator: {
            enabled: true
          }
        }
      }
    });
    proportionalMeterChart = Tools.merge({}, meterChart, {
      legend: {
        enabled: true
      }
    });
    radarChart = Tools.merge({}, chart, {
      radar: {
        axes: {
          angle: "key",
          value: "value"
        },
        alignment: Alignments.LEFT
      },
      tooltip: {
        gridline: {
          enabled: true
        },
        valueFormatter: function(value2) {
          return value2 !== null && value2 !== void 0 ? value2 : "N/A";
        }
      }
    });
    comboChart = Tools.merge({}, baseBarChart, {
      comboChartTypes: []
    });
    treeChart = Tools.merge({
      tree: {
        type: TreeTypes.TREE
      }
    }, chart, {});
    treemapChart = Tools.merge({}, chart, {
      data: Tools.merge(chart.data, {
        groupMapsTo: "name"
      })
    });
    circlePackChart = Tools.merge({}, chart, circlePack, {
      data: Tools.merge(chart.data, {
        groupMapsTo: "name"
      })
    });
    alluvialChart = Tools.merge({}, chart, {
      alluvial: {
        data: Tools.merge(chart.data, {
          groupMapsTo: "source"
        }),
        nodePadding: 24,
        monochrome: false,
        nodes: []
      }
    });
    heatmapChart = Tools.merge({}, chart, {
      axes,
      heatmap: {
        divider: {
          state: DividerStatus.AUTO
        },
        colorLegend: {
          type: "linear"
        }
      }
    });
    options = {
      chart,
      axisChart,
      simpleBarChart,
      groupedBarChart,
      stackedBarChart,
      boxplotChart,
      bubbleChart,
      bulletChart,
      histogramChart,
      lineChart,
      areaChart,
      stackedAreaChart,
      scatterChart,
      lollipopChart,
      pieChart,
      donutChart,
      meterChart,
      proportionalMeterChart,
      radarChart,
      gaugeChart,
      comboChart,
      treeChart,
      treemapChart,
      circlePackChart,
      wordCloudChart,
      alluvialChart,
      heatmapChart
    };
    Configuration = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      grid,
      ruler,
      baseTooltip,
      timeScale,
      options,
      area: area$1,
      axis: axis$1,
      canvasZoomSettings,
      circlePack,
      color: color$1,
      boxplot,
      histogram,
      legend: legend$1,
      lines,
      meter,
      pie: pie$1,
      radar,
      alluvial,
      heatmap,
      spacers,
      tooltips,
      transitions,
      toolbar,
      zoomBar,
      defaultLegendAdditionalItems
    }, Symbol.toStringTag, { value: "Module" }));
    ascendingBisect = bisector(ascending);
    bisectRight = ascendingBisect.right;
    bisector(number$3).center;
    bisect = bisectRight;
    InternMap = class extends Map {
      constructor(entries, key2 = keyof) {
        super();
        Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key2 } });
        if (entries != null)
          for (const [key22, value2] of entries)
            this.set(key22, value2);
      }
      get(key2) {
        return super.get(intern_get(this, key2));
      }
      has(key2) {
        return super.has(intern_get(this, key2));
      }
      set(key2, value2) {
        return super.set(intern_set(this, key2), value2);
      }
      delete(key2) {
        return super.delete(intern_delete(this, key2));
      }
    };
    array$2 = Array.prototype;
    slice$2 = array$2.slice;
    e10 = Math.sqrt(50);
    e5 = Math.sqrt(10);
    e2 = Math.sqrt(2);
    implicit = Symbol("implicit");
    darker = 0.7;
    brighter = 1 / darker;
    reI = "\\s*([+-]?\\d+)\\s*";
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
    reHex = /^#([0-9a-f]{3,8})$/;
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    named = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
    define(Color, color, {
      copy: function(channels) {
        return Object.assign(new this.constructor(), this, channels);
      },
      displayable: function() {
        return this.rgb().displayable();
      },
      hex: color_formatHex,
      formatHex: color_formatHex,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });
    define(Rgb, rgb, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb: function() {
        return this;
      },
      displayable: function() {
        return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex,
      formatHex: rgb_formatHex,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));
    define(Hsl, hsl, extend(Color, {
      brighter: function(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker: function(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb: function() {
        var h2 = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s3, m1 = 2 * l - m2;
        return new Rgb(hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2), hsl2rgb(h2, m1, m2), hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2), this.opacity);
      },
      displayable: function() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl: function() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
      }
    }));
    constant$5 = (x22) => () => x22;
    interpolateRgb = function rgbGamma(y2) {
      var color2 = gamma(y2);
      function rgb$1(start2, end) {
        var r2 = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
        return function(t2) {
          start2.r = r2(t2);
          start2.g = g(t2);
          start2.b = b(t2);
          start2.opacity = opacity(t2);
          return start2 + "";
        };
      }
      rgb$1.gamma = rgbGamma;
      return rgb$1;
    }(1);
    reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
    reB = new RegExp(reA.source, "g");
    degrees = 180 / Math.PI;
    identity$4 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };
    interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
    unit = [0, 1];
    re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    formatSpecifier.prototype = FormatSpecifier.prototype;
    FormatSpecifier.prototype.toString = function() {
      return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    formatTypes = {
      "%": (x22, p) => (x22 * 100).toFixed(p),
      "b": (x22) => Math.round(x22).toString(2),
      "c": (x22) => x22 + "",
      "d": formatDecimal,
      "e": (x22, p) => x22.toExponential(p),
      "f": (x22, p) => x22.toFixed(p),
      "g": (x22, p) => x22.toPrecision(p),
      "o": (x22) => Math.round(x22).toString(8),
      "p": (x22, p) => formatRounded(x22 * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x22) => Math.round(x22).toString(16).toUpperCase(),
      "x": (x22) => Math.round(x22).toString(16)
    };
    map = Array.prototype.map;
    prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    defaultLocale$2({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });
    t0 = new Date();
    t1 = new Date();
    millisecond = newInterval(function() {
    }, function(date2, step) {
      date2.setTime(+date2 + step);
    }, function(start2, end) {
      return end - start2;
    });
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0))
        return null;
      if (!(k > 1))
        return millisecond;
      return newInterval(function(date2) {
        date2.setTime(Math.floor(date2 / k) * k);
      }, function(date2, step) {
        date2.setTime(+date2 + step * k);
      }, function(start2, end) {
        return (end - start2) / k;
      });
    };
    millisecond$1 = millisecond;
    durationSecond = 1e3;
    durationMinute = durationSecond * 60;
    durationHour = durationMinute * 60;
    durationDay = durationHour * 24;
    durationWeek = durationDay * 7;
    durationMonth = durationDay * 30;
    durationYear = durationDay * 365;
    second = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds());
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationSecond);
    }, function(start2, end) {
      return (end - start2) / durationSecond;
    }, function(date2) {
      return date2.getUTCSeconds();
    });
    utcSecond = second;
    minute = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationMinute);
    }, function(start2, end) {
      return (end - start2) / durationMinute;
    }, function(date2) {
      return date2.getMinutes();
    });
    timeMinute = minute;
    hour = newInterval(function(date2) {
      date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationHour);
    }, function(start2, end) {
      return (end - start2) / durationHour;
    }, function(date2) {
      return date2.getHours();
    });
    timeHour = hour;
    day = newInterval((date2) => date2.setHours(0, 0, 0, 0), (date2, step) => date2.setDate(date2.getDate() + step), (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay, (date2) => date2.getDate() - 1);
    timeDay = day;
    sunday = weekday(0);
    monday = weekday(1);
    weekday(2);
    weekday(3);
    thursday = weekday(4);
    weekday(5);
    weekday(6);
    month = newInterval(function(date2) {
      date2.setDate(1);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setMonth(date2.getMonth() + step);
    }, function(start2, end) {
      return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
    }, function(date2) {
      return date2.getMonth();
    });
    timeMonth = month;
    year = newInterval(function(date2) {
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setFullYear(date2.getFullYear() + step);
    }, function(start2, end) {
      return end.getFullYear() - start2.getFullYear();
    }, function(date2) {
      return date2.getFullYear();
    });
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
        date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
        date2.setMonth(0, 1);
        date2.setHours(0, 0, 0, 0);
      }, function(date2, step) {
        date2.setFullYear(date2.getFullYear() + step * k);
      });
    };
    timeYear = year;
    utcMinute = newInterval(function(date2) {
      date2.setUTCSeconds(0, 0);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationMinute);
    }, function(start2, end) {
      return (end - start2) / durationMinute;
    }, function(date2) {
      return date2.getUTCMinutes();
    });
    utcMinute$1 = utcMinute;
    utcHour = newInterval(function(date2) {
      date2.setUTCMinutes(0, 0, 0);
    }, function(date2, step) {
      date2.setTime(+date2 + step * durationHour);
    }, function(start2, end) {
      return (end - start2) / durationHour;
    }, function(date2) {
      return date2.getUTCHours();
    });
    utcHour$1 = utcHour;
    utcDay = newInterval(function(date2) {
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCDate(date2.getUTCDate() + step);
    }, function(start2, end) {
      return (end - start2) / durationDay;
    }, function(date2) {
      return date2.getUTCDate() - 1;
    });
    utcDay$1 = utcDay;
    utcSunday = utcWeekday(0);
    utcMonday = utcWeekday(1);
    utcWeekday(2);
    utcWeekday(3);
    utcThursday = utcWeekday(4);
    utcWeekday(5);
    utcWeekday(6);
    utcMonth = newInterval(function(date2) {
      date2.setUTCDate(1);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCMonth(date2.getUTCMonth() + step);
    }, function(start2, end) {
      return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
    }, function(date2) {
      return date2.getUTCMonth();
    });
    utcMonth$1 = utcMonth;
    utcYear = newInterval(function(date2) {
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCFullYear(date2.getUTCFullYear() + step);
    }, function(start2, end) {
      return end.getUTCFullYear() - start2.getUTCFullYear();
    }, function(date2) {
      return date2.getUTCFullYear();
    });
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date2) {
        date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
        date2.setUTCMonth(0, 1);
        date2.setUTCHours(0, 0, 0, 0);
      }, function(date2, step) {
        date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
      });
    };
    utcYear$1 = utcYear;
    ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
    [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);
    pads = { "-": "", "_": " ", "0": "0" };
    numberRe = /^\s*\d+/;
    percentRe = /^%/;
    requoteRe = /[\\^$*+?|[\]().{}]/g;
    defaultLocale$1({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    pi$2 = Math.PI;
    tau$2 = 2 * pi$2;
    epsilon$3 = 1e-6;
    tauEpsilon$1 = tau$2 - epsilon$3;
    Path$1.prototype = path$1.prototype = {
      constructor: Path$1,
      moveTo: function(x22, y2) {
        this._ += "M" + (this._x0 = this._x1 = +x22) + "," + (this._y0 = this._y1 = +y2);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x22, y2) {
        this._ += "L" + (this._x1 = +x22) + "," + (this._y1 = +y2);
      },
      quadraticCurveTo: function(x1, y1, x22, y2) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x22) + "," + (this._y1 = +y2);
      },
      bezierCurveTo: function(x1, y1, x22, y2, x3, y3) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x22 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
      },
      arcTo: function(x1, y1, x22, y2, r2) {
        x1 = +x1, y1 = +y1, x22 = +x22, y2 = +y2, r2 = +r2;
        var x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        } else if (!(l01_2 > epsilon$3))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r2) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } else {
          var x20 = x22 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon$3) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x22, y2, r2, a0, a1, ccw) {
        x22 = +x22, y2 = +y2, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x22 + dx, y0 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        } else if (Math.abs(this._x1 - x0) > epsilon$3 || Math.abs(this._y1 - y0) > epsilon$3) {
          this._ += "L" + x0 + "," + y0;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau$2 + tau$2;
        if (da > tauEpsilon$1) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (x22 - dx) + "," + (y2 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        } else if (da > epsilon$3) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi$2) + "," + cw2 + "," + (this._x1 = x22 + r2 * Math.cos(a1)) + "," + (this._y1 = y2 + r2 * Math.sin(a1));
        }
      },
      rect: function(x22, y2, w, h2) {
        this._ += "M" + (this._x0 = this._x1 = +x22) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h2 + "h" + -w + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    abs$1 = Math.abs;
    atan2 = Math.atan2;
    cos = Math.cos;
    max$2 = Math.max;
    min$2 = Math.min;
    sin = Math.sin;
    sqrt = Math.sqrt;
    epsilon$2 = 1e-12;
    pi$1 = Math.PI;
    halfPi = pi$1 / 2;
    tau$1 = 2 * pi$1;
    slice$1 = Array.prototype.slice;
    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(x22, y2);
            break;
        }
      }
    };
    curveRadialLinear = curveRadial(curveLinear);
    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r2) {
        this._curve.point(r2 * Math.sin(a), r2 * -Math.cos(a));
      }
    };
    Bump = class {
      constructor(context, x22) {
        this._context = context;
        this._x = x22;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line)
              this._context.lineTo(x22, y2);
            else
              this._context.moveTo(x22, y2);
            break;
          }
          case 1:
            this._point = 2;
          default: {
            if (this._x)
              this._context.bezierCurveTo(this._x0 = (this._x0 + x22) / 2, this._y0, this._x0, y2, x22, y2);
            else
              this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x22, this._y0, x22, y2);
            break;
          }
        }
        this._x0 = x22, this._y0 = y2;
      }
    };
    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3:
            point$3(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
          default:
            point$3(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x22;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    BasisClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x2 = x22, this._y2 = y2;
            break;
          case 1:
            this._point = 2;
            this._x3 = x22, this._y3 = y2;
            break;
          case 2:
            this._point = 3;
            this._x4 = x22, this._y4 = y2;
            this._context.moveTo((this._x0 + 4 * this._x1 + x22) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
            break;
          default:
            point$3(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x22;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var x0 = (this._x0 + 4 * this._x1 + x22) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
            this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
            break;
          case 3:
            this._point = 4;
          default:
            point$3(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = x22;
        this._y0 = this._y1, this._y1 = y2;
      }
    };
    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x22 = this._x, y2 = this._y, j = x22.length - 1;
        if (j > 0) {
          var x0 = x22[0], y0 = y2[0], dx = x22[j] - x0, dy = y2[j] - y0, i2 = -1, t2;
          while (++i2 <= j) {
            t2 = i2 / j;
            this._basis.point(this._beta * x22[i2] + (1 - this._beta) * (x0 + t2 * dx), this._beta * y2[i2] + (1 - this._beta) * (y0 + t2 * dy));
          }
        }
        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x22, y2) {
        this._x.push(+x22);
        this._y.push(+y2);
      }
    };
    curveBundle = function custom(beta) {
      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }
      bundle.beta = function(beta2) {
        return custom(+beta2);
      };
      return bundle;
    }(0.85);
    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            point$2(this, this._x1, this._y1);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
            this._x1 = x22, this._y1 = y2;
            break;
          case 2:
            this._point = 3;
          default:
            point$2(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCardinal = function custom2(tension) {
      function cardinal(context) {
        return new Cardinal(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom2(+tension2);
      };
      return cardinal;
    }(0);
    CardinalClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x22, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x22, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x22, this._y5 = y2;
            break;
          default:
            point$2(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCardinalClosed = function custom3(tension) {
      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom3(+tension2);
      };
      return cardinal;
    }(0);
    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point$2(this, x22, y2);
            break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCardinalOpen = function custom4(tension) {
      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }
      cardinal.tension = function(tension2) {
        return custom4(+tension2);
      };
      return cardinal;
    }(0);
    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x2, this._y2);
            break;
          case 3:
            this.point(this._x2, this._y2);
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x22, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
          default:
            point$1(this, x22, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCatmullRom = function custom5(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom5(+alpha2);
      };
      return catmullRom;
    }(0.5);
    CatmullRomClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x22, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            this._x3 = x22, this._y3 = y2;
            break;
          case 1:
            this._point = 2;
            this._context.moveTo(this._x4 = x22, this._y4 = y2);
            break;
          case 2:
            this._point = 3;
            this._x5 = x22, this._y5 = y2;
            break;
          default:
            point$1(this, x22, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCatmullRomClosed = function custom6(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom6(+alpha2);
      };
      return catmullRom;
    }(0.5);
    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
      },
      lineEnd: function() {
        if (this._line || this._line !== 0 && this._point === 3)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        if (this._point) {
          var x23 = this._x2 - x22, y23 = this._y2 - y2;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }
        switch (this._point) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
            break;
          case 3:
            this._point = 4;
          default:
            point$1(this, x22, y2);
            break;
        }
        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x22;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
      }
    };
    curveCatmullRomOpen = function custom7(alpha) {
      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }
      catmullRom.alpha = function(alpha2) {
        return custom7(+alpha2);
      };
      return catmullRom;
    }(0.5);
    LinearClosed.prototype = {
      areaStart: noop$2,
      areaEnd: noop$2,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point)
          this._context.closePath();
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        if (this._point)
          this._context.lineTo(x22, y2);
        else
          this._point = 1, this._context.moveTo(x22, y2);
      }
    };
    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            point(this, this._t0, slope2(this, this._t0));
            break;
        }
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        var t12 = NaN;
        x22 = +x22, y2 = +y2;
        if (x22 === this._x1 && y2 === this._y1)
          return;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            point(this, slope2(this, t12 = slope3(this, x22, y2)), t12);
            break;
          default:
            point(this, this._t0, t12 = slope3(this, x22, y2));
            break;
        }
        this._x0 = this._x1, this._x1 = x22;
        this._y0 = this._y1, this._y1 = y2;
        this._t0 = t12;
      }
    };
    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x22, y2) {
      MonotoneX.prototype.point.call(this, y2, x22);
    };
    ReflectContext.prototype = {
      moveTo: function(x22, y2) {
        this._context.moveTo(y2, x22);
      },
      closePath: function() {
        this._context.closePath();
      },
      lineTo: function(x22, y2) {
        this._context.lineTo(y2, x22);
      },
      bezierCurveTo: function(x1, y1, x22, y2, x3, y3) {
        this._context.bezierCurveTo(y1, x1, y2, x22, y3, x3);
      }
    };
    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x22 = this._x, y2 = this._y, n = x22.length;
        if (n) {
          this._line ? this._context.lineTo(x22[0], y2[0]) : this._context.moveTo(x22[0], y2[0]);
          if (n === 2) {
            this._context.lineTo(x22[1], y2[1]);
          } else {
            var px = controlPoints(x22), py = controlPoints(y2);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x22[i1], y2[i1]);
            }
          }
        }
        if (this._line || this._line !== 0 && n === 1)
          this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x22, y2) {
        this._x.push(+x22);
        this._y.push(+y2);
      }
    };
    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2)
          this._context.lineTo(this._x, this._y);
        if (this._line || this._line !== 0 && this._point === 1)
          this._context.closePath();
        if (this._line >= 0)
          this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x22, y2) {
        x22 = +x22, y2 = +y2;
        switch (this._point) {
          case 0:
            this._point = 1;
            this._line ? this._context.lineTo(x22, y2) : this._context.moveTo(x22, y2);
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y2);
              this._context.lineTo(x22, y2);
            } else {
              var x1 = this._x * (1 - this._t) + x22 * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y2);
            }
            break;
          }
        }
        this._x = x22, this._y = y2;
      }
    };
    __assign$3 = globalThis && globalThis.__assign || function() {
      __assign$3 = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign$3.apply(this, arguments);
    };
    ChartModel = function() {
      function ChartModel2(services) {
        this.state = {
          options: {}
        };
        this.colorScale = {};
        this.colorClassNames = {};
        this.services = services;
      }
      ChartModel2.prototype.getAllDataFromDomain = function(groups) {
        if (!this.getData()) {
          return null;
        }
        var options2 = this.getOptions();
        var allData = this.getData();
        var dataGroups = this.getDataGroups();
        var groupMapsTo = Tools.getProperty(options2, "data").groupMapsTo;
        var axesOptions = Tools.getProperty(options2, "axes");
        if (groups) {
          allData = allData.filter(function(item) {
            return groups.includes(item[groupMapsTo]);
          });
        }
        if (axesOptions) {
          Object.keys(axesOptions).forEach(function(axis2) {
            var mapsTo = axesOptions[axis2].mapsTo;
            var scaleType = axesOptions[axis2].scaleType;
            if (scaleType === ScaleTypes.LINEAR || scaleType === ScaleTypes.LOG) {
              allData = allData.map(function(datum2) {
                var _a32;
                return __assign$3(__assign$3({}, datum2), (_a32 = {}, _a32[mapsTo] = datum2[mapsTo] === null ? datum2[mapsTo] : Number(datum2[mapsTo]), _a32));
              });
            }
            if (mapsTo && axesOptions[axis2].domain) {
              if (scaleType === ScaleTypes.LABELS) {
                allData = allData.filter(function(datum2) {
                  return axesOptions[axis2].domain.includes(datum2[mapsTo]);
                });
              } else {
                var _a22 = axesOptions[axis2].domain, start_1 = _a22[0], end_1 = _a22[1];
                allData = allData.filter(function(datum2) {
                  return !(mapsTo in datum2) || datum2[mapsTo] >= start_1 && datum2[mapsTo] <= end_1;
                });
              }
            }
          });
        }
        return allData.filter(function(datum2) {
          return dataGroups.find(function(group) {
            return group.name === datum2[groupMapsTo];
          });
        });
      };
      ChartModel2.prototype.getDisplayData = function(groups) {
        if (!this.get("data")) {
          return null;
        }
        var ACTIVE = legend$1.items.status.ACTIVE;
        var dataGroups = this.getDataGroups(groups);
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        var allDataFromDomain = this.getAllDataFromDomain(groups);
        return allDataFromDomain.filter(function(datum2) {
          return dataGroups.find(function(dataGroup) {
            return dataGroup.name === datum2[groupMapsTo] && dataGroup.status === ACTIVE;
          });
        });
      };
      ChartModel2.prototype.getData = function() {
        return this.get("data");
      };
      ChartModel2.prototype.isDataEmpty = function() {
        return !this.getData().length;
      };
      ChartModel2.prototype.setData = function(newData) {
        var sanitizedData = this.sanitize(Tools.clone(newData));
        var dataGroups = this.generateDataGroups(sanitizedData);
        this.set({
          data: sanitizedData,
          dataGroups
        });
        return sanitizedData;
      };
      ChartModel2.prototype.getDataGroups = function(groups) {
        var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
        if (isDataLoading) {
          return [];
        }
        if (groups) {
          return this.get("dataGroups").filter(function(dataGroup) {
            return groups.includes(dataGroup.name);
          });
        }
        return this.get("dataGroups");
      };
      ChartModel2.prototype.getActiveDataGroups = function(groups) {
        var ACTIVE = legend$1.items.status.ACTIVE;
        return this.getDataGroups(groups).filter(function(dataGroup) {
          return dataGroup.status === ACTIVE;
        });
      };
      ChartModel2.prototype.getDataGroupNames = function(groups) {
        var dataGroups = this.getDataGroups(groups);
        return dataGroups.map(function(dataGroup) {
          return dataGroup.name;
        });
      };
      ChartModel2.prototype.getActiveDataGroupNames = function(groups) {
        var activeDataGroups = this.getActiveDataGroups(groups);
        return activeDataGroups.map(function(dataGroup) {
          return dataGroup.name;
        });
      };
      ChartModel2.prototype.aggregateBinDataByGroup = function(bin2) {
        return Tools.groupBy(bin2, "group");
      };
      ChartModel2.prototype.getBinConfigurations = function() {
        var _this = this;
        var data = this.getDisplayData();
        var options2 = this.getOptions();
        var mainXPos = this.services.cartesianScales.getMainXAxisPosition();
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
        var axisOptions = options2.axes[mainXPos];
        var groupMapsTo = options2.data.groupMapsTo;
        var _a22 = axisOptions.bins, axisBins = _a22 === void 0 ? histogram.defaultBins : _a22;
        var areBinsDefined = Array.isArray(axisBins);
        var bins = bin().value(function(d) {
          return d[domainIdentifier];
        }).thresholds(axisBins)(data);
        if (!areBinsDefined) {
          var binsWidth = bins[0].x1 - bins[0].x0;
          bins[bins.length - 1].x1 = +bins[bins.length - 1].x0 + binsWidth;
        } else {
          bins[bins.length - 1].x1 = axisBins[axisBins.length - 1];
        }
        var binsDomain = areBinsDefined ? [axisBins[0], axisBins[axisBins.length - 1]] : [bins[0].x0, bins[bins.length - 1].x1];
        var groupsKeys = Array.from(new Set(data.map(function(d) {
          return d[groupMapsTo];
        })));
        var histogramData = [];
        bins.forEach(function(bin2) {
          var key2 = bin2.x0 + "-" + bin2.x1;
          var aggregateDataByGroup = _this.aggregateBinDataByGroup(bin2);
          groupsKeys.forEach(function(group) {
            histogramData.push({
              group,
              key: key2,
              value: aggregateDataByGroup[group] || 0,
              bin: bin2.x0
            });
          });
        });
        return {
          bins,
          binsDomain
        };
      };
      ChartModel2.prototype.getBinnedStackedData = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var dataGroupNames = this.getActiveDataGroupNames();
        var bins = this.getBinConfigurations().bins;
        var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({
          bins
        });
        return stack().keys(dataGroupNames)(dataValuesGroupedByKeys).map(function(series, i2) {
          return Object.keys(series).filter(function(key2) {
            return !isNaN(key2);
          }).map(function(key2) {
            var element = series[key2];
            element[groupMapsTo] = dataGroupNames[i2];
            return element;
          });
        });
      };
      ChartModel2.prototype.getGroupedData = function(groups) {
        var displayData = this.getDisplayData(groups);
        var groupedData = {};
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        displayData.map(function(datum2) {
          var group = datum2[groupMapsTo];
          if (groupedData[group] !== null && groupedData[group] !== void 0) {
            groupedData[group].push(datum2);
          } else {
            groupedData[group] = [datum2];
          }
        });
        return Object.keys(groupedData).map(function(groupName) {
          return {
            name: groupName,
            data: groupedData[groupName]
          };
        });
      };
      ChartModel2.prototype.getStackKeys = function(_a22) {
        var _this = this;
        var _b = _a22 === void 0 ? { bins: null, groups: null } : _a22, _c = _b.bins, bins = _c === void 0 ? null : _c, _d2 = _b.groups, groups = _d2 === void 0 ? null : _d2;
        var options2 = this.getOptions();
        var displayData = this.getDisplayData(groups);
        var stackKeys;
        if (bins) {
          stackKeys = bins.map(function(bin2) {
            return bin2.x0 + "-" + bin2.x1;
          });
        } else {
          stackKeys = Tools.removeArrayDuplicates(displayData.map(function(datum2) {
            var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
            return datum2[domainIdentifier] && typeof datum2[domainIdentifier].toString === "function" ? datum2[domainIdentifier].toString() : datum2[domainIdentifier];
          }));
        }
        var axisPosition = this.services.cartesianScales.domainAxisPosition;
        var scaleType = options2.axes[axisPosition].scaleType;
        if (scaleType === ScaleTypes.TIME) {
          stackKeys.sort(function(a, b) {
            var dateA = new Date(a);
            var dateB = new Date(b);
            return dateA - dateB;
          });
        } else if (scaleType === ScaleTypes.LOG || scaleType === ScaleTypes.LINEAR) {
          stackKeys.sort(function(a, b) {
            return a - b;
          });
        }
        return stackKeys;
      };
      ChartModel2.prototype.getDataValuesGroupedByKeys = function(_a22) {
        var _this = this;
        var _b = _a22.bins, bins = _b === void 0 ? null : _b, _c = _a22.groups, groups = _c === void 0 ? null : _c;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var displayData = this.getDisplayData(groups);
        var dataGroupNames = this.getDataGroupNames();
        var stackKeys = this.getStackKeys({ bins, groups });
        if (bins) {
          return stackKeys.map(function(key2) {
            var _a32 = key2.split("-"), binStart = _a32[0], binEnd = _a32[1];
            var correspondingValues = { x0: binStart, x1: binEnd };
            var correspondingBin = bins.find(function(bin2) {
              return bin2.x0.toString() === binStart.toString();
            });
            dataGroupNames.forEach(function(dataGroupName) {
              correspondingValues[dataGroupName] = correspondingBin.filter(function(binItem) {
                return binItem[groupMapsTo] === dataGroupName;
              }).length;
            });
            return correspondingValues;
          });
        }
        return stackKeys.map(function(key2) {
          var correspondingValues = { sharedStackKey: key2 };
          dataGroupNames.forEach(function(dataGroupName) {
            var correspondingDatum = displayData.find(function(datum2) {
              var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
              return datum2[groupMapsTo] === dataGroupName && datum2.hasOwnProperty(domainIdentifier) && datum2[domainIdentifier].toString() === key2;
            });
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(correspondingValues);
            correspondingValues[dataGroupName] = correspondingDatum ? correspondingDatum[rangeIdentifier] : null;
          });
          return correspondingValues;
        });
      };
      ChartModel2.prototype.getStackedData = function(_a22) {
        var _b = _a22.percentage, percentage = _b === void 0 ? false : _b, _c = _a22.groups, groups = _c === void 0 ? null : _c, _d2 = _a22.divergent, divergent = _d2 === void 0 ? false : _d2;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var dataGroupNames = this.getActiveDataGroupNames(groups);
        var dataValuesGroupedByKeys = this.getDataValuesGroupedByKeys({
          groups
        });
        if (percentage) {
          var maxByKey_1 = Tools.fromPairs(dataValuesGroupedByKeys.map(function(d) {
            return [d.sharedStackKey, 0];
          }));
          dataValuesGroupedByKeys.forEach(function(d) {
            dataGroupNames.forEach(function(name) {
              maxByKey_1[d.sharedStackKey] += d[name];
            });
          });
          dataValuesGroupedByKeys.forEach(function(d) {
            dataGroupNames.forEach(function(name) {
              if (maxByKey_1[d.sharedStackKey]) {
                d[name] = d[name] / maxByKey_1[d.sharedStackKey] * 100;
              } else {
                d[name] = 0;
              }
            });
          });
        }
        var stackToUse = divergent ? stack().offset(stackOffsetDiverging) : stack();
        return stackToUse.keys(dataGroupNames)(dataValuesGroupedByKeys).map(function(series, i2) {
          return Object.keys(series).filter(function(key2) {
            return !isNaN(key2);
          }).map(function(key2) {
            var element = series[key2];
            element[groupMapsTo] = dataGroupNames[i2];
            return element;
          });
        });
      };
      ChartModel2.prototype.getOptions = function() {
        return this.state.options;
      };
      ChartModel2.prototype.set = function(newState, configs) {
        this.state = Object.assign({}, this.state, newState);
        var newConfig = Object.assign({ skipUpdate: false, animate: true }, configs);
        if (!newConfig.skipUpdate) {
          this.update(newConfig.animate);
        }
      };
      ChartModel2.prototype.get = function(property2) {
        if (property2) {
          return this.state[property2];
        } else {
          return this.state;
        }
      };
      ChartModel2.prototype.setOptions = function(newOptions) {
        var options2 = this.getOptions();
        Tools.updateLegendAdditionalItems(options2, newOptions);
        this.set({
          options: Tools.merge(options2, newOptions)
        });
      };
      ChartModel2.prototype.update = function(animate) {
        if (animate === void 0) {
          animate = true;
        }
        if (!this.getDisplayData()) {
          return;
        }
        this.updateAllDataGroups();
        this.setCustomColorScale();
        this.setColorClassNames();
        this.services.events.dispatchEvent(Events$1.Model.UPDATE, { animate });
      };
      ChartModel2.prototype.toggleDataLabel = function(changedLabel) {
        var _a22 = legend$1.items.status, ACTIVE = _a22.ACTIVE, DISABLED = _a22.DISABLED;
        var dataGroups = this.getDataGroups();
        var hasDeactivatedItems = dataGroups.some(function(group) {
          return group.status === DISABLED;
        });
        var activeItems = dataGroups.filter(function(group) {
          return group.status === ACTIVE;
        });
        if (hasDeactivatedItems) {
          if (activeItems.length === 1 && activeItems[0].name === changedLabel) {
            dataGroups.forEach(function(group, i2) {
              dataGroups[i2].status = ACTIVE;
            });
          } else {
            var indexToChange = dataGroups.findIndex(function(group) {
              return group.name === changedLabel;
            });
            dataGroups[indexToChange].status = dataGroups[indexToChange].status === DISABLED ? ACTIVE : DISABLED;
          }
        } else {
          dataGroups.forEach(function(group, i2) {
            dataGroups[i2].status = group.name === changedLabel ? ACTIVE : DISABLED;
          });
        }
        var updatedActiveItems = dataGroups.filter(function(group) {
          return group.status === ACTIVE;
        });
        var options2 = this.getOptions();
        var hasUpdatedDeactivatedItems = dataGroups.some(function(group) {
          return group.status === DISABLED;
        });
        if (hasUpdatedDeactivatedItems) {
          options2.data.selectedGroups = updatedActiveItems.map(function(activeItem) {
            return activeItem.name;
          });
        } else {
          options2.data.selectedGroups = [];
        }
        this.services.events.dispatchEvent(Events$1.Legend.ITEMS_UPDATE, {
          dataGroups
        });
        this.set({
          dataGroups
        });
      };
      ChartModel2.prototype.getIsFilled = function(group, key2, data, defaultFilled) {
        var options2 = this.getOptions();
        if (options2.getIsFilled) {
          return options2.getIsFilled(group, key2, data, defaultFilled);
        } else {
          return defaultFilled;
        }
      };
      ChartModel2.prototype.getFillColor = function(group, key2, data) {
        var options2 = this.getOptions();
        var defaultFillColor = Tools.getProperty(this.colorScale, group);
        if (options2.getFillColor) {
          return options2.getFillColor(group, key2, data, defaultFillColor);
        } else {
          return defaultFillColor;
        }
      };
      ChartModel2.prototype.getStrokeColor = function(group, key2, data) {
        var options2 = this.getOptions();
        var defaultStrokeColor = Tools.getProperty(this.colorScale, group);
        if (options2.getStrokeColor) {
          return options2.getStrokeColor(group, key2, data, defaultStrokeColor);
        } else {
          return defaultStrokeColor;
        }
      };
      ChartModel2.prototype.isUserProvidedColorScaleValid = function() {
        var userProvidedScale = Tools.getProperty(this.getOptions(), "color", "scale");
        var dataGroups = this.getDataGroups();
        if (userProvidedScale == null || Object.keys(userProvidedScale).length == 0) {
          return false;
        }
        return dataGroups.some(function(dataGroup) {
          return Object.keys(userProvidedScale).includes(dataGroup.name);
        });
      };
      ChartModel2.prototype.getColorClassName = function(configs) {
        var colorPairingTag = this.colorClassNames(configs.dataGroupName);
        var className = configs.originalClassName;
        configs.classNameTypes.forEach(function(type2) {
          return className = configs.originalClassName ? className + " " + type2 + "-" + colorPairingTag : type2 + "-" + colorPairingTag;
        });
        return className;
      };
      ChartModel2.prototype.getStatus = function() {
        return null;
      };
      ChartModel2.prototype.getAllDataGroupsNames = function() {
        return this.allDataGroups;
      };
      ChartModel2.prototype.transformToTabularData = function(data) {
        console.warn("We've updated the charting data format to be tabular by default. The current format you're using is deprecated and will be removed in v1.0, read more here https://carbon-design-system.github.io/carbon-charts/?path=/story/docs-tutorials--tabular-data-format");
        var tabularData = [];
        var datasets = data.datasets, labels = data.labels;
        datasets.forEach(function(dataset) {
          dataset.data.forEach(function(datum2, i2) {
            var group;
            var datasetLabel = Tools.getProperty(dataset, "label");
            if (datasetLabel === null) {
              var correspondingLabel = Tools.getProperty(labels, i2);
              if (correspondingLabel) {
                group = correspondingLabel;
              } else {
                group = "Ungrouped";
              }
            } else {
              group = datasetLabel;
            }
            var updatedDatum = {
              group,
              key: labels[i2]
            };
            if (isNaN(datum2)) {
              updatedDatum["value"] = datum2.value;
              updatedDatum["date"] = datum2.date;
            } else {
              updatedDatum["value"] = datum2;
            }
            tabularData.push(updatedDatum);
          });
        });
        return tabularData;
      };
      ChartModel2.prototype.getTabularDataArray = function() {
        return [];
      };
      ChartModel2.prototype.exportToCSV = function() {
        var data = this.getTabularDataArray().map(function(row) {
          return row.map(function(column) {
            return '"' + column + '"';
          });
        });
        var csvString = "", csvData = "";
        data.forEach(function(d, i2) {
          csvData = d.join(",");
          csvString += i2 < data.length ? csvData + "\n" : csvData;
        });
        this.services.files.downloadCSV(csvString, "myChart.csv");
      };
      ChartModel2.prototype.getTabularData = function(data) {
        if (!Array.isArray(data)) {
          return this.transformToTabularData(data);
        }
        return data;
      };
      ChartModel2.prototype.sanitize = function(data) {
        data = this.getTabularData(data);
        return data;
      };
      ChartModel2.prototype.updateAllDataGroups = function() {
        var _this = this;
        if (!this.allDataGroups) {
          this.allDataGroups = this.getDataGroupNames();
        } else {
          this.getDataGroupNames().forEach(function(dataGroupName) {
            if (_this.allDataGroups.indexOf(dataGroupName) === -1) {
              _this.allDataGroups.push(dataGroupName);
            }
          });
        }
      };
      ChartModel2.prototype.generateDataGroups = function(data) {
        var groupMapsTo = this.getOptions().data.groupMapsTo;
        var _a22 = legend$1.items.status, ACTIVE = _a22.ACTIVE, DISABLED = _a22.DISABLED;
        var options2 = this.getOptions();
        var uniqueDataGroups = Tools.removeArrayDuplicates(data.map(function(datum2) {
          return datum2[groupMapsTo];
        }));
        if (options2.data.selectedGroups.length) {
          var hasAllSelectedGroups = options2.data.selectedGroups.every(function(groupName) {
            return uniqueDataGroups.includes(groupName);
          });
          if (!hasAllSelectedGroups) {
            options2.data.selectedGroups = [];
          }
        }
        var getStatus = function(groupName) {
          return !options2.data.selectedGroups.length || options2.data.selectedGroups.includes(groupName) ? ACTIVE : DISABLED;
        };
        return uniqueDataGroups.map(function(groupName) {
          return {
            name: groupName,
            status: getStatus(groupName)
          };
        });
      };
      ChartModel2.prototype.setCustomColorScale = function() {
        var _this = this;
        if (!this.isUserProvidedColorScaleValid()) {
          return;
        }
        var options2 = this.getOptions();
        var userProvidedScale = Tools.getProperty(options2, "color", "scale");
        Object.keys(userProvidedScale).forEach(function(dataGroup) {
          if (!_this.allDataGroups.includes(dataGroup)) {
            console.warn('"' + dataGroup + '" does not exist in data groups.');
          }
        });
        var providedDataGroups = this.allDataGroups.filter(function(dataGroup) {
          return userProvidedScale[dataGroup];
        });
        providedDataGroups.forEach(function(dataGroup) {
          return _this.colorScale[dataGroup] = userProvidedScale[dataGroup];
        });
      };
      ChartModel2.prototype.setColorClassNames = function() {
        var colorPairingOptions = Tools.getProperty(this.getOptions(), "color", "pairing");
        var numberOfVariants = Tools.getProperty(colorPairingOptions, "numberOfVariants");
        if (!numberOfVariants || numberOfVariants < this.allDataGroups.length) {
          numberOfVariants = this.allDataGroups.length;
        }
        var pairingOption = Tools.getProperty(colorPairingOptions, "option");
        var colorPairingCounts = color$1.pairingOptions;
        var numberOfColors = numberOfVariants > 5 ? 14 : numberOfVariants;
        pairingOption = pairingOption <= colorPairingCounts[numberOfColors + "-color"] ? pairingOption : 1;
        var colorPairing = this.allDataGroups.map(function(dataGroup, index2) {
          return numberOfColors + "-" + pairingOption + "-" + (index2 % 14 + 1);
        });
        this.colorClassNames = ordinal().range(colorPairing).domain(this.allDataGroups);
      };
      return ChartModel2;
    }();
    Service = function() {
      function Service2(model, services) {
        this.model = model;
        this.services = services;
        this.init();
      }
      Service2.prototype.init = function() {
      };
      Service2.prototype.update = function() {
      };
      Service2.prototype.setModel = function(newObj) {
        this.model = newObj;
      };
      Service2.prototype.setServices = function(newObj) {
        this.services = newObj;
      };
      return Service2;
    }();
    settings = {
      prefix: "bx",
      selectorTabbable: "\n    a[href], area[href], input:not([disabled]):not([tabindex='-1']),\n    button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),\n    textarea:not([disabled]):not([tabindex='-1']),\n    iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]\n  ",
      selectorFocusable: "\n    a[href], area[href], input:not([disabled]),\n    button:not([disabled]),select:not([disabled]),\n    textarea:not([disabled]),\n    iframe, object, embed, *[tabindex], *[contenteditable=true]\n  "
    };
    settings_1 = settings;
    settings$1 = settings_1;
    MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key2) {
        var result = -1;
        arr.some(function(entry4, index2) {
          if (entry4[0] === key2) {
            result = index2;
            return true;
          }
          return false;
        });
        return result;
      }
      return function() {
        function anonymous() {
          this.__entries__ = [];
        }
        var prototypeAccessors = { size: { configurable: true } };
        prototypeAccessors.size.get = function() {
          return this.__entries__.length;
        };
        anonymous.prototype.get = function(key2) {
          var index2 = getIndex(this.__entries__, key2);
          var entry4 = this.__entries__[index2];
          return entry4 && entry4[1];
        };
        anonymous.prototype.set = function(key2, value2) {
          var index2 = getIndex(this.__entries__, key2);
          if (~index2) {
            this.__entries__[index2][1] = value2;
          } else {
            this.__entries__.push([key2, value2]);
          }
        };
        anonymous.prototype.delete = function(key2) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key2);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        anonymous.prototype.has = function(key2) {
          return !!~getIndex(this.__entries__, key2);
        };
        anonymous.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        anonymous.prototype.forEach = function(callback, ctx) {
          var this$1$1 = this;
          if (ctx === void 0)
            ctx = null;
          for (var i2 = 0, list = this$1$1.__entries__; i2 < list.length; i2 += 1) {
            var entry4 = list[i2];
            callback.call(ctx, entry4[1], entry4[0]);
          }
        };
        Object.defineProperties(anonymous.prototype, prototypeAccessors);
        return anonymous;
      }();
    }();
    isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    trailingTimeout = 2;
    throttle = function(callback, delay) {
      var leadingCall = false, trailingCall = false, lastCallTime = 0;
      function resolvePending() {
        if (leadingCall) {
          leadingCall = false;
          callback();
        }
        if (trailingCall) {
          proxy();
        }
      }
      function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
      }
      function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
          if (timeStamp - lastCallTime < trailingTimeout) {
            return;
          }
          trailingCall = true;
        } else {
          leadingCall = true;
          trailingCall = false;
          setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
      }
      return proxy;
    };
    REFRESH_DELAY = 20;
    transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    mutationObserverSupported = typeof MutationObserver !== "undefined";
    ResizeObserverController = function() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    };
    ResizeObserverController.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController.prototype.onTransitionEnd_ = function(ref) {
      var propertyName = ref.propertyName;
      if (propertyName === void 0)
        propertyName = "";
      var isReflowProperty = transitionKeys.some(function(key2) {
        return !!~propertyName.indexOf(key2);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController();
      }
      return this.instance_;
    };
    ResizeObserverController.instance_ = null;
    defineConfigurable = function(target, props) {
      for (var i2 = 0, list = Object.keys(props); i2 < list.length; i2 += 1) {
        var key2 = list[i2];
        Object.defineProperty(target, key2, {
          value: props[key2],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    emptyRect = createRectInit(0, 0, 0, 0);
    isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    ResizeObservation = function(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    };
    ResizeObservation.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    ResizeObserverEntry = function(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    };
    ResizeObserverSPI = function(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    };
    ResizeObserverSPI.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI.prototype.gatherActive = function() {
      var this$1$1 = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          this$1$1.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    ResizeObserver = function(callback) {
      if (!(this instanceof ResizeObserver)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    };
    ["observe", "unobserve", "disconnect"].forEach(function(method) {
      ResizeObserver.prototype[method] = function() {
        return (ref = observers.get(this))[method].apply(ref, arguments);
        var ref;
      };
    });
    index = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver;
    }();
    domToImage$1 = { exports: {} };
    (function(module2) {
      (function(global2) {
        var util = newUtil();
        var inliner = newInliner();
        var fontFaces = newFontFaces();
        var images = newImages();
        var defaultOptions = {
          imagePlaceholder: void 0,
          cacheBust: false
        };
        var domtoimage = {
          toSvg,
          toPng,
          toJpeg,
          toBlob,
          toPixelData,
          impl: {
            fontFaces,
            images,
            util,
            inliner,
            options: {}
          }
        };
        module2.exports = domtoimage;
        function toSvg(node, options2) {
          options2 = options2 || {};
          copyOptions(options2);
          return Promise.resolve(node).then(function(node2) {
            return cloneNode(node2, options2.filter, true);
          }).then(embedFonts).then(inlineImages).then(applyOptions).then(function(clone2) {
            return makeSvgDataUri(clone2, options2.width || util.width(node), options2.height || util.height(node));
          });
          function applyOptions(clone2) {
            if (options2.bgcolor)
              clone2.style.backgroundColor = options2.bgcolor;
            if (options2.width)
              clone2.style.width = options2.width + "px";
            if (options2.height)
              clone2.style.height = options2.height + "px";
            if (options2.style)
              Object.keys(options2.style).forEach(function(property2) {
                clone2.style[property2] = options2.style[property2];
              });
            return clone2;
          }
        }
        function toPixelData(node, options2) {
          return draw(node, options2 || {}).then(function(canvas) {
            return canvas.getContext("2d").getImageData(0, 0, util.width(node), util.height(node)).data;
          });
        }
        function toPng(node, options2) {
          return draw(node, options2 || {}).then(function(canvas) {
            return canvas.toDataURL();
          });
        }
        function toJpeg(node, options2) {
          options2 = options2 || {};
          return draw(node, options2).then(function(canvas) {
            return canvas.toDataURL("image/jpeg", options2.quality || 1);
          });
        }
        function toBlob(node, options2) {
          return draw(node, options2 || {}).then(util.canvasToBlob);
        }
        function copyOptions(options2) {
          if (typeof options2.imagePlaceholder === "undefined") {
            domtoimage.impl.options.imagePlaceholder = defaultOptions.imagePlaceholder;
          } else {
            domtoimage.impl.options.imagePlaceholder = options2.imagePlaceholder;
          }
          if (typeof options2.cacheBust === "undefined") {
            domtoimage.impl.options.cacheBust = defaultOptions.cacheBust;
          } else {
            domtoimage.impl.options.cacheBust = options2.cacheBust;
          }
        }
        function draw(domNode, options2) {
          return toSvg(domNode, options2).then(util.makeImage).then(util.delay(100)).then(function(image) {
            var canvas = newCanvas(domNode);
            canvas.getContext("2d").drawImage(image, 0, 0);
            return canvas;
          });
          function newCanvas(domNode2) {
            var canvas = document.createElement("canvas");
            canvas.width = options2.width || util.width(domNode2);
            canvas.height = options2.height || util.height(domNode2);
            if (options2.bgcolor) {
              var ctx = canvas.getContext("2d");
              ctx.fillStyle = options2.bgcolor;
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            return canvas;
          }
        }
        function cloneNode(node, filter2, root2) {
          if (!root2 && filter2 && !filter2(node))
            return Promise.resolve();
          return Promise.resolve(node).then(makeNodeCopy).then(function(clone2) {
            return cloneChildren(node, clone2, filter2);
          }).then(function(clone2) {
            return processClone(node, clone2);
          });
          function makeNodeCopy(node2) {
            if (node2 instanceof HTMLCanvasElement)
              return util.makeImage(node2.toDataURL());
            return node2.cloneNode(false);
          }
          function cloneChildren(original, clone2, filter3) {
            var children2 = original.childNodes;
            if (children2.length === 0)
              return Promise.resolve(clone2);
            return cloneChildrenInOrder(clone2, util.asArray(children2), filter3).then(function() {
              return clone2;
            });
            function cloneChildrenInOrder(parent, children3, filter4) {
              var done = Promise.resolve();
              children3.forEach(function(child) {
                done = done.then(function() {
                  return cloneNode(child, filter4);
                }).then(function(childClone) {
                  if (childClone)
                    parent.appendChild(childClone);
                });
              });
              return done;
            }
          }
          function processClone(original, clone2) {
            if (!(clone2 instanceof Element))
              return clone2;
            return Promise.resolve().then(cloneStyle).then(clonePseudoElements).then(copyUserInput).then(fixSvg).then(function() {
              return clone2;
            });
            function cloneStyle() {
              copyStyle(window.getComputedStyle(original), clone2.style);
              function copyStyle(source, target) {
                if (source.cssText)
                  target.cssText = source.cssText;
                else
                  copyProperties(source, target);
                function copyProperties(source2, target2) {
                  util.asArray(source2).forEach(function(name) {
                    target2.setProperty(name, source2.getPropertyValue(name), source2.getPropertyPriority(name));
                  });
                }
              }
            }
            function clonePseudoElements() {
              [":before", ":after"].forEach(function(element) {
                clonePseudoElement(element);
              });
              function clonePseudoElement(element) {
                var style = window.getComputedStyle(original, element);
                var content = style.getPropertyValue("content");
                if (content === "" || content === "none")
                  return;
                var className = util.uid();
                clone2.className = clone2.className + " " + className;
                var styleElement = document.createElement("style");
                styleElement.appendChild(formatPseudoElementStyle(className, element, style));
                clone2.appendChild(styleElement);
                function formatPseudoElementStyle(className2, element2, style2) {
                  var selector2 = "." + className2 + ":" + element2;
                  var cssText = style2.cssText ? formatCssText(style2) : formatCssProperties(style2);
                  return document.createTextNode(selector2 + "{" + cssText + "}");
                  function formatCssText(style3) {
                    var content2 = style3.getPropertyValue("content");
                    return style3.cssText + " content: " + content2 + ";";
                  }
                  function formatCssProperties(style3) {
                    return util.asArray(style3).map(formatProperty).join("; ") + ";";
                    function formatProperty(name) {
                      return name + ": " + style3.getPropertyValue(name) + (style3.getPropertyPriority(name) ? " !important" : "");
                    }
                  }
                }
              }
            }
            function copyUserInput() {
              if (original instanceof HTMLTextAreaElement)
                clone2.innerHTML = original.value;
              if (original instanceof HTMLInputElement)
                clone2.setAttribute("value", original.value);
            }
            function fixSvg() {
              if (!(clone2 instanceof SVGElement))
                return;
              clone2.setAttribute("xmlns", "http://www.w3.org/2000/svg");
              if (!(clone2 instanceof SVGRectElement))
                return;
              ["width", "height"].forEach(function(attribute) {
                var value2 = clone2.getAttribute(attribute);
                if (!value2)
                  return;
                clone2.style.setProperty(attribute, value2);
              });
            }
          }
        }
        function embedFonts(node) {
          return fontFaces.resolveAll().then(function(cssText) {
            var styleNode = document.createElement("style");
            node.appendChild(styleNode);
            styleNode.appendChild(document.createTextNode(cssText));
            return node;
          });
        }
        function inlineImages(node) {
          return images.inlineAll(node).then(function() {
            return node;
          });
        }
        function makeSvgDataUri(node, width, height) {
          return Promise.resolve(node).then(function(node2) {
            node2.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
            return new XMLSerializer().serializeToString(node2);
          }).then(util.escapeXhtml).then(function(xhtml2) {
            return '<foreignObject x="0" y="0" width="100%" height="100%">' + xhtml2 + "</foreignObject>";
          }).then(function(foreignObject) {
            return '<svg xmlns="http://www.w3.org/2000/svg" width="' + width + '" height="' + height + '">' + foreignObject + "</svg>";
          }).then(function(svg) {
            return "data:image/svg+xml;charset=utf-8," + svg;
          });
        }
        function newUtil() {
          return {
            escape: escape2,
            parseExtension,
            mimeType,
            dataAsUrl,
            isDataUrl,
            canvasToBlob,
            resolveUrl,
            getAndEncode,
            uid: uid(),
            delay,
            asArray,
            escapeXhtml,
            makeImage,
            width,
            height
          };
          function mimes() {
            var WOFF = "application/font-woff";
            var JPEG = "image/jpeg";
            return {
              "woff": WOFF,
              "woff2": WOFF,
              "ttf": "application/font-truetype",
              "eot": "application/vnd.ms-fontobject",
              "png": "image/png",
              "jpg": JPEG,
              "jpeg": JPEG,
              "gif": "image/gif",
              "tiff": "image/tiff",
              "svg": "image/svg+xml"
            };
          }
          function parseExtension(url) {
            var match2 = /\.([^\.\/]*?)$/g.exec(url);
            if (match2)
              return match2[1];
            else
              return "";
          }
          function mimeType(url) {
            var extension = parseExtension(url).toLowerCase();
            return mimes()[extension] || "";
          }
          function isDataUrl(url) {
            return url.search(/^(data:)/) !== -1;
          }
          function toBlob2(canvas) {
            return new Promise(function(resolve2) {
              var binaryString = window.atob(canvas.toDataURL().split(",")[1]);
              var length = binaryString.length;
              var binaryArray = new Uint8Array(length);
              for (var i2 = 0; i2 < length; i2++)
                binaryArray[i2] = binaryString.charCodeAt(i2);
              resolve2(new Blob([binaryArray], {
                type: "image/png"
              }));
            });
          }
          function canvasToBlob(canvas) {
            if (canvas.toBlob)
              return new Promise(function(resolve2) {
                canvas.toBlob(resolve2);
              });
            return toBlob2(canvas);
          }
          function resolveUrl(url, baseUrl) {
            var doc = document.implementation.createHTMLDocument();
            var base2 = doc.createElement("base");
            doc.head.appendChild(base2);
            var a = doc.createElement("a");
            doc.body.appendChild(a);
            base2.href = baseUrl;
            a.href = url;
            return a.href;
          }
          function uid() {
            var index2 = 0;
            return function() {
              return "u" + fourRandomChars() + index2++;
              function fourRandomChars() {
                return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
              }
            };
          }
          function makeImage(uri) {
            return new Promise(function(resolve2, reject) {
              var image = new Image();
              image.onload = function() {
                resolve2(image);
              };
              image.onerror = reject;
              image.src = uri;
            });
          }
          function getAndEncode(url) {
            var TIMEOUT = 3e4;
            if (domtoimage.impl.options.cacheBust) {
              url += (/\?/.test(url) ? "&" : "?") + new Date().getTime();
            }
            return new Promise(function(resolve2) {
              var request = new XMLHttpRequest();
              request.onreadystatechange = done;
              request.ontimeout = timeout2;
              request.responseType = "blob";
              request.timeout = TIMEOUT;
              request.open("GET", url, true);
              request.send();
              var placeholder;
              if (domtoimage.impl.options.imagePlaceholder) {
                var split = domtoimage.impl.options.imagePlaceholder.split(/,/);
                if (split && split[1]) {
                  placeholder = split[1];
                }
              }
              function done() {
                if (request.readyState !== 4)
                  return;
                if (request.status !== 200) {
                  if (placeholder) {
                    resolve2(placeholder);
                  } else {
                    fail("cannot fetch resource: " + url + ", status: " + request.status);
                  }
                  return;
                }
                var encoder2 = new FileReader();
                encoder2.onloadend = function() {
                  var content = encoder2.result.split(/,/)[1];
                  resolve2(content);
                };
                encoder2.readAsDataURL(request.response);
              }
              function timeout2() {
                if (placeholder) {
                  resolve2(placeholder);
                } else {
                  fail("timeout of " + TIMEOUT + "ms occured while fetching resource: " + url);
                }
              }
              function fail(message) {
                console.error(message);
                resolve2("");
              }
            });
          }
          function dataAsUrl(content, type2) {
            return "data:" + type2 + ";base64," + content;
          }
          function escape2(string) {
            return string.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
          }
          function delay(ms) {
            return function(arg) {
              return new Promise(function(resolve2) {
                setTimeout(function() {
                  resolve2(arg);
                }, ms);
              });
            };
          }
          function asArray(arrayLike) {
            var array2 = [];
            var length = arrayLike.length;
            for (var i2 = 0; i2 < length; i2++)
              array2.push(arrayLike[i2]);
            return array2;
          }
          function escapeXhtml(string) {
            return string.replace(/#/g, "%23").replace(/\n/g, "%0A");
          }
          function width(node) {
            var leftBorder = px(node, "border-left-width");
            var rightBorder = px(node, "border-right-width");
            return node.scrollWidth + leftBorder + rightBorder;
          }
          function height(node) {
            var topBorder = px(node, "border-top-width");
            var bottomBorder = px(node, "border-bottom-width");
            return node.scrollHeight + topBorder + bottomBorder;
          }
          function px(node, styleProperty) {
            var value2 = window.getComputedStyle(node).getPropertyValue(styleProperty);
            return parseFloat(value2.replace("px", ""));
          }
        }
        function newInliner() {
          var URL_REGEX = /url\(['"]?([^'"]+?)['"]?\)/g;
          return {
            inlineAll,
            shouldProcess,
            impl: {
              readUrls,
              inline
            }
          };
          function shouldProcess(string) {
            return string.search(URL_REGEX) !== -1;
          }
          function readUrls(string) {
            var result = [];
            var match2;
            while ((match2 = URL_REGEX.exec(string)) !== null) {
              result.push(match2[1]);
            }
            return result.filter(function(url) {
              return !util.isDataUrl(url);
            });
          }
          function inline(string, url, baseUrl, get2) {
            return Promise.resolve(url).then(function(url2) {
              return baseUrl ? util.resolveUrl(url2, baseUrl) : url2;
            }).then(get2 || util.getAndEncode).then(function(data) {
              return util.dataAsUrl(data, util.mimeType(url));
            }).then(function(dataUrl) {
              return string.replace(urlAsRegex(url), "$1" + dataUrl + "$3");
            });
            function urlAsRegex(url2) {
              return new RegExp(`(url\\(['"]?)(` + util.escape(url2) + `)(['"]?\\))`, "g");
            }
          }
          function inlineAll(string, baseUrl, get2) {
            if (nothingToInline())
              return Promise.resolve(string);
            return Promise.resolve(string).then(readUrls).then(function(urls) {
              var done = Promise.resolve(string);
              urls.forEach(function(url) {
                done = done.then(function(string2) {
                  return inline(string2, url, baseUrl, get2);
                });
              });
              return done;
            });
            function nothingToInline() {
              return !shouldProcess(string);
            }
          }
        }
        function newFontFaces() {
          return {
            resolveAll,
            impl: {
              readAll
            }
          };
          function resolveAll() {
            return readAll().then(function(webFonts) {
              return Promise.all(webFonts.map(function(webFont) {
                return webFont.resolve();
              }));
            }).then(function(cssStrings) {
              return cssStrings.join("\n");
            });
          }
          function readAll() {
            return Promise.resolve(util.asArray(document.styleSheets)).then(getCssRules).then(selectWebFontRules).then(function(rules) {
              return rules.map(newWebFont);
            });
            function selectWebFontRules(cssRules) {
              return cssRules.filter(function(rule) {
                return rule.type === CSSRule.FONT_FACE_RULE;
              }).filter(function(rule) {
                return inliner.shouldProcess(rule.style.getPropertyValue("src"));
              });
            }
            function getCssRules(styleSheets) {
              var cssRules = [];
              styleSheets.forEach(function(sheet) {
                try {
                  util.asArray(sheet.cssRules || []).forEach(cssRules.push.bind(cssRules));
                } catch (e3) {
                  console.log("Error while reading CSS rules from " + sheet.href, e3.toString());
                }
              });
              return cssRules;
            }
            function newWebFont(webFontRule) {
              return {
                resolve: function resolve2() {
                  var baseUrl = (webFontRule.parentStyleSheet || {}).href;
                  return inliner.inlineAll(webFontRule.cssText, baseUrl);
                },
                src: function() {
                  return webFontRule.style.getPropertyValue("src");
                }
              };
            }
          }
        }
        function newImages() {
          return {
            inlineAll,
            impl: {
              newImage
            }
          };
          function newImage(element) {
            return {
              inline
            };
            function inline(get2) {
              if (util.isDataUrl(element.src))
                return Promise.resolve();
              return Promise.resolve(element.src).then(get2 || util.getAndEncode).then(function(data) {
                return util.dataAsUrl(data, util.mimeType(element.src));
              }).then(function(dataUrl) {
                return new Promise(function(resolve2, reject) {
                  element.onload = resolve2;
                  element.onerror = reject;
                  element.src = dataUrl;
                });
              });
            }
          }
          function inlineAll(node) {
            if (!(node instanceof Element))
              return Promise.resolve(node);
            return inlineBackground(node).then(function() {
              if (node instanceof HTMLImageElement)
                return newImage(node).inline();
              else
                return Promise.all(util.asArray(node.childNodes).map(function(child) {
                  return inlineAll(child);
                }));
            });
            function inlineBackground(node2) {
              var background = node2.style.getPropertyValue("background");
              if (!background)
                return Promise.resolve(node2);
              return inliner.inlineAll(background).then(function(inlined) {
                node2.style.setProperty("background", inlined, node2.style.getPropertyPriority("background"));
              }).then(function() {
                return node2;
              });
            }
          }
        }
      })();
    })(domToImage$1);
    domToImage = domToImage$1.exports;
    __extends$1y = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CSS_VERIFIER_ELEMENT_CLASSNAME = "DONT_STYLE_ME_css_styles_verifier";
    DOMUtils = function(_super) {
      __extends$1y(DOMUtils2, _super);
      function DOMUtils2(model, services) {
        var _this = _super.call(this, model, services) || this;
        _this.chartID = Math.floor((1 + Math.random()) * 281474976710656).toString(16);
        return _this;
      }
      DOMUtils2.getHTMLElementSize = function(element) {
        return {
          width: element.clientWidth,
          height: element.clientHeight
        };
      };
      DOMUtils2.getSVGElementSize = function(svgSelector, options2) {
        if (options2 === void 0) {
          options2 = {
            useAttrs: false,
            useClientDimensions: false,
            useBBox: false,
            useBoundingRect: false
          };
        }
        if (!svgSelector.attr) {
          svgSelector = select(svgSelector);
        }
        var finalDimensions = {
          width: 0,
          height: 0
        };
        var validateAndSetDimensions = function(dimensions) {
          if (dimensions) {
            Object.keys(finalDimensions).forEach(function(dimensionKey) {
              if (dimensions[dimensionKey]) {
                var dimension = dimensions[dimensionKey];
                var dimensionNumber = parseFloat(dimension);
                if (dimension && dimensionNumber > finalDimensions[dimensionKey] && ("" + dimension).indexOf("%") === -1) {
                  finalDimensions[dimensionKey] = dimensionNumber;
                }
              }
            });
          }
        };
        var attrDimensions = {
          width: svgSelector.attr("width"),
          height: svgSelector.attr("height")
        };
        var bbox, bboxDimensions, boundingRect, boundingRectDimensions;
        try {
          bbox = svgSelector.node().getBBox();
          bboxDimensions = {
            width: bbox.width,
            height: bbox.height
          };
        } catch (e3) {
        }
        try {
          boundingRect = svgSelector.node().getBoundingClientRect();
          boundingRectDimensions = {
            width: boundingRect.width,
            height: boundingRect.height
          };
        } catch (e3) {
        }
        var clientDimensions = {
          width: svgSelector.node().clientWidth,
          height: svgSelector.node().clientHeight
        };
        if (options2) {
          if (options2.useAttrs) {
            validateAndSetDimensions(attrDimensions);
            if (finalDimensions.width > 0 && finalDimensions.height > 0) {
              return finalDimensions;
            }
          }
          if (options2.useClientDimensions) {
            validateAndSetDimensions(clientDimensions);
            if (finalDimensions.width > 0 && finalDimensions.height > 0) {
              return clientDimensions;
            }
          }
          if (options2.useBBox) {
            validateAndSetDimensions(bboxDimensions);
            if (finalDimensions.width > 0 && finalDimensions.height > 0) {
              return bboxDimensions;
            }
          }
          if (options2.useBoundingRect) {
            validateAndSetDimensions(boundingRectDimensions);
            if (finalDimensions.width > 0 && finalDimensions.height > 0) {
              return boundingRectDimensions;
            }
          }
        }
        try {
          var nativeDimensions = {
            width: Tools.getProperty(svgSelector.node(), "width", "baseVal", "value"),
            height: Tools.getProperty(svgSelector.node(), "height", "baseVal", "value")
          };
          validateAndSetDimensions(nativeDimensions);
        } catch (e3) {
          validateAndSetDimensions(clientDimensions);
          validateAndSetDimensions(bboxDimensions);
          validateAndSetDimensions(attrDimensions);
        }
        return finalDimensions;
      };
      DOMUtils2.appendOrSelect = function(parent, query) {
        var selection2 = parent.select("" + query);
        if (selection2.empty()) {
          var querySections = query.split("#");
          var elementToAppend = void 0;
          var id2 = void 0;
          if (querySections.length === 2) {
            elementToAppend = querySections[0];
            querySections = querySections[1].split(".");
            id2 = querySections[0];
          } else {
            querySections = query.split(".");
            elementToAppend = querySections[0];
          }
          return parent.append(elementToAppend).attr("id", id2).attr("class", querySections.slice(1).join(" "));
        }
        return selection2;
      };
      DOMUtils2.prototype.init = function() {
        this.styleHolderElement();
        this.addMainContainer();
        this.verifyCSSStylesBeingApplied();
        if (this.model.getOptions().resizable) {
          this.addResizeListener();
        }
        this.addHolderListeners();
        this.handleFullscreenChange();
      };
      DOMUtils2.prototype.getChartID = function() {
        return this.chartID;
      };
      DOMUtils2.prototype.generateElementIDString = function(originalID) {
        return "chart-" + this.chartID + "-" + originalID;
      };
      DOMUtils2.prototype.addMainContainer = function() {
        var options2 = this.model.getOptions();
        var chartsprefix = Tools.getProperty(options2, "style", "prefix");
        var mainContainer = select(this.getHolder()).append("div").classed(settings$1.prefix + "--" + chartsprefix + "--chart-wrapper", true).style("height", "100%").style("width", "100%");
        mainContainer.append("g").attr("class", CSS_VERIFIER_ELEMENT_CLASSNAME);
        this.mainContainer = mainContainer.node();
      };
      DOMUtils2.prototype.update = function() {
        this.styleHolderElement();
      };
      DOMUtils2.prototype.styleHolderElement = function() {
        var holderElement = this.getHolder();
        select(this.getHolder()).classed(settings$1.prefix + "--chart-holder", true);
        var _a22 = this.model.getOptions(), width = _a22.width, height = _a22.height;
        if (width !== this.width) {
          holderElement.style.width = width;
          this.width = width;
        }
        if (height !== this.height) {
          holderElement.style.height = height;
          this.height = height;
        }
      };
      DOMUtils2.prototype.getHolder = function() {
        return this.model.get("holder");
      };
      DOMUtils2.prototype.exportToJPG = function() {
        var self2 = this;
        var holder = this.getHolder();
        var holderSelection = select(holder);
        holderSelection.classed("filled", true);
        domToImage.toJpeg(this.getMainContainer(), {
          bgcolor: typeof window !== "undefined" ? window.getComputedStyle(holder).getPropertyValue("background-color") : void 0,
          quality: 1,
          filter: function(node) {
            if (node.classList && node.classList.contains("bx--cc--toolbar")) {
              return false;
            }
            return true;
          }
        }).then(function(dataUrl) {
          self2.services.files.downloadImage(dataUrl, "myChart.jpg");
          holderSelection.classed("filled", false);
        });
      };
      DOMUtils2.prototype.exportToPNG = function() {
        var self2 = this;
        var holder = this.getHolder();
        var holderSelection = select(holder);
        holderSelection.classed("filled", true);
        domToImage.toPng(this.getMainContainer(), {
          bgcolor: typeof window !== "undefined" ? window.getComputedStyle(holder).getPropertyValue("background-color") : void 0,
          quality: 1,
          filter: function(node) {
            if (node.classList && node.classList.contains("bx--cc--toolbar")) {
              return false;
            }
            return true;
          }
        }).then(function(dataUrl) {
          self2.services.files.downloadImage(dataUrl, "myChart.png");
          holderSelection.classed("filled", false);
        }).catch(function(error2) {
          console.error("oops, something went wrong!", error2);
        });
      };
      DOMUtils2.prototype.toggleFullscreen = function() {
        var holder = this.getHolder();
        var holderSelection = select(holder);
        var isFullScreen = holderSelection.classed("fullscreen");
        if (isFullScreen && (document.fullscreenElement || document["webkitFullscreenElement"] || document["mozFullScreenElement"] || document["msFullscreenElement"])) {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document["webkitExitFullscreen"]) {
            document["webkitExitFullscreen"]();
          } else if (document["mozCancelFullScreen"]) {
            document["mozCancelFullScreen"]();
          } else if (document["msExitFullscreen"]) {
            document["msExitFullscreen"]();
          }
        } else {
          if (holder.requestFullscreen) {
            holder.requestFullscreen();
          } else if (holder.webkitRequestFullscreen) {
            holder.webkitRequestFullscreen();
          } else if (holder.mozRequestFullScreen) {
            holder.mozRequestFullScreen();
          } else if (holder.msRequestFullscreen) {
            holder.msRequestFullscreen();
          }
        }
      };
      DOMUtils2.prototype.handleFullscreenChange = function() {
        var _this = this;
        document.addEventListener("fullscreenchange", function() {
          var holderSelection = select(_this.getHolder());
          var isFullScreen = holderSelection.classed("fullscreen");
          holderSelection.classed("fullscreen", !isFullScreen);
        });
      };
      DOMUtils2.prototype.verifyCSSStylesBeingApplied = function() {
        var _this = this;
        setTimeout(function() {
          var cssVerifierElement = select(_this.mainContainer).select("g." + CSS_VERIFIER_ELEMENT_CLASSNAME).node();
          var computedStyles = getComputedStyle(cssVerifierElement);
          if (computedStyles.getPropertyValue("overflow") !== "hidden" || computedStyles.getPropertyValue("opacity") !== "0") {
            console.error("Missing CSS styles for Carbon Charts. Please read the Carbon Charts getting started guide.");
          }
        });
      };
      DOMUtils2.prototype.setSVGMaxHeight = function() {
        if (!this.model.getOptions().height) {
          var chartHeight = DOMUtils2.getSVGElementSize(select(this.mainContainer), { useBBox: true }).height;
          var chartSVGSelector = select(this.mainContainer).attr("class");
          var children2 = select(this.mainContainer).selectAll("." + chartSVGSelector + " > svg");
          var childrenHeight_1 = 0;
          children2.nodes().forEach(function(childSVG) {
            childrenHeight_1 += Number(DOMUtils2.getSVGElementSize(select(childSVG), {
              useBBox: true
            }).height);
          });
          childrenHeight_1 <= chartHeight ? select(this.mainContainer).attr("height", childrenHeight_1) : select(this.mainContainer).attr("height", "100%");
        }
      };
      DOMUtils2.prototype.getMainContainer = function() {
        return this.mainContainer;
      };
      DOMUtils2.prototype.addHolderListeners = function() {
        var _this = this;
        var holder = this.getHolder();
        if (!holder) {
          return;
        }
        select(holder).on("mouseover", function() {
          _this.services.events.dispatchEvent(Events$1.Chart.MOUSEOVER);
        }).on("mouseout", function() {
          _this.services.events.dispatchEvent(Events$1.Chart.MOUSEOUT);
        });
      };
      DOMUtils2.prototype.addResizeListener = function() {
        var _this = this;
        var holder = this.getHolder();
        if (!holder) {
          return;
        }
        var containerWidth = holder.clientWidth;
        var containerHeight = holder.clientHeight;
        var resizeCallback = Tools.debounce(function(entries, observer) {
          if (!holder) {
            return;
          }
          if (Math.abs(containerWidth - holder.clientWidth) > 1 || Math.abs(containerHeight - holder.clientHeight) > 1) {
            containerWidth = holder.clientWidth;
            containerHeight = holder.clientHeight;
            _this.services.events.dispatchEvent(Events$1.Chart.RESIZE);
          }
        }, 12.5);
        var resizeObserver = new index(resizeCallback);
        resizeObserver.observe(holder);
      };
      return DOMUtils2;
    }(Service);
    __extends$1x = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Events = function(_super) {
      __extends$1x(Events2, _super);
      function Events2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Events2.prototype.init = function() {
        this.documentFragment = document.createDocumentFragment();
      };
      Events2.prototype.addEventListener = function(type2, listener) {
        this.documentFragment.addEventListener(type2, listener);
      };
      Events2.prototype.removeEventListener = function(type2, listener) {
        this.documentFragment.removeEventListener(type2, listener);
      };
      Events2.prototype.dispatchEvent = function(eventType, eventDetail) {
        var newEvent;
        if (eventDetail) {
          newEvent = new CustomEvent(eventType, {
            detail: eventDetail
          });
        } else {
          newEvent = document.createEvent("Event");
          newEvent.initEvent(eventType, false, true);
        }
        this.documentFragment.dispatchEvent(newEvent);
      };
      return Events2;
    }(Service);
    __extends$1w = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Files = function(_super) {
      __extends$1w(Files2, _super);
      function Files2(model, services) {
        return _super.call(this, model, services) || this;
      }
      Files2.prototype.downloadCSV = function(content, filename) {
        var anchor = document.createElement("a");
        var mimeType = "text/csv;encoding:utf-8";
        if (navigator["msSaveBlob"]) {
          navigator["msSaveBlob"](new Blob([content], {
            type: mimeType
          }), filename);
        } else if (URL && "download" in anchor) {
          var href = URL.createObjectURL(new Blob([content], {
            type: mimeType
          }));
          anchor.href = href;
          anchor.setAttribute("download", filename);
          document.body.appendChild(anchor);
          anchor.click();
          document.body.removeChild(anchor);
          URL.revokeObjectURL(href);
        } else {
          location.href = "data:application/octet-stream," + encodeURIComponent(content);
        }
      };
      Files2.prototype.downloadImage = function(uri, name) {
        var link2 = document.createElement("a");
        link2.download = name;
        link2.href = uri;
        document.body.appendChild(link2);
        link2.click();
        document.body.removeChild(link2);
      };
      return Files2;
    }(Service);
    __extends$1v = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Transitions = function(_super) {
      __extends$1v(Transitions2, _super);
      function Transitions2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.pendingTransitions = {};
        return _this;
      }
      Transitions2.prototype.init = function() {
        var _this = this;
        this.services.events.addEventListener(Events$1.Model.UPDATE, function() {
          _this.pendingTransitions = {};
        });
      };
      Transitions2.prototype.setupTransition = function(_a22) {
        var _this = this;
        var t2 = _a22.transition, name = _a22.name, animate = _a22.animate;
        this.pendingTransitions[t2._id] = t2;
        t2.on("end interrupt cancel", function() {
          delete _this.pendingTransitions[t2._id];
        });
        if (this.model.getOptions().animations === false || animate === false) {
          return t2.duration(0);
        }
        return t2.duration(Tools.getProperty(transitions, name, "duration") || transitions.default.duration);
      };
      Transitions2.prototype.getPendingTransitions = function() {
        return this.pendingTransitions;
      };
      return Transitions2;
    }(Service);
    __extends$1u = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    GradientUtils = function(_super) {
      __extends$1u(GradientUtils2, _super);
      function GradientUtils2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      GradientUtils2.appendOrUpdateLinearGradient = function(configs) {
        var lg = configs.svg.select("defs linearGradient#" + configs.id);
        if (lg.empty()) {
          lg = configs.svg.append("defs").append("linearGradient").attr("id", configs.id).attr("x1", configs.x1).attr("x2", configs.x2).attr("y1", configs.y1).attr("y2", configs.y2);
        }
        lg.selectAll("stop").remove();
        lg.selectAll("stop").data(configs.stops).enter().append("stop").attr("offset", function(d) {
          return d.offset;
        }).style("stop-color", function(d) {
          return d.color;
        }).style("stop-opacity", function(d) {
          return d.opacity;
        });
      };
      GradientUtils2.getOffsetRatio = function(domain) {
        var offsetRatio = (Math.abs(domain[1]) * 100 / Math.abs(domain[0] - domain[1])).toFixed(2) + "%";
        return offsetRatio;
      };
      GradientUtils2.getStops = function(domain, color2) {
        var need3Stops = domain[0] < 0 && domain[1] > 0;
        var stops = [
          {
            offset: "0%",
            color: color2,
            opacity: "0.6"
          },
          {
            offset: "80%",
            color: color2,
            opacity: "0"
          }
        ];
        if (need3Stops) {
          stops = [
            {
              offset: "0%",
              color: color2,
              opacity: "0.6"
            },
            {
              offset: GradientUtils2.getOffsetRatio(domain),
              color: color2,
              opacity: "0"
            },
            {
              offset: "100%",
              color: color2,
              opacity: "0.6"
            }
          ];
        }
        return stops;
      };
      return GradientUtils2;
    }(Service);
    MILLISECONDS_IN_HOUR$1 = 36e5;
    MILLISECONDS_IN_MINUTE$2 = 6e4;
    MILLISECONDS_IN_DAY$1 = 864e5;
    MILLISECONDS_IN_MINUTE$1 = 6e4;
    MILLISECONDS_IN_HOUR = 36e5;
    MILLISECONDS_IN_MINUTE = 6e4;
    formatDistanceLocale = {
      lessThanXSeconds: {
        one: "less than a second",
        other: "less than {{count}} seconds"
      },
      xSeconds: {
        one: "1 second",
        other: "{{count}} seconds"
      },
      halfAMinute: "half a minute",
      lessThanXMinutes: {
        one: "less than a minute",
        other: "less than {{count}} minutes"
      },
      xMinutes: {
        one: "1 minute",
        other: "{{count}} minutes"
      },
      aboutXHours: {
        one: "about 1 hour",
        other: "about {{count}} hours"
      },
      xHours: {
        one: "1 hour",
        other: "{{count}} hours"
      },
      xDays: {
        one: "1 day",
        other: "{{count}} days"
      },
      aboutXMonths: {
        one: "about 1 month",
        other: "about {{count}} months"
      },
      xMonths: {
        one: "1 month",
        other: "{{count}} months"
      },
      aboutXYears: {
        one: "about 1 year",
        other: "about {{count}} years"
      },
      xYears: {
        one: "1 year",
        other: "{{count}} years"
      },
      overXYears: {
        one: "over 1 year",
        other: "over {{count}} years"
      },
      almostXYears: {
        one: "almost 1 year",
        other: "almost {{count}} years"
      }
    };
    dateFormats = {
      full: "EEEE, MMMM do, y",
      long: "MMMM do, y",
      medium: "MMM d, y",
      short: "MM/dd/yyyy"
    };
    timeFormats = {
      full: "h:mm:ss a zzzz",
      long: "h:mm:ss a z",
      medium: "h:mm:ss a",
      short: "h:mm a"
    };
    dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: "{{date}}, {{time}}",
      short: "{{date}}, {{time}}"
    };
    formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: "full"
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: "full"
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: "full"
      })
    };
    formatLong$1 = formatLong;
    formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: "P"
    };
    eraValues = {
      narrow: ["B", "A"],
      abbreviated: ["BC", "AD"],
      wide: ["Before Christ", "Anno Domini"]
    };
    quarterValues = {
      narrow: ["1", "2", "3", "4"],
      abbreviated: ["Q1", "Q2", "Q3", "Q4"],
      wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
    };
    monthValues = {
      narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
      abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
    };
    dayValues = {
      narrow: ["S", "M", "T", "W", "T", "F", "S"],
      short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
      abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
    };
    dayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "morning",
        afternoon: "afternoon",
        evening: "evening",
        night: "night"
      }
    };
    formattingDayPeriodValues = {
      narrow: {
        am: "a",
        pm: "p",
        midnight: "mi",
        noon: "n",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      abbreviated: {
        am: "AM",
        pm: "PM",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      },
      wide: {
        am: "a.m.",
        pm: "p.m.",
        midnight: "midnight",
        noon: "noon",
        morning: "in the morning",
        afternoon: "in the afternoon",
        evening: "in the evening",
        night: "at night"
      }
    };
    localize = {
      ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: "wide"
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: "wide",
        argumentCallback: function(quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: "wide"
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: "wide"
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: "wide",
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: "wide"
      })
    };
    localize$1 = localize;
    matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    parseOrdinalNumberPattern = /\d+/i;
    matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function(value2) {
          return parseInt(value2, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseEraPatterns,
        defaultParseWidth: "any"
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: "any",
        valueCallback: function(index2) {
          return index2 + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: "any"
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: "wide",
        parsePatterns: parseDayPatterns,
        defaultParseWidth: "any"
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: "any",
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: "any"
      })
    };
    match$1 = match;
    locale = {
      code: "en-US",
      formatDistance,
      formatLong: formatLong$1,
      formatRelative,
      localize: localize$1,
      match: match$1,
      options: {
        weekStartsOn: 0,
        firstWeekContainsDate: 1
      }
    };
    defaultLocale = locale;
    formatters$2 = {
      y: function(date2, token) {
        var signedYear = date2.getUTCFullYear();
        var year2 = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === "yy" ? year2 % 100 : year2, token.length);
      },
      M: function(date2, token) {
        var month2 = date2.getUTCMonth();
        return token === "M" ? String(month2 + 1) : addLeadingZeros(month2 + 1, 2);
      },
      d: function(date2, token) {
        return addLeadingZeros(date2.getUTCDate(), token.length);
      },
      a: function(date2, token) {
        var dayPeriodEnumValue = date2.getUTCHours() / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return dayPeriodEnumValue.toUpperCase();
          case "aaaaa":
            return dayPeriodEnumValue[0];
          case "aaaa":
          default:
            return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
        }
      },
      h: function(date2, token) {
        return addLeadingZeros(date2.getUTCHours() % 12 || 12, token.length);
      },
      H: function(date2, token) {
        return addLeadingZeros(date2.getUTCHours(), token.length);
      },
      m: function(date2, token) {
        return addLeadingZeros(date2.getUTCMinutes(), token.length);
      },
      s: function(date2, token) {
        return addLeadingZeros(date2.getUTCSeconds(), token.length);
      },
      S: function(date2, token) {
        var numberOfDigits = token.length;
        var milliseconds = date2.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };
    formatters$3 = formatters$2;
    MILLISECONDS_IN_DAY = 864e5;
    MILLISECONDS_IN_WEEK$1 = 6048e5;
    MILLISECONDS_IN_WEEK = 6048e5;
    dayPeriodEnum = {
      am: "am",
      pm: "pm",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    };
    formatters = {
      G: function(date2, token, localize2) {
        var era = date2.getUTCFullYear() > 0 ? 1 : 0;
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return localize2.era(era, {
              width: "abbreviated"
            });
          case "GGGGG":
            return localize2.era(era, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return localize2.era(era, {
              width: "wide"
            });
        }
      },
      y: function(date2, token, localize2) {
        if (token === "yo") {
          var signedYear = date2.getUTCFullYear();
          var year2 = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize2.ordinalNumber(year2, {
            unit: "year"
          });
        }
        return formatters$3.y(date2, token);
      },
      Y: function(date2, token, localize2, options2) {
        var signedWeekYear = getUTCWeekYear(date2, options2);
        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
        if (token === "YY") {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        }
        if (token === "Yo") {
          return localize2.ordinalNumber(weekYear, {
            unit: "year"
          });
        }
        return addLeadingZeros(weekYear, token.length);
      },
      R: function(date2, token) {
        var isoWeekYear = getUTCISOWeekYear(date2);
        return addLeadingZeros(isoWeekYear, token.length);
      },
      u: function(date2, token) {
        var year2 = date2.getUTCFullYear();
        return addLeadingZeros(year2, token.length);
      },
      Q: function(date2, token, localize2) {
        var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
        switch (token) {
          case "Q":
            return String(quarter);
          case "QQ":
            return addLeadingZeros(quarter, 2);
          case "Qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "QQQ":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "formatting"
            });
          case "QQQQQ":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      q: function(date2, token, localize2) {
        var quarter = Math.ceil((date2.getUTCMonth() + 1) / 3);
        switch (token) {
          case "q":
            return String(quarter);
          case "qq":
            return addLeadingZeros(quarter, 2);
          case "qo":
            return localize2.ordinalNumber(quarter, {
              unit: "quarter"
            });
          case "qqq":
            return localize2.quarter(quarter, {
              width: "abbreviated",
              context: "standalone"
            });
          case "qqqqq":
            return localize2.quarter(quarter, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return localize2.quarter(quarter, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      M: function(date2, token, localize2) {
        var month2 = date2.getUTCMonth();
        switch (token) {
          case "M":
          case "MM":
            return formatters$3.M(date2, token);
          case "Mo":
            return localize2.ordinalNumber(month2 + 1, {
              unit: "month"
            });
          case "MMM":
            return localize2.month(month2, {
              width: "abbreviated",
              context: "formatting"
            });
          case "MMMMM":
            return localize2.month(month2, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return localize2.month(month2, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      L: function(date2, token, localize2) {
        var month2 = date2.getUTCMonth();
        switch (token) {
          case "L":
            return String(month2 + 1);
          case "LL":
            return addLeadingZeros(month2 + 1, 2);
          case "Lo":
            return localize2.ordinalNumber(month2 + 1, {
              unit: "month"
            });
          case "LLL":
            return localize2.month(month2, {
              width: "abbreviated",
              context: "standalone"
            });
          case "LLLLL":
            return localize2.month(month2, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return localize2.month(month2, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      w: function(date2, token, localize2, options2) {
        var week = getUTCWeek(date2, options2);
        if (token === "wo") {
          return localize2.ordinalNumber(week, {
            unit: "week"
          });
        }
        return addLeadingZeros(week, token.length);
      },
      I: function(date2, token, localize2) {
        var isoWeek = getUTCISOWeek(date2);
        if (token === "Io") {
          return localize2.ordinalNumber(isoWeek, {
            unit: "week"
          });
        }
        return addLeadingZeros(isoWeek, token.length);
      },
      d: function(date2, token, localize2) {
        if (token === "do") {
          return localize2.ordinalNumber(date2.getUTCDate(), {
            unit: "date"
          });
        }
        return formatters$3.d(date2, token);
      },
      D: function(date2, token, localize2) {
        var dayOfYear = getUTCDayOfYear(date2);
        if (token === "Do") {
          return localize2.ordinalNumber(dayOfYear, {
            unit: "dayOfYear"
          });
        }
        return addLeadingZeros(dayOfYear, token.length);
      },
      E: function(date2, token, localize2) {
        var dayOfWeek = date2.getUTCDay();
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "EEEEE":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "EEEE":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      e: function(date2, token, localize2, options2) {
        var dayOfWeek = date2.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "e":
            return String(localDayOfWeek);
          case "ee":
            return addLeadingZeros(localDayOfWeek, 2);
          case "eo":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "eee":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "eeeee":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "eeee":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      c: function(date2, token, localize2, options2) {
        var dayOfWeek = date2.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options2.weekStartsOn + 8) % 7 || 7;
        switch (token) {
          case "c":
            return String(localDayOfWeek);
          case "cc":
            return addLeadingZeros(localDayOfWeek, token.length);
          case "co":
            return localize2.ordinalNumber(localDayOfWeek, {
              unit: "day"
            });
          case "ccc":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "standalone"
            });
          case "ccccc":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "standalone"
            });
          case "cccc":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "standalone"
            });
        }
      },
      i: function(date2, token, localize2) {
        var dayOfWeek = date2.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
        switch (token) {
          case "i":
            return String(isoDayOfWeek);
          case "ii":
            return addLeadingZeros(isoDayOfWeek, token.length);
          case "io":
            return localize2.ordinalNumber(isoDayOfWeek, {
              unit: "day"
            });
          case "iii":
            return localize2.day(dayOfWeek, {
              width: "abbreviated",
              context: "formatting"
            });
          case "iiiii":
            return localize2.day(dayOfWeek, {
              width: "narrow",
              context: "formatting"
            });
          case "iiiiii":
            return localize2.day(dayOfWeek, {
              width: "short",
              context: "formatting"
            });
          case "iiii":
          default:
            return localize2.day(dayOfWeek, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      a: function(date2, token, localize2) {
        var hours = date2.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "aaaaa":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      b: function(date2, token, localize2) {
        var hours = date2.getUTCHours();
        var dayPeriodEnumValue;
        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
        }
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "bbbbb":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      B: function(date2, token, localize2) {
        var hours = date2.getUTCHours();
        var dayPeriodEnumValue;
        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "abbreviated",
              context: "formatting"
            });
          case "BBBBB":
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return localize2.dayPeriod(dayPeriodEnumValue, {
              width: "wide",
              context: "formatting"
            });
        }
      },
      h: function(date2, token, localize2) {
        if (token === "ho") {
          var hours = date2.getUTCHours() % 12;
          if (hours === 0)
            hours = 12;
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return formatters$3.h(date2, token);
      },
      H: function(date2, token, localize2) {
        if (token === "Ho") {
          return localize2.ordinalNumber(date2.getUTCHours(), {
            unit: "hour"
          });
        }
        return formatters$3.H(date2, token);
      },
      K: function(date2, token, localize2) {
        var hours = date2.getUTCHours() % 12;
        if (token === "Ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      k: function(date2, token, localize2) {
        var hours = date2.getUTCHours();
        if (hours === 0)
          hours = 24;
        if (token === "ko") {
          return localize2.ordinalNumber(hours, {
            unit: "hour"
          });
        }
        return addLeadingZeros(hours, token.length);
      },
      m: function(date2, token, localize2) {
        if (token === "mo") {
          return localize2.ordinalNumber(date2.getUTCMinutes(), {
            unit: "minute"
          });
        }
        return formatters$3.m(date2, token);
      },
      s: function(date2, token, localize2) {
        if (token === "so") {
          return localize2.ordinalNumber(date2.getUTCSeconds(), {
            unit: "second"
          });
        }
        return formatters$3.s(date2, token);
      },
      S: function(date2, token) {
        return formatters$3.S(date2, token);
      },
      X: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        if (timezoneOffset === 0) {
          return "Z";
        }
        switch (token) {
          case "X":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "XXXX":
          case "XX":
            return formatTimezone(timezoneOffset);
          case "XXXXX":
          case "XXX":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      x: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "x":
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          case "xxxx":
          case "xx":
            return formatTimezone(timezoneOffset);
          case "xxxxx":
          case "xxx":
          default:
            return formatTimezone(timezoneOffset, ":");
        }
      },
      O: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "O":
          case "OO":
          case "OOO":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "OOOO":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      z: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timezoneOffset = originalDate.getTimezoneOffset();
        switch (token) {
          case "z":
          case "zz":
          case "zzz":
            return "GMT" + formatTimezoneShort(timezoneOffset, ":");
          case "zzzz":
          default:
            return "GMT" + formatTimezone(timezoneOffset, ":");
        }
      },
      t: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timestamp = Math.floor(originalDate.getTime() / 1e3);
        return addLeadingZeros(timestamp, token.length);
      },
      T: function(date2, token, _localize, options2) {
        var originalDate = options2._originalDate || date2;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };
    formatters$1 = formatters;
    longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };
    longFormatters$1 = longFormatters;
    protectedDayOfYearTokens = ["D", "DD"];
    protectedWeekYearTokens = ["YY", "YYYY"];
    formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
    longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    escapedStringRegExp = /^'([^]*?)'?$/;
    doubleQuoteRegExp = /''/g;
    unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    __extends$1t = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __rest$1 = globalThis && globalThis.__rest || function(s3, e3) {
      var t2 = {};
      for (var p in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p) && e3.indexOf(p) < 0)
          t2[p] = s3[p];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
          if (e3.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
            t2[p[i2]] = s3[p[i2]];
        }
      return t2;
    };
    __spreadArrays$j = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    CartesianScales = function(_super) {
      __extends$1t(CartesianScales2, _super);
      function CartesianScales2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.scaleTypes = {
          top: null,
          right: null,
          bottom: null,
          left: null
        };
        _this.scales = {
          top: null,
          right: null,
          bottom: null,
          left: null
        };
        return _this;
      }
      CartesianScales2.prototype.getDomainAxisPosition = function(_a22) {
        var _b = (_a22 === void 0 ? {} : _a22).datum, datum2 = _b === void 0 ? null : _b;
        var _c;
        if (this.dualAxes && datum2) {
          var options2 = this.model.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          var axesOptions = Tools.getProperty(options2, "axes", this.secondaryDomainAxisPosition);
          var dataset = datum2[groupMapsTo];
          if (((_c = axesOptions) === null || _c === void 0 ? void 0 : _c.correspondingDatasets) && axesOptions.correspondingDatasets.includes(dataset)) {
            return this.secondaryDomainAxisPosition;
          }
        }
        return this.domainAxisPosition;
      };
      CartesianScales2.prototype.getRangeAxisPosition = function(_a22) {
        var _b = _a22 === void 0 ? {} : _a22, _c = _b.datum, datum2 = _c === void 0 ? null : _c, _d2 = _b.groups, groups = _d2 === void 0 ? null : _d2;
        var _e;
        if (this.dualAxes) {
          var options2 = this.model.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          var axisOptions = Tools.getProperty(options2, "axes", this.secondaryRangeAxisPosition);
          var dataset = void 0;
          if (datum2 !== null) {
            dataset = datum2[groupMapsTo];
          } else if (groups && groups.length > 0) {
            dataset = groups[0];
          }
          if (((_e = axisOptions) === null || _e === void 0 ? void 0 : _e.correspondingDatasets) && axisOptions.correspondingDatasets.includes(dataset)) {
            return this.secondaryRangeAxisPosition;
          }
        }
        return this.rangeAxisPosition;
      };
      CartesianScales2.prototype.getAxisOptions = function(position) {
        return Tools.getProperty(this.model.getOptions(), "axes", position);
      };
      CartesianScales2.prototype.getDomainAxisOptions = function() {
        var domainAxisPosition = this.getDomainAxisPosition();
        return this.getAxisOptions(domainAxisPosition);
      };
      CartesianScales2.prototype.getRangeAxisOptions = function() {
        var rangeAxisPosition = this.getRangeAxisPosition();
        return this.getAxisOptions(rangeAxisPosition);
      };
      CartesianScales2.prototype.getScaleLabel = function(position) {
        var axisOptions = this.getAxisOptions(position);
        var title = axisOptions.title;
        if (!title) {
          if (position === AxisPositions.BOTTOM || position === AxisPositions.TOP) {
            return "x-value";
          }
          return "y-value";
        }
        return title;
      };
      CartesianScales2.prototype.getDomainLabel = function() {
        return this.getScaleLabel(this.getDomainAxisPosition());
      };
      CartesianScales2.prototype.getRangeLabel = function() {
        return this.getScaleLabel(this.getRangeAxisPosition());
      };
      CartesianScales2.prototype.update = function(animate) {
        var _this = this;
        this.determineAxisDuality();
        this.findDomainAndRangeAxes();
        this.determineOrientation();
        var axisPositions = Object.keys(AxisPositions).map(function(axisPositionKey) {
          return AxisPositions[axisPositionKey];
        });
        axisPositions.forEach(function(axisPosition) {
          _this.scales[axisPosition] = _this.createScale(axisPosition);
        });
      };
      CartesianScales2.prototype.findDomainAndRangeAxes = function() {
        var verticalAxesPositions = this.findVerticalAxesPositions();
        var horizontalAxesPositions = this.findHorizontalAxesPositions();
        var domainAndRangeAxesPositions = this.findDomainAndRangeAxesPositions(verticalAxesPositions, horizontalAxesPositions);
        this.domainAxisPosition = domainAndRangeAxesPositions.primaryDomainAxisPosition;
        this.rangeAxisPosition = domainAndRangeAxesPositions.primaryRangeAxisPosition;
        if (this.isDualAxes()) {
          this.secondaryDomainAxisPosition = domainAndRangeAxesPositions.secondaryDomainAxisPosition;
          this.secondaryRangeAxisPosition = domainAndRangeAxesPositions.secondaryRangeAxisPosition;
        }
      };
      CartesianScales2.prototype.determineOrientation = function() {
        if ((this.rangeAxisPosition === AxisPositions.LEFT || this.rangeAxisPosition === AxisPositions.RIGHT) && (this.domainAxisPosition === AxisPositions.BOTTOM || this.domainAxisPosition === AxisPositions.TOP)) {
          this.orientation = CartesianOrientations.VERTICAL;
        } else {
          this.orientation = CartesianOrientations.HORIZONTAL;
        }
      };
      CartesianScales2.prototype.isDualAxes = function() {
        return this.dualAxes;
      };
      CartesianScales2.prototype.determineAxisDuality = function() {
        var _a22, _b, _c, _d2;
        var options2 = this.model.getOptions();
        var axesOptions = Tools.getProperty(options2, "axes");
        if (((_a22 = axesOptions[AxisPositions.LEFT]) === null || _a22 === void 0 ? void 0 : _a22.correspondingDatasets) && axesOptions[AxisPositions.RIGHT] || ((_b = axesOptions[AxisPositions.RIGHT]) === null || _b === void 0 ? void 0 : _b.correspondingDatasets) && axesOptions[AxisPositions.LEFT] || ((_c = axesOptions[AxisPositions.TOP]) === null || _c === void 0 ? void 0 : _c.correspondingDatasets) && axesOptions[AxisPositions.BOTTOM] || ((_d2 = axesOptions[AxisPositions.BOTTOM]) === null || _d2 === void 0 ? void 0 : _d2.correspondingDatasets) && axesOptions[AxisPositions.TOP]) {
          this.dualAxes = true;
        }
      };
      CartesianScales2.prototype.getCustomDomainValuesByposition = function(axisPosition) {
        var domain = Tools.getProperty(this.model.getOptions(), "axes", axisPosition, "domain");
        if (domain && !Array.isArray(domain)) {
          throw new Error("Domain in " + axisPosition + " axis is not a valid array");
        }
        if (Array.isArray(domain)) {
          if ((this.scaleTypes[axisPosition] === ScaleTypes.LINEAR || this.scaleTypes[axisPosition] === ScaleTypes.TIME) && domain.length !== 2) {
            throw new Error("There can only be 2 elements in domain for scale type: " + this.scaleTypes[axisPosition]);
          }
        }
        return domain;
      };
      CartesianScales2.prototype.getOrientation = function() {
        return this.orientation;
      };
      CartesianScales2.prototype.getScaleByPosition = function(axisPosition) {
        return this.scales[axisPosition];
      };
      CartesianScales2.prototype.getScaleTypeByPosition = function(axisPosition) {
        return this.scaleTypes[axisPosition];
      };
      CartesianScales2.prototype.getDomainAxisScaleType = function() {
        var domainAxisPosition = this.getDomainAxisPosition();
        return this.getScaleTypeByPosition(domainAxisPosition);
      };
      CartesianScales2.prototype.getRangeAxisScaleType = function() {
        var rangeAxisPosition = this.getRangeAxisPosition();
        return this.getScaleTypeByPosition(rangeAxisPosition);
      };
      CartesianScales2.prototype.getDomainScale = function() {
        return this.scales[this.domainAxisPosition];
      };
      CartesianScales2.prototype.getRangeScale = function() {
        return this.scales[this.rangeAxisPosition];
      };
      CartesianScales2.prototype.getMainXAxisPosition = function() {
        var possibleXAxisPositions = [
          AxisPositions.BOTTOM,
          AxisPositions.TOP
        ];
        return [this.domainAxisPosition, this.rangeAxisPosition].find(function(position) {
          return possibleXAxisPositions.indexOf(position) > -1;
        });
      };
      CartesianScales2.prototype.getMainYAxisPosition = function() {
        var possibleYAxisPositions = [
          AxisPositions.LEFT,
          AxisPositions.RIGHT
        ];
        return [this.domainAxisPosition, this.rangeAxisPosition].find(function(position) {
          return possibleYAxisPositions.indexOf(position) > -1;
        });
      };
      CartesianScales2.prototype.getMainXScale = function() {
        return this.scales[this.getMainXAxisPosition()];
      };
      CartesianScales2.prototype.getMainYScale = function() {
        return this.scales[this.getMainYAxisPosition()];
      };
      CartesianScales2.prototype.getValueFromScale = function(scale, scaleType, axisPosition, datum2, index2) {
        var options2 = this.model.getOptions();
        var axesOptions = Tools.getProperty(options2, "axes");
        var axisOptions = axesOptions[axisPosition];
        var mapsTo = axisOptions.mapsTo;
        var value2 = Tools.getProperty(datum2, mapsTo) !== null ? datum2[mapsTo] : datum2;
        var scaledValue;
        switch (scaleType) {
          case ScaleTypes.LABELS:
            scaledValue = scale(value2) + scale.step() / 2;
            break;
          case ScaleTypes.TIME:
            scaledValue = scale(new Date(value2));
            break;
          default:
            scaledValue = scale(value2);
        }
        return scaledValue;
      };
      CartesianScales2.prototype.getBoundedScaledValues = function(datum2, index2) {
        var bounds = this.model.getOptions().bounds;
        var axisPosition = this.getRangeAxisPosition({ datum: datum2 });
        var scale = this.scales[axisPosition];
        var options2 = this.model.getOptions();
        var axesOptions = Tools.getProperty(options2, "axes");
        var axisOptions = axesOptions[axisPosition];
        var mapsTo = axisOptions.mapsTo;
        var value2 = datum2[mapsTo] !== void 0 ? datum2[mapsTo] : datum2;
        var boundedValues = [
          scale(Tools.getProperty(datum2, bounds.upperBoundMapsTo) !== null ? datum2[bounds.upperBoundMapsTo] : value2),
          scale(Tools.getProperty(datum2, bounds.lowerBoundMapsTo) !== null ? datum2[bounds.lowerBoundMapsTo] : value2)
        ];
        return boundedValues;
      };
      CartesianScales2.prototype.getValueThroughAxisPosition = function(axisPosition, datum2, index2) {
        var scaleType = this.scaleTypes[axisPosition];
        var scale = this.scales[axisPosition];
        return this.getValueFromScale(scale, scaleType, axisPosition, datum2, index2);
      };
      CartesianScales2.prototype.getDomainValue = function(d, i2) {
        var axisPosition = this.getDomainAxisPosition({ datum: d });
        return this.getValueThroughAxisPosition(axisPosition, d, i2);
      };
      CartesianScales2.prototype.getRangeValue = function(d, i2) {
        var axisPosition = this.getRangeAxisPosition({ datum: d });
        return this.getValueThroughAxisPosition(axisPosition, d, i2);
      };
      CartesianScales2.prototype.getMainXScaleType = function() {
        return this.getScaleTypeByPosition(this.getMainXAxisPosition());
      };
      CartesianScales2.prototype.getMainYScaleType = function() {
        return this.getScaleTypeByPosition(this.getMainYAxisPosition());
      };
      CartesianScales2.prototype.getDomainIdentifier = function(datum2) {
        var options2 = this.model.getOptions();
        return Tools.getProperty(options2, "axes", this.getDomainAxisPosition({ datum: datum2 }), "mapsTo");
      };
      CartesianScales2.prototype.getRangeIdentifier = function(datum2) {
        var options2 = this.model.getOptions();
        return Tools.getProperty(options2, "axes", this.getRangeAxisPosition({ datum: datum2 }), "mapsTo");
      };
      CartesianScales2.prototype.extendsDomain = function(axisPosition, domain) {
        var options2 = this.model.getOptions();
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        if (axisOptions.scaleType === ScaleTypes.TIME) {
          var spaceToAddToEdges = Tools.getProperty(options2, "timeScale", "addSpaceOnEdges");
          return addSpacingToTimeDomain(domain, spaceToAddToEdges);
        } else {
          return addSpacingToContinuousDomain(domain, axis$1.paddingRatio, axisOptions.scaleType);
        }
      };
      CartesianScales2.prototype.findVerticalAxesPositions = function() {
        var options2 = this.model.getOptions();
        var axesOptions = Tools.getProperty(options2, "axes");
        var dualAxes = this.isDualAxes();
        if (Tools.getProperty(axesOptions, AxisPositions.LEFT) === null && Tools.getProperty(axesOptions, AxisPositions.RIGHT) !== null || Tools.getProperty(axesOptions, AxisPositions.RIGHT, "main") === true || dualAxes && Tools.getProperty(axesOptions, AxisPositions.LEFT, "correspondingDatasets")) {
          return {
            primary: AxisPositions.RIGHT,
            secondary: AxisPositions.LEFT
          };
        }
        return { primary: AxisPositions.LEFT, secondary: AxisPositions.RIGHT };
      };
      CartesianScales2.prototype.findHorizontalAxesPositions = function() {
        var options2 = this.model.getOptions();
        var axesOptions = Tools.getProperty(options2, "axes");
        var dualAxes = this.isDualAxes();
        if (Tools.getProperty(axesOptions, AxisPositions.BOTTOM) === null && Tools.getProperty(axesOptions, AxisPositions.TOP) !== null || Tools.getProperty(axesOptions, AxisPositions.TOP, "main") === true || dualAxes && Tools.getProperty(axesOptions, AxisPositions.BOTTOM, "correspondingDatasets")) {
          return {
            primary: AxisPositions.TOP,
            secondary: AxisPositions.BOTTOM
          };
        }
        return { primary: AxisPositions.BOTTOM, secondary: AxisPositions.TOP };
      };
      CartesianScales2.prototype.findDomainAndRangeAxesPositions = function(verticalAxesPositions, horizontalAxesPositions) {
        var options2 = this.model.getOptions();
        var mainVerticalAxisOptions = Tools.getProperty(options2, "axes", verticalAxesPositions.primary);
        var mainHorizontalAxisOptions = Tools.getProperty(options2, "axes", horizontalAxesPositions.primary);
        var mainVerticalScaleType = mainVerticalAxisOptions.scaleType || ScaleTypes.LINEAR;
        var mainHorizontalScaleType = mainHorizontalAxisOptions.scaleType || ScaleTypes.LINEAR;
        var result = {
          primaryDomainAxisPosition: null,
          secondaryDomainAxisPosition: null,
          primaryRangeAxisPosition: null,
          secondaryRangeAxisPosition: null
        };
        result.primaryDomainAxisPosition = horizontalAxesPositions.primary;
        result.primaryRangeAxisPosition = verticalAxesPositions.primary;
        result.secondaryDomainAxisPosition = horizontalAxesPositions.secondary;
        result.secondaryRangeAxisPosition = verticalAxesPositions.secondary;
        if (!(mainHorizontalScaleType === ScaleTypes.LABELS || mainHorizontalScaleType === ScaleTypes.TIME) && mainVerticalScaleType === ScaleTypes.LABELS || mainVerticalScaleType === ScaleTypes.TIME) {
          result.primaryDomainAxisPosition = verticalAxesPositions.primary;
          result.primaryRangeAxisPosition = horizontalAxesPositions.primary;
          result.secondaryDomainAxisPosition = verticalAxesPositions.secondary;
          result.secondaryRangeAxisPosition = horizontalAxesPositions.secondary;
        }
        return result;
      };
      CartesianScales2.prototype.getScaleDomain = function(axisPosition) {
        var options2 = this.model.getOptions();
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        var bounds = Tools.getProperty(options2, "bounds");
        var includeZero = axisOptions.includeZero;
        var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
        if (this.model.isDataEmpty()) {
          return [];
        }
        if (axisOptions.binned) {
          var bins = this.model.getBinConfigurations().bins;
          return [0, max$3(bins, function(d) {
            return d.length;
          })];
        } else if (axisOptions.limitDomainToBins) {
          var bins = this.model.getBinConfigurations().bins;
          var stackKeys = this.model.getStackKeys({ bins });
          return [
            stackKeys[0].split("-")[0],
            stackKeys[stackKeys.length - 1].split("-")[1]
          ];
        }
        var displayData = this.model.getDisplayData();
        var extendLinearDomainBy = axisOptions.extendLinearDomainBy, mapsTo = axisOptions.mapsTo, percentage = axisOptions.percentage, thresholds = axisOptions.thresholds;
        var _a22 = axis$1.ratio, ratioReference = _a22.reference, ratioCompareTo = _a22.compareTo;
        if (axisOptions.domain) {
          if (scaleType === ScaleTypes.LABELS) {
            return axisOptions.domain;
          } else if (scaleType === ScaleTypes.TIME) {
            axisOptions.domain = axisOptions.domain.map(function(d) {
              return d.getTime === void 0 ? new Date(d) : d;
            });
          }
          return this.extendsDomain(axisPosition, axisOptions.domain);
        }
        if (percentage) {
          return [0, 100];
        }
        if (axisOptions && scaleType === ScaleTypes.LABELS) {
          return Tools.removeArrayDuplicates(displayData.map(function(d) {
            return d[mapsTo];
          }));
        }
        var domain;
        var allDataValues;
        var dataGroupNames = this.model.getDataGroupNames();
        if (scaleType === ScaleTypes.LABELS_RATIO) {
          return displayData.map(function(datum2) {
            return datum2[ratioReference] + "/" + datum2[ratioCompareTo];
          });
        } else if (scaleType === ScaleTypes.TIME) {
          allDataValues = displayData.map(function(datum2) {
            return +new Date(datum2[mapsTo]);
          });
        } else if (bounds && options2.axes) {
          allDataValues = [];
          displayData.forEach(function(datum2) {
            allDataValues.push(datum2[mapsTo]);
            if (datum2[bounds.upperBoundMapsTo]) {
              allDataValues.push(datum2[bounds.upperBoundMapsTo]);
            }
            if (datum2[bounds.lowerBoundMapsTo]) {
              allDataValues.push(datum2[bounds.lowerBoundMapsTo]);
            }
          });
        } else if (axisOptions.stacked === true && dataGroupNames && axisPosition === this.getRangeAxisPosition()) {
          var groupMapsTo_1 = options2.data.groupMapsTo;
          var dataValuesGroupedByKeys = this.model.getDataValuesGroupedByKeys({
            groups: dataGroupNames
          });
          var nonStackedGroupsData = displayData.filter(function(datum2) {
            return !dataGroupNames.includes(datum2[groupMapsTo_1]);
          });
          var stackedValues_1 = [];
          dataValuesGroupedByKeys.forEach(function(dataValues) {
            dataValues.sharedStackKey;
            var numericalValues = __rest$1(dataValues, ["sharedStackKey"]);
            var positiveSum = 0, negativeSum = 0;
            Object.values(numericalValues).forEach(function(value2) {
              if (!isNaN(value2)) {
                if (value2 < 0) {
                  negativeSum += value2;
                } else {
                  positiveSum += value2;
                }
              }
            });
            stackedValues_1.push([negativeSum, positiveSum]);
          });
          allDataValues = __spreadArrays$j(Tools.flatten(stackedValues_1), nonStackedGroupsData.map(function(datum2) {
            return datum2[mapsTo];
          }));
        } else {
          allDataValues = [];
          displayData.forEach(function(datum2) {
            var value2 = datum2[mapsTo];
            if (Array.isArray(value2) && value2.length === 2) {
              allDataValues.push(value2[0]);
              allDataValues.push(value2[1]);
            } else {
              if (extendLinearDomainBy) {
                allDataValues.push(Math.max(datum2[mapsTo], datum2[extendLinearDomainBy]));
              }
              allDataValues.push(value2);
            }
          });
        }
        if (scaleType !== ScaleTypes.TIME && scaleType !== ScaleTypes.LOG && includeZero) {
          allDataValues.push(0);
        }
        if (thresholds && thresholds.length > 0) {
          thresholds.forEach(function(threshold) {
            var thresholdValue = Tools.getProperty(threshold, "value");
            if (thresholdValue !== null)
              allDataValues.push(thresholdValue);
          });
        }
        domain = extent(allDataValues);
        domain = this.extendsDomain(axisPosition, domain);
        return domain;
      };
      CartesianScales2.prototype.createScale = function(axisPosition) {
        var options2 = this.model.getOptions();
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        if (!axisOptions) {
          return null;
        }
        var scaleType = Tools.getProperty(axisOptions, "scaleType") || ScaleTypes.LINEAR;
        this.scaleTypes[axisPosition] = scaleType;
        var scale;
        if (scaleType === ScaleTypes.TIME) {
          scale = time();
        } else if (scaleType === ScaleTypes.LOG) {
          scale = log().base(axisOptions.base || 10);
        } else if (scaleType === ScaleTypes.LABELS || scaleType === ScaleTypes.LABELS_RATIO) {
          scale = band();
        } else {
          scale = linear();
        }
        scale.domain(this.getScaleDomain(axisPosition));
        return scale;
      };
      CartesianScales2.prototype.getHighestDomainThreshold = function() {
        var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
        var domainAxisPosition = this.getDomainAxisPosition();
        var thresholds = axesOptions[domainAxisPosition].thresholds;
        if (!Array.isArray(thresholds) || Array.isArray(thresholds) && !thresholds.length) {
          return null;
        }
        var domainScale = this.getDomainScale();
        var highestThreshold = thresholds.sort(function(a, b) {
          return b.value - a.value;
        })[0];
        var scaleType = this.getScaleTypeByPosition(domainAxisPosition);
        if (scaleType === ScaleTypes.TIME && (typeof highestThreshold.value === "string" || highestThreshold.value.getTime === void 0)) {
          highestThreshold.value = new Date(highestThreshold.value);
        }
        return {
          threshold: highestThreshold,
          scaleValue: domainScale(highestThreshold.value)
        };
      };
      CartesianScales2.prototype.getHighestRangeThreshold = function() {
        var axesOptions = Tools.getProperty(this.model.getOptions(), "axes");
        var rangeAxisPosition = this.getRangeAxisPosition();
        var thresholds = axesOptions[rangeAxisPosition].thresholds;
        if (!Array.isArray(thresholds) || Array.isArray(thresholds) && !thresholds.length) {
          return null;
        }
        var rangeScale = this.getRangeScale();
        var highestThreshold = thresholds.sort(function(a, b) {
          return b.value - a.value;
        })[0];
        return {
          threshold: highestThreshold,
          scaleValue: rangeScale(highestThreshold.value)
        };
      };
      return CartesianScales2;
    }(Service);
    __extends$1s = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Curves = function(_super) {
      __extends$1s(Curves2, _super);
      function Curves2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.curveTypes = {
          curveLinear,
          curveLinearClosed,
          curveBasis,
          curveBasisClosed,
          curveBasisOpen,
          curveBundle,
          curveCardinal,
          curveCardinalClosed,
          curveCardinalOpen,
          curveCatmullRom,
          curveCatmullRomClosed,
          curveCatmullRomOpen,
          curveMonotoneX: monotoneX,
          curveMonotoneY: monotoneY,
          curveNatural,
          curveStep,
          curveStepAfter: stepAfter,
          curveStepBefore: stepBefore
        };
        return _this;
      }
      Curves2.prototype.getD3Curve = function() {
        var curveName = "curveLinear";
        var curveOptions = this.model.getOptions().curve;
        if (curveOptions) {
          if (typeof curveOptions === "string") {
            curveName = curveOptions;
          } else {
            curveName = curveOptions.name;
          }
        }
        if (this.curveTypes[curveName]) {
          var curve_1 = this.curveTypes[curveName];
          if (curveOptions) {
            Object.keys(curveOptions).forEach(function(optionName) {
              if (curve_1[optionName]) {
                curve_1 = curve_1[optionName](curveOptions[optionName]);
              }
            });
          }
          return curve_1;
        }
        console.warn("The curve type '" + curveName + "' is invalid, using 'curveLinear' instead");
        return this.curveTypes["curveLinear"];
      };
      return Curves2;
    }(Service);
    __extends$1r = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Zoom = function(_super) {
      __extends$1r(Zoom2, _super);
      function Zoom2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Zoom2.prototype.isZoomBarEnabled = function() {
        if (!this.services.cartesianScales) {
          return false;
        }
        if (!Tools.getProperty(this.model.getOptions(), "zoomBar", "top", "enabled")) {
          return false;
        }
        this.services.cartesianScales.findDomainAndRangeAxes();
        var mainXAxisPosition = this.services.cartesianScales.getMainXAxisPosition();
        var mainXScaleType = Tools.getProperty(this.model.getOptions(), "axes", mainXAxisPosition, "scaleType");
        return mainXAxisPosition === AxisPositions.BOTTOM && mainXScaleType === ScaleTypes.TIME;
      };
      Zoom2.prototype.getZoomBarData = function() {
        var customZoomBarData = this.model.getZoomBarData();
        if (customZoomBarData && customZoomBarData.length > 1) {
          return customZoomBarData;
        } else {
          return this.model.getDisplayData();
        }
      };
      Zoom2.prototype.getDefaultZoomBarDomain = function(zoomBarData) {
        var allZoomBarData = zoomBarData || this.services.zoom.getZoomBarData();
        var cartesianScales = this.services.cartesianScales;
        var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
        var domainIdentifier = cartesianScales.getDomainIdentifier();
        var customDomain = Tools.getProperty(this.model.getOptions(), "axes", mainXAxisPosition, "domain");
        if (Array.isArray(customDomain) && customDomain.length === 2) {
          return customDomain;
        }
        return cartesianScales.extendsDomain(mainXAxisPosition, extent(allZoomBarData, function(d) {
          return d[domainIdentifier];
        }));
      };
      Zoom2.prototype.handleDomainChange = function(newDomain, configs) {
        if (configs === void 0) {
          configs = { dispatchEvent: true };
        }
        this.model.set({ zoomDomain: newDomain }, { animate: false });
        if (configs.dispatchEvent) {
          this.services.events.dispatchEvent(Events$1.ZoomDomain.CHANGE, {
            newDomain
          });
        }
      };
      Zoom2.prototype.getZoomRatio = function() {
        return Tools.getProperty(this.model.getOptions(), "zoomBar", "zoomRatio");
      };
      Zoom2.prototype.filterDataForRangeAxis = function(displayData, configs) {
        var zoomDomain = this.model.get("zoomDomain");
        var mergedConfigs = Object.assign({ stacked: false }, configs);
        var shouldUpdateRangeAxis = Tools.getProperty(this.model.getOptions(), "zoomBar", "updateRangeAxis");
        if (this.isZoomBarEnabled() && shouldUpdateRangeAxis && zoomDomain) {
          var domainIdentifier_1 = mergedConfigs.stacked ? "sharedStackKey" : this.services.cartesianScales.getDomainIdentifier();
          var filteredData = displayData.filter(function(datum2) {
            return new Date(datum2[domainIdentifier_1]) >= zoomDomain[0] && new Date(datum2[domainIdentifier_1]) <= zoomDomain[1];
          });
          if (filteredData.length > 0) {
            return filteredData;
          }
        }
        return displayData;
      };
      Zoom2.prototype.zoomIn = function(zoomRatio) {
        if (zoomRatio === void 0) {
          zoomRatio = this.getZoomRatio();
        }
        var currentZoomDomain = this.model.get("zoomDomain");
        var handleWidth = zoomBar.handleWidth;
        var xScale = this.services.cartesianScales.getMainXScale().copy();
        xScale.domain(this.getDefaultZoomBarDomain());
        var currentX0 = xScale(currentZoomDomain[0]);
        var currentX1 = xScale(currentZoomDomain[1]);
        if (currentX1 - currentX0 < handleWidth + 1) {
          return;
        }
        var fullRange = xScale.range();
        var gap = currentX1 - currentX0;
        var diff = Math.min((fullRange[1] - fullRange[0]) / 2 * (zoomRatio / 2), gap / 2);
        var newX0 = currentX0 + diff;
        var newX1 = currentX1 - diff;
        if (newX0 >= newX1) {
          newX0 = currentX0 + gap / 2 - handleWidth / 2;
          newX1 = currentX1 - gap / 2 + handleWidth / 2;
        }
        var newDomain = [xScale.invert(newX0), xScale.invert(newX1)];
        if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
          this.handleDomainChange(newDomain);
        }
      };
      Zoom2.prototype.zoomOut = function(zoomRatio) {
        if (zoomRatio === void 0) {
          zoomRatio = this.getZoomRatio();
        }
        var currentZoomDomain = this.model.get("zoomDomain");
        var xScale = this.services.cartesianScales.getMainXScale().copy();
        xScale.domain(this.getDefaultZoomBarDomain());
        var currentX0 = xScale(currentZoomDomain[0]);
        var currentX1 = xScale(currentZoomDomain[1]);
        var fullRange = xScale.range();
        var diff = (fullRange[1] - fullRange[0]) / 2 * (zoomRatio / 2);
        var newX0 = Math.max(currentX0 - diff, fullRange[0]);
        var newX1 = Math.min(currentX1 + diff, fullRange[1]);
        var newDomain = [xScale.invert(newX0), xScale.invert(newX1)];
        if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
          this.handleDomainChange(newDomain);
        }
      };
      Zoom2.prototype.resetZoomDomain = function() {
        var currentZoomDomain = this.model.get("zoomDomain");
        var newDomain = this.getDefaultZoomBarDomain();
        if (currentZoomDomain[0].valueOf() !== newDomain[0].valueOf() || currentZoomDomain[1].valueOf() !== newDomain[1].valueOf()) {
          this.handleDomainChange(newDomain);
        }
      };
      Zoom2.prototype.isMinZoomDomain = function() {
        var currentZoomDomain = this.model.get("zoomDomain");
        var maxZoomDomain = this.getDefaultZoomBarDomain();
        if (!currentZoomDomain || !maxZoomDomain) {
          return false;
        }
        var currentZoomDomainPeriod = currentZoomDomain[1].valueOf() - currentZoomDomain[0].valueOf();
        var maxZoomDomainPeriod = maxZoomDomain[1].valueOf() - maxZoomDomain[0].valueOf();
        var minZoomRatio = Tools.getProperty(this.model.getOptions(), "zoomBar", "minZoomRatio");
        if (currentZoomDomainPeriod / maxZoomDomainPeriod < minZoomRatio) {
          return true;
        }
        return false;
      };
      Zoom2.prototype.isMaxZoomDomain = function() {
        var currentZoomDomain = this.model.get("zoomDomain");
        var maxZoomDomain = this.getDefaultZoomBarDomain();
        if (currentZoomDomain && maxZoomDomain && currentZoomDomain[0].valueOf() === maxZoomDomain[0].valueOf() && currentZoomDomain[1].valueOf() === maxZoomDomain[1].valueOf()) {
          return true;
        }
        return false;
      };
      Zoom2.prototype.isEmptyState = function() {
        return this.getZoomBarData().length === 0;
      };
      Zoom2.prototype.isZoomBarLoading = function(position) {
        return Tools.getProperty(this.model.getOptions(), "zoomBar", position, "loading");
      };
      Zoom2.prototype.isZoomBarLocked = function(position) {
        return Tools.getProperty(this.model.getOptions(), "zoomBar", position, "locked");
      };
      return Zoom2;
    }(Service);
    __extends$1q = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CanvasZoom = function(_super) {
      __extends$1q(CanvasZoom2, _super);
      function CanvasZoom2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      CanvasZoom2.prototype.zoomIn = function(focal, canvasElements, zoomSettings) {
        var x22;
        var y2;
        var zoomLevel;
        var settings2 = zoomSettings ? zoomSettings : canvasZoomSettings;
        if (focal) {
          x22 = focal.x;
          y2 = focal.y;
          zoomLevel = 2;
        }
        var _a22 = DOMUtils.getSVGElementSize(this.services.domUtils.getHolder(), {
          useClientDimensions: true
        }), width = _a22.width, height = _a22.height;
        canvasElements.transition().duration(settings2.duration).ease(settings2.ease).attr("transform", "translate(" + width / 2 + ", " + height / 2 + ") scale(" + zoomLevel + ") translate(" + -x22 + "," + -y2 + ")");
        this.services.events.dispatchEvent(Events$1.CanvasZoom.CANVAS_ZOOM_IN, {
          element: select(focal)
        });
      };
      CanvasZoom2.prototype.zoomOut = function(canvasElements, zoomSettings) {
        var settings2 = zoomSettings ? zoomSettings : canvasZoomSettings;
        canvasElements.transition().duration(settings2.duration).ease(settings2.ease).attr("transform", "");
        this.services.events.dispatchEvent(Events$1.CanvasZoom.CANVAS_ZOOM_OUT);
      };
      return CanvasZoom2;
    }(Service);
    Component = function() {
      function Component2(model, services, configs) {
        this.renderType = RenderTypes.HTML;
        this.configs = {};
        this.model = model;
        this.services = services;
        if (configs) {
          this.configs = configs;
          if (this.configs.id) {
            var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
            this.id = chartprefix + "--" + this.configs.id;
          }
        }
        if (!this.parent) {
          this.setParent(select(this.services.domUtils.getMainContainer()));
        }
      }
      Component2.prototype.init = function() {
      };
      Component2.prototype.render = function(animate) {
        console.error("render() method is not implemented");
      };
      Component2.prototype.destroy = function() {
      };
      Component2.prototype.setModel = function(newObj) {
        this.model = newObj;
      };
      Component2.prototype.setServices = function(newObj) {
        this.services = newObj;
      };
      Component2.prototype.setParent = function(parent) {
        var oldParent = this.parent;
        this.parent = parent;
        if (oldParent && oldParent.node() === parent.node()) {
          return;
        }
        if (this.type) {
          var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
          this.parent.classed(settings$1.prefix + "--" + chartprefix + "--" + this.type, true);
          if (oldParent) {
            oldParent.classed(settings$1.prefix + "--" + chartprefix + "--" + this.type, false);
          }
        }
      };
      Component2.prototype.getParent = function() {
        return this.parent;
      };
      Component2.prototype.getComponentContainer = function(configs) {
        if (configs === void 0) {
          configs = { withinChartClip: false };
        }
        if (this.type) {
          var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
          var idSelector = this.id ? "#" + this.id : "";
          var container = DOMUtils.appendOrSelect(this.parent, (this.renderType === RenderTypes.SVG ? "svg" : "div") + idSelector + "." + settings$1.prefix + "--" + chartprefix + "--" + this.type);
          if (configs.withinChartClip) {
            var chartClipId = this.model.get("chartClipId");
            if (chartClipId) {
              var chartClipSelection = select("#" + chartClipId);
              var chartClipRectSelection = chartClipSelection.select("rect");
              if (chartClipRectSelection.size() !== 0 && parseFloat(chartClipRectSelection.attr("height")) > 0) {
                container.attr("clip-path", "url(#" + chartClipId + ")");
              }
            }
          }
          return container.attr("width", "100%").attr("height", "100%");
        }
        return this.parent;
      };
      Component2.prototype.getOptions = function() {
        if (this.configs.options) {
          var options2 = Tools.merge({}, this.model.getOptions(), this.configs.options);
          return options2;
        }
        return this.model.getOptions();
      };
      return Component2;
    }();
    __extends$1p = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Legend = function(_super) {
      __extends$1p(Legend2, _super);
      function Legend2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "legend";
        _this.renderType = RenderTypes.HTML;
        return _this;
      }
      Legend2.prototype.render = function() {
        var _this = this;
        var options2 = this.getOptions();
        var legendOptions = Tools.getProperty(options2, "legend");
        var alignment = Tools.getProperty(legendOptions, "alignment");
        var legendOrientation = Tools.getProperty(options2, "legend", "orientation");
        var dataGroups = this.model.getDataGroups();
        var DISABLED = legend$1.items.status.DISABLED;
        var hasDeactivatedItems = dataGroups.some(function(dataGroup) {
          return dataGroup.status === DISABLED;
        });
        var userProvidedOrder = Tools.getProperty(legendOptions, "order");
        var svg = this.getComponentContainer().classed("center-aligned", alignment === Alignments.CENTER).classed("right-aligned", alignment === Alignments.RIGHT).classed(legendOrientation, true).classed("has-deactivated-items", hasDeactivatedItems).attr("role", Roles.GROUP).attr("aria-label", "Data groups").attr("data-name", "legend-items");
        if (userProvidedOrder) {
          dataGroups = this.sortDataGroups(dataGroups, userProvidedOrder);
        }
        var legendItems = svg.selectAll("div.legend-item").data(dataGroups, function(dataGroup) {
          return dataGroup.name;
        });
        var addedLegendItems = legendItems.enter().append("div").attr("class", "legend-item");
        addedLegendItems.merge(svg.selectAll("div.legend-item")).classed("active", function(d, i2) {
          return d.status === legend$1.items.status.ACTIVE;
        });
        var legendClickable = Tools.getProperty(this.getOptions(), "legend", "clickable");
        svg.classed("clickable", legendClickable && dataGroups.length > 1);
        var checkboxRadius = legend$1.checkbox.radius;
        var addedCheckboxes = addedLegendItems.append("div").classed("checkbox", true);
        var allCheckboxes = addedCheckboxes.merge(legendItems.select("div.checkbox")).attr("role", Roles.CHECKBOX).attr("tabindex", legendClickable ? 0 : -1).attr("aria-labelledby", function(d, i2) {
          return _this.services.domUtils.generateElementIDString("legend-datagroup-" + i2 + "-title");
        }).attr("aria-checked", function(_a22) {
          var status = _a22.status;
          return status === legend$1.items.status.ACTIVE;
        }).attr("width", checkboxRadius * 2).attr("height", checkboxRadius * 2).attr("class", function(d, i2) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.BACKGROUND],
            dataGroupName: d.name,
            originalClassName: "checkbox"
          });
        }).style("background", function(d) {
          return d.status === legend$1.items.status.ACTIVE ? _this.model.getFillColor(d.name) || _this.model.getStrokeColor(d.name) : null;
        }).classed("active", function(d, i2) {
          return d.status === legend$1.items.status.ACTIVE;
        });
        addedCheckboxes.append("svg").attr("focusable", false).attr("preserveAspectRatio", "xMidYMid meet").attr("xmlns", "http://www.w3.org/2000/svg").attr("width", "11").attr("height", "11").attr("viewBox", "0 0 31 28").attr("aria-hidden", true).style("will-change", "transform").append("path").attr("d", "M13 21.2l-7.1-7.1-1.4 1.4 7.1 7.1L13 24 27.1 9.9l-1.4-1.5z");
        addedLegendItems.append("p").merge(legendItems.select("p"));
        var additionalItemsOption = Tools.getProperty(options2, "legend", "additionalItems");
        if (additionalItemsOption && dataGroups.length) {
          var self_1 = this;
          var additionalItems = svg.selectAll("div.additional-item").data(additionalItemsOption);
          additionalItems.exit().remove();
          var addedAdditionalItems = additionalItems.enter().append("div").merge(additionalItems).classed("legend-item", true).classed("additional", true).attr("aria-labelledby", function(d, i2) {
            return _this.services.domUtils.generateElementIDString("legend-datagroup-" + (allCheckboxes.size() + i2) + "-title");
          });
          addedAdditionalItems.selectAll("*").remove();
          var previousType_1;
          var indexOfItem_1 = 1;
          addedAdditionalItems.append("svg").classed("icon", true).each(function(d, i2) {
            var additionalItem = select(this);
            if (!previousType_1 || previousType_1 != d.type) {
              previousType_1 = d.type;
              indexOfItem_1 = 1;
            } else {
              indexOfItem_1++;
            }
            self_1.addAdditionalItem(additionalItem, d, indexOfItem_1);
          });
          addedAdditionalItems.append("p").merge(addedAdditionalItems.select("p"));
          this.truncateLegendText();
        }
        legendItems.exit().on("mouseover", null).on("click", null).on("mouseout", null).remove();
        if (legendClickable && addedLegendItems.size() > 1) {
          this.addEventListeners();
        }
      };
      Legend2.prototype.sortDataGroups = function(dataGroups, legendOrder) {
        dataGroups.sort(function(dataA, dataB) {
          return legendOrder.indexOf(dataA.name) - legendOrder.indexOf(dataB.name);
        });
        if (legendOrder.length < dataGroups.length) {
          var definedOrderIndex = dataGroups.length - legendOrder.length;
          var definedOrder = dataGroups.slice(definedOrderIndex);
          return definedOrder.concat(dataGroups.slice(0, definedOrderIndex));
        }
        return dataGroups;
      };
      Legend2.prototype.addAdditionalItem = function(additionalItem, itemConfig, indexOfItem) {
        var _a22 = legend$1.area, width = _a22.width, height = _a22.height;
        if (itemConfig.type === LegendItemType.RADIUS) {
          additionalItem.style("width", height + "px").style("height", height + "px");
        } else {
          additionalItem.style("width", width + "px").style("height", height + "px");
        }
        if (itemConfig.type === LegendItemType.RADIUS) {
          var _b = legend$1.radius, iconData = _b.iconData, fill = _b.fill, stroke = _b.stroke;
          var circleEnter = additionalItem.attr("fill", "none").selectAll("circle").data(iconData).enter();
          circleEnter.append("circle").classed("radius", true).attr("role", Roles.IMG).attr("aria-label", "radius").attr("cx", function(d) {
            return d.cx;
          }).attr("cy", function(d) {
            return d.cy;
          }).attr("r", function(d) {
            return d.r;
          }).style("fill", itemConfig.fill ? itemConfig.fill : fill).style("stroke", itemConfig.stroke ? itemConfig.stroke : stroke);
        } else if (itemConfig.type === LegendItemType.LINE) {
          var lineConfig = legend$1.line;
          if (additionalItem.select("line.line").empty()) {
            additionalItem.append("line").classed("line-" + indexOfItem, true).attr("role", Roles.IMG).attr("aria-label", "line").attr("x1", 0).attr("y1", lineConfig.yPosition).attr("x2", width).attr("y2", lineConfig.yPosition).style("stroke", itemConfig.stroke ? itemConfig.stroke : lineConfig.stroke).style("stroke-width", lineConfig.strokeWidth);
          }
        } else if (itemConfig.type === LegendItemType.AREA) {
          if (additionalItem.select("rect.area").empty()) {
            additionalItem.append("rect").classed("area-" + indexOfItem, true).attr("role", Roles.IMG).attr("aria-label", "area").attr("width", width).attr("height", height).style("fill", indexOfItem > 3 && !itemConfig.fill ? legend$1.area.fill : itemConfig.fill).style("stroke", itemConfig.stroke);
          }
        } else if (itemConfig.type === LegendItemType.SIZE) {
          var _c = legend$1.size, iconData = _c.iconData, fill = _c.fill, stroke = _c.stroke;
          var sizeEnter = additionalItem.attr("fill", "none").attr("role", Roles.IMG).attr("aria-label", "size").selectAll("rect").data(iconData).enter();
          sizeEnter.append("rect").classed("size", true).attr("width", function(d) {
            return d.width;
          }).attr("height", function(d) {
            return d.height;
          }).attr("y", function(d) {
            return 0;
          }).style("fill", itemConfig.fill ? itemConfig.fill : fill).style("stroke", itemConfig.stroke ? itemConfig.stroke : stroke).style("stroke-width", 1);
        } else if (itemConfig.type === LegendItemType.QUARTILE) {
          var iconData = legend$1.quartile.iconData;
          var quartileEnter = additionalItem.selectAll("rect").attr("role", Roles.IMG).attr("aria-label", "quartile").data(iconData).enter();
          quartileEnter.append("rect").attr("class", function(d, i2) {
            return "quartile-" + (i2 === 0 ? "wrapper" : "line");
          }).attr("x", function(d) {
            return d.x;
          }).attr("y", function(d) {
            return d.y;
          }).attr("width", function(d) {
            return d.width;
          }).attr("height", function(d) {
            return d.height;
          });
        } else if (itemConfig.type === LegendItemType.ZOOM) {
          var _d2 = Tools.getProperty(Configuration, "legend", "zoom"), iconData = _d2.iconData, color_1 = _d2.color;
          var zoomEnter = additionalItem.attr("role", Roles.IMG).attr("aria-label", "zoom").selectAll("g.icon").data(iconData).enter();
          zoomEnter.append("g").attr("x", function(d) {
            return d.x;
          }).attr("y", function(d) {
            return d.y;
          }).attr("width", function(d) {
            return d.width;
          }).attr("height", function(d) {
            return d.height;
          }).append("polygon").attr("points", "7.7 4.82 5.78 4.82 5.78 2.89 4.82 2.89 4.82 4.82 2.89 4.82 2.89 5.78 4.82 5.78 4.82 7.7 5.78 7.7 5.78 5.78 7.7 5.78 7.7 4.82").attr("fill", function(d) {
            return itemConfig.color ? itemConfig.color : color_1;
          });
          zoomEnter.append("path").attr("d", "M9.36,8.67A5.22,5.22,0,0,0,10.59,5.3,5.3,5.3,0,1,0,5.3,10.59,5.22,5.22,0,0,0,8.67,9.36L12.32,13l.68-.68Zm-4.06,1A4.34,4.34,0,1,1,9.63,5.3,4.33,4.33,0,0,1,5.3,9.63Z").attr("fill", function(d) {
            return itemConfig.color ? itemConfig.color : color_1;
          });
        }
      };
      Legend2.prototype.truncateLegendText = function() {
        var svg = this.getComponentContainer();
        var truncationOptions = Tools.getProperty(this.getOptions(), "legend", "truncation");
        var truncationType = Tools.getProperty(truncationOptions, "type");
        var truncationThreshold = Tools.getProperty(truncationOptions, "threshold");
        var truncationNumCharacter = Tools.getProperty(truncationOptions, "numCharacter");
        var addedLegendItemsText = svg.selectAll("div.legend-item p");
        addedLegendItemsText.attr("id", function(d, i2) {
          var elementToReference = this.parentNode.querySelector("div.checkbox") || this.parentNode;
          return elementToReference.getAttribute("aria-labelledby");
        });
        if (truncationType !== TruncationTypes.NONE) {
          addedLegendItemsText.html(function(d) {
            if (d.name.length > truncationThreshold) {
              return Tools.truncateLabel(d.name, truncationType, truncationNumCharacter);
            } else {
              return d.name;
            }
          });
        } else {
          addedLegendItemsText.html(function(d) {
            return d.name;
          });
        }
      };
      Legend2.prototype.addEventListeners = function() {
        var self2 = this;
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var legendOptions = Tools.getProperty(options2, "legend");
        var truncationThreshold = Tools.getProperty(legendOptions, "truncation", "threshold");
        svg.selectAll("div.legend-item").on("mouseover", function(event) {
          self2.services.events.dispatchEvent(Events$1.Legend.ITEM_HOVER, {
            hoveredElement: select(this)
          });
          var hoveredItem = select(this);
          hoveredItem.select("div.checkbox").classed("hovered", true);
          var hoveredItemData = hoveredItem.datum();
          if (hoveredItemData.name.length > truncationThreshold) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement: hoveredItem,
              content: hoveredItemData.name
            });
          }
        }).on("mousemove", function(event) {
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function() {
          self2.services.events.dispatchEvent(Events$1.Legend.ITEM_CLICK, {
            clickedElement: select(this)
          });
          var clickedItem = select(this);
          var clickedItemData = clickedItem.datum();
          self2.model.toggleDataLabel(clickedItemData.name);
        }).on("mouseout", function() {
          var hoveredItem = select(this);
          hoveredItem.select("div.checkbox").classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
          self2.services.events.dispatchEvent(Events$1.Legend.ITEM_MOUSEOUT, {
            hoveredElement: hoveredItem
          });
        });
        svg.selectAll("div.legend-item div.checkbox").on("keyup", function(event) {
          if (event.key && event.key === "Tab") {
            self2.services.events.dispatchEvent(Events$1.Legend.ITEM_HOVER, {
              hoveredElement: select(this)
            });
          }
        });
        svg.selectAll("div.legend-item div.checkbox").on("keydown", function(event, d) {
          if (event.key && event.key === " ") {
            event.preventDefault();
            self2.model.toggleDataLabel(d.name);
          } else if (event.key && event.key === "Tab") {
            self2.services.events.dispatchEvent(Events$1.Legend.ITEM_MOUSEOUT, {
              hoveredElement: select(this)
            });
          }
        });
        svg.selectAll("g.additional-item").on("mouseover", function(event) {
          var hoveredItem = select(this);
          var hoveredItemData = hoveredItem.datum();
          if (hoveredItemData.name.length > truncationThreshold) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement: hoveredItem,
              content: hoveredItemData.name
            });
          }
        });
      };
      return Legend2;
    }(Component);
    top = 1;
    right = 2;
    bottom = 3;
    left = 4;
    epsilon$1 = 1e-6;
    __extends$1o = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ColorScaleLegend = function(_super) {
      __extends$1o(ColorScaleLegend2, _super);
      function ColorScaleLegend2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "color-legend";
        _this.renderType = RenderTypes.SVG;
        _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
        _this.handleAxisCompleteEvent = function(event) {
          var svg = _this.getComponentContainer();
          var width = DOMUtils.getSVGElementSize(svg, {
            useAttrs: true
          }).width;
          var isDataLoading = Tools.getProperty(_this.getOptions(), "data", "loading");
          if (width > legend$1.color.barWidth && !isDataLoading) {
            var title = Tools.getProperty(_this.getOptions(), "heatmap", "colorLegend", "title");
            var cartesianScales = _this.services.cartesianScales;
            var mainXScale = cartesianScales.getMainXScale();
            var xDimensions = mainXScale.range();
            if (xDimensions[0] > 1) {
              svg.select("g.legend").attr("transform", "translate(" + xDimensions[0] + ", 0)");
              if (title) {
                var textWidth = DOMUtils.getSVGElementSize(svg.select("g.legend-title").select("text"), { useBBox: true }).width;
                var availableSpace = xDimensions[0] - textWidth - 9;
                if (availableSpace > 1) {
                  svg.select("g.legend-title").attr("transform", "translate(" + availableSpace + ", 0)");
                } else {
                  svg.select("g.legend").attr("transform", "translate(" + xDimensions[0] + ", 16)");
                  svg.select("g.legend-title").attr("transform", "translate(" + xDimensions[0] + ", 0)");
                }
              }
            }
          } else {
            svg.select("g.legend-title").attr("transform", "translate(0, 0)");
          }
        };
        return _this;
      }
      ColorScaleLegend2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
      };
      ColorScaleLegend2.prototype.render = function(animate) {
        var options2 = this.getOptions();
        var svg = this.getComponentContainer();
        var width = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }).width;
        var customColors = Tools.getProperty(options2, "color", "gradient", "colors");
        var colorScaleType = Tools.getProperty(options2, "heatmap", "colorLegend", "type");
        var colorPairingOption = Tools.getProperty(options2, "color", "pairing", "option");
        var title = Tools.getProperty(options2, "heatmap", "colorLegend", "title");
        var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
        if (isDataLoading) {
          svg.html("");
          return;
        }
        var customColorsEnabled = !Tools.isEmpty(customColors);
        var domain = this.model.getValueDomain();
        var useDefaultBarWidth = !(width <= legend$1.color.barWidth);
        var barWidth = useDefaultBarWidth ? legend$1.color.barWidth : width;
        var legendGroupElement = DOMUtils.appendOrSelect(svg, "g.legend");
        var axisElement = DOMUtils.appendOrSelect(legendGroupElement, "g.legend-axis");
        if (title) {
          var legendTitleGroup = DOMUtils.appendOrSelect(svg, "g.legend-title");
          var legendTitle = DOMUtils.appendOrSelect(legendTitleGroup, "text");
          legendTitle.text(title).attr("dy", "0.7em");
          legendGroupElement.attr("transform", "translate(0, 16)");
        }
        var colorScheme = domain[0] < 0 && domain[1] > 0 ? "diverge" : "mono";
        if (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === "mono") {
          colorPairingOption = 1;
        } else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === "diverge") {
          colorPairingOption = 1;
        }
        var colorPairing = [];
        var colorGroupingLength = colorScheme === "diverge" ? 17 : 11;
        if (!customColorsEnabled) {
          for (var i2 = 1; i2 < colorGroupingLength + 1; i2++) {
            colorPairing.push(colorScaleType === ColorLegendType.LINEAR ? "stop-color-" + colorScheme + "-" + colorPairingOption + "-" + i2 : "fill-" + colorScheme + "-" + colorPairingOption + "-" + i2);
          }
        } else {
          colorPairing = customColors;
        }
        var interpolator = interpolateNumber(domain[0], domain[1]);
        var quant = quantize$1(interpolator, 3);
        var linearScale = linear().domain(domain).range([0, barWidth]);
        var legendAxis = axisBottom(linearScale).tickSize(0).tickValues(quant);
        switch (colorScaleType) {
          case ColorLegendType.LINEAR:
            this.drawLinear(colorPairing, legendGroupElement, barWidth);
            break;
          case ColorLegendType.QUANTIZE:
            var rangeStart = this.drawQuantize(colorPairing, colorScheme, customColorsEnabled, legendGroupElement, barWidth);
            linearScale.range([rangeStart, barWidth]);
            break;
          default:
            throw Error("Entered color legend type is not supported.");
        }
        axisElement.attr("transform", "translate(0," + legend$1.color.axisYTranslation + ")").call(legendAxis);
        axisElement.select(".domain").remove();
        axisElement.select("g.tick:last-of-type text").style("text-anchor", useDefaultBarWidth ? "middle" : "end");
        axisElement.select("g.tick:first-of-type text").style("text-anchor", useDefaultBarWidth ? "middle" : "start");
      };
      ColorScaleLegend2.prototype.drawLinear = function(colorPairing, legendGroupElement, barWidth) {
        var stopLengthPercentage = 100 / (colorPairing.length - 1);
        var linearGradient = DOMUtils.appendOrSelect(legendGroupElement, "linearGradient");
        linearGradient.attr("id", this.gradient_id + "-legend").selectAll("stop").data(colorPairing).enter().append("stop").attr("offset", function(_, i2) {
          return i2 * stopLengthPercentage + "%";
        }).attr("class", function(_, i2) {
          return colorPairing[i2];
        }).attr("stop-color", function(d) {
          return d;
        });
        var rectangle = DOMUtils.appendOrSelect(legendGroupElement, "rect");
        rectangle.attr("width", barWidth).attr("height", legend$1.color.barHeight).style("fill", "url(#" + this.gradient_id + "-legend)");
      };
      ColorScaleLegend2.prototype.drawQuantize = function(colorPairing, colorScheme, customColorsEnabled, legendGroupElement, barWidth) {
        if (!customColorsEnabled && colorScheme === "diverge") {
          colorPairing.splice(colorPairing.length / 2, 1);
        }
        var colorScaleBand = band().domain(colorPairing).range([0, barWidth]);
        var rectangle = DOMUtils.appendOrSelect(legendGroupElement, "g.quantized-rect");
        rectangle.selectAll("rect").data(colorScaleBand.domain()).join("rect").attr("x", function(d) {
          return colorScaleBand(d);
        }).attr("y", 0).attr("width", Math.max(0, colorScaleBand.bandwidth() - 1)).attr("height", legend$1.color.barHeight).attr("class", function(d) {
          return d;
        }).attr("fill", function(d) {
          return d;
        });
        return (!customColorsEnabled && colorScheme) === "mono" ? colorScaleBand.bandwidth() - 1 : 0;
      };
      ColorScaleLegend2.prototype.destroy = function() {
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Axis.RENDER_COMPLETE, this.handleAxisCompleteEvent);
      };
      return ColorScaleLegend2;
    }(Legend);
    exports$1 = [eventedState, eventedShowHideState];
    eventedShowHideState$1 = exports$1;
    __DEV__ = process.env.NODE_ENV !== "production";
    warning = function() {
    };
    if (__DEV__) {
      warning = function(condition, format22, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key2 = 2; key2 < len; key2++) {
          args[key2 - 2] = arguments[key2];
        }
        if (format22 === void 0) {
          throw new Error("`warning(condition, format, ...args)` requires a warning message argument");
        }
        if (format22.length < 10 || /^[s\W]*$/.test(format22)) {
          throw new Error("The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: " + format22);
        }
        if (!condition) {
          var argIndex = 0;
          var message = "Warning: " + format22.replace(/%s/g, function() {
            return args[argIndex++];
          });
          if (typeof console !== "undefined") {
            console.error(message);
          }
          try {
            throw new Error(message);
          } catch (x22) {
          }
        }
      };
    }
    warning_1 = warning;
    Modal$1 = /* @__PURE__ */ function(_mixin) {
      _inherits(Modal2, _mixin);
      var _super = _createSuper(Modal2);
      function Modal2(element, options2) {
        var _this;
        _classCallCheck(this, Modal2);
        _this = _super.call(this, element, options2);
        _this._handleFocusinListener = void 0;
        _this._handleKeydownListener = void 0;
        _this._handleFocusin = function(evt) {
          var focusWrapNode = _this.element.querySelector(_this.options.selectorModalContainer) || _this.element;
          if (_this.element.classList.contains(_this.options.classVisible) && !focusWrapNode.contains(evt.target) && _this.options.selectorsFloatingMenus.every(function(selector2) {
            return !eventMatches(evt, selector2);
          })) {
            _this.element.querySelector(settings$1.selectorTabbable).focus();
          }
        };
        _this._hookCloseActions();
        return _this;
      }
      _createClass(Modal2, [{
        key: "createdByLauncher",
        value: function createdByLauncher(evt) {
          this.show(evt);
        }
      }, {
        key: "shouldStateBeChanged",
        value: function shouldStateBeChanged(state) {
          if (state === "shown") {
            return !this.element.classList.contains(this.options.classVisible);
          }
          return this.element.classList.contains(this.options.classVisible);
        }
      }, {
        key: "_changeState",
        value: function _changeState(state, detail, callback) {
          var _this2 = this;
          var handleTransitionEnd;
          var transitionEnd = function transitionEnd2() {
            if (handleTransitionEnd) {
              handleTransitionEnd = _this2.unmanage(handleTransitionEnd).release();
            }
            if (state === "shown" && _this2.element.offsetWidth > 0 && _this2.element.offsetHeight > 0) {
              _this2.previouslyFocusedNode = _this2.element.ownerDocument.activeElement;
              var focusableItem = _this2.element.querySelector(_this2.options.selectorPrimaryFocus) || _this2.element.querySelector(settings$1.selectorTabbable);
              focusableItem.focus();
              if (process.env.NODE_ENV !== "production") {
                process.env.NODE_ENV !== "production" ? warning_1(focusableItem, "Modals need to contain a focusable element by either using " + "`".concat(_this2.options.selectorPrimaryFocus, "` or settings.selectorTabbable.")) : void 0;
              }
            }
            callback();
          };
          if (this._handleFocusinListener) {
            this._handleFocusinListener = this.unmanage(this._handleFocusinListener).release();
          }
          if (state === "shown") {
            var hasFocusin = "onfocusin" in this.element.ownerDocument.defaultView;
            var focusinEventName = hasFocusin ? "focusin" : "focus";
            this._handleFocusinListener = this.manage(on(this.element.ownerDocument, focusinEventName, this._handleFocusin, !hasFocusin));
          }
          if (state === "hidden") {
            this.element.classList.toggle(this.options.classVisible, false);
            this.element.ownerDocument.body.classList.toggle(this.options.classBody, false);
            if (this.options.selectorFocusOnClose || this.previouslyFocusedNode) {
              (this.element.ownerDocument.querySelector(this.options.selectorFocusOnClose) || this.previouslyFocusedNode).focus();
            }
          } else if (state === "shown") {
            this.element.classList.toggle(this.options.classVisible, true);
            this.element.ownerDocument.body.classList.toggle(this.options.classBody, true);
          }
          handleTransitionEnd = this.manage(on(this.element, "transitionend", transitionEnd));
        }
      }, {
        key: "_hookCloseActions",
        value: function _hookCloseActions() {
          var _this3 = this;
          this.manage(on(this.element, "click", function(evt) {
            var closeButton = eventMatches(evt, _this3.options.selectorModalClose);
            if (closeButton) {
              evt.delegateTarget = closeButton;
            }
            if (closeButton || evt.target === _this3.element) {
              _this3.hide(evt);
            }
          }));
          if (this._handleKeydownListener) {
            this._handleKeydownListener = this.unmanage(this._handleKeydownListener).release();
          }
          this._handleKeydownListener = this.manage(on(this.element.ownerDocument.body, "keydown", function(evt) {
            if (evt.which === 27 && _this3.shouldStateBeChanged("hidden")) {
              evt.stopPropagation();
              _this3.hide(evt);
            }
          }));
        }
      }], [{
        key: "options",
        get: function get2() {
          var prefix = settings$1.prefix;
          return {
            selectorInit: "[data-modal]",
            selectorModalClose: "[data-modal-close]",
            selectorPrimaryFocus: "[data-modal-primary-focus]",
            selectorsFloatingMenus: [".".concat(prefix, "--overflow-menu-options"), ".".concat(prefix, "--tooltip"), ".flatpickr-calendar"],
            selectorModalContainer: ".".concat(prefix, "--modal-container"),
            classVisible: "is-visible",
            classBody: "".concat(prefix, "--body--with-modal-open"),
            attribInitTarget: "data-modal-target",
            initEventNames: ["click"],
            eventBeforeShown: "modal-beingshown",
            eventAfterShown: "modal-shown",
            eventBeforeHidden: "modal-beinghidden",
            eventAfterHidden: "modal-hidden"
          };
        }
      }]);
      Modal2.components = /* @__PURE__ */ new WeakMap();
      return Modal2;
    }(mixin(createComponent, initComponentByLauncher, eventedShowHideState$1, handles));
    CarbonModalComponent = Modal$1;
    __extends$1n = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Modal = function(_super) {
      __extends$1n(Modal2, _super);
      function Modal2(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "modal";
        _this.isEventListenerAdded = false;
        _this.handleShowModal = function() {
          _this.modal.html(_this.getModalHTML());
          _this.modal.select("div.bx--modal-footer button.bx--btn").on("click", function() {
            return _this.model.exportToCSV();
          });
          var modalInstance = CarbonModalComponent.create(_this.modal.node());
          modalInstance.show();
        };
        _this.init();
        return _this;
      }
      Modal2.prototype.addEventListeners = function() {
        this.services.events.addEventListener(Events$1.Modal.SHOW, this.handleShowModal);
      };
      Modal2.prototype.removeEventListeners = function() {
        this.services.events.removeEventListener(Events$1.Modal.SHOW, this.handleShowModal);
      };
      Modal2.prototype.getModalHTML = function() {
        var options2 = this.model.getOptions();
        var chartprefix = Tools.getProperty(options2, "style", "prefix");
        var tableArray = this.model.getTabularDataArray();
        return '\n		<div class="bx--modal-container cds--modal-container">\n			<div class="bx--modal-header cds--modal-header">\n				<p class="bx--modal-header__label bx--type-delta cds--modal-header__label cds--type-delta" id="modal-title">Tabular representation</p>\n\n				<p class="bx--modal-header__heading bx--type-beta cds--modal-header__heading cds--type-beta" id="modal-description">' + options2.title + '</p>\n\n				<button class="bx--modal-close cds--modal-close" type="button" data-modal-close aria-label="close modal"  data-modal-primary-focus>\n					<svg focusable="false" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" fill="currentColor" aria-label="Close" width="20" height="20" viewBox="0 0 32 32" role="img" class="bx--modal-close__icon cds--modal-close__icon">\n						<path d="M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"></path>\n					</svg>\n				</button>\n			</div>\n\n			<div class="bx--modal-content cds--modal-content">\n				<table class="bx--data-table bx--data-table--no-border cds--data-table cds--data-table--no-border">\n					<thead>\n						<tr>\n							' + get$3(tableArray, 0).map(function(heading) {
          return '<th scope="col">\n								<div class="bx--table-header-label cds--table-header-label">' + heading + "</div>\n							</th>";
        }).join("") + "\n						</tr>\n					</thead>\n\n					<tbody>" + tableArray.slice(1).map(function(row) {
          return "\n							<tr>\n								" + row.map(function(column) {
            return "<td>" + column + "</td>";
          }).join("") + "\n							</tr>";
        }).join("") + '\n					</tbody>\n				</table>\n			</div>\n\n			<div class="bx--modal-footer cds--modal-footer">\n			  <div class="' + settings$1.prefix + "--" + chartprefix + '-modal-footer-spacer"></div>\n			  <button class="bx--btn bx--btn--primary cds--btn cds--btn--primary" type="button" data-modal-primary-focus>Download as CSV</button>\n			</div>\n		</div>';
      };
      Modal2.prototype.render = function() {
        var options2 = this.model.getOptions();
        if (!this.isEventListenerAdded) {
          var holder = select(this.services.domUtils.getHolder());
          var chartprefix = Tools.getProperty(options2, "style", "prefix");
          this.modal = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--modal");
          this.addEventListeners();
          this.isEventListenerAdded = true;
          this.modal.attr("data-modal", true).attr("class", "bx--modal cds--modal").attr("role", "dialog").attr("aria-modal", true).attr("aria-labelledby", "modal-title").attr("aria-describedby", "modal-description").attr("tabindex", -1);
        }
      };
      Modal2.prototype.destroy = function() {
        this.removeEventListeners();
        this.isEventListenerAdded = false;
      };
      return Modal2;
    }(Component);
    (function(PLACEMENTS2) {
      PLACEMENTS2["LEFT"] = "left";
      PLACEMENTS2["RIGHT"] = "right";
      PLACEMENTS2["TOP"] = "top";
      PLACEMENTS2["BOTTOM"] = "bottom";
    })(PLACEMENTS || (PLACEMENTS = {}));
    defaultPositions = (_a$1 = {}, _a$1[PLACEMENTS.LEFT] = function(referenceOffset, target, referenceRect) {
      return {
        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
        left: Math.round(referenceOffset.left - target.offsetWidth)
      };
    }, _a$1[PLACEMENTS.RIGHT] = function(referenceOffset, target, referenceRect) {
      return {
        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
        left: Math.round(referenceOffset.left + referenceRect.width)
      };
    }, _a$1[PLACEMENTS.TOP] = function(referenceOffset, target, referenceRect) {
      return {
        top: Math.round(referenceOffset.top - target.offsetHeight),
        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
      };
    }, _a$1[PLACEMENTS.BOTTOM] = function(referenceOffset, target, referenceRect) {
      return {
        top: Math.round(referenceOffset.top + referenceRect.height),
        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
      };
    }, _a$1);
    windowRef = typeof window !== "undefined" ? window : {
      innerHeight: 0,
      scrollY: 0,
      innerWidth: 0,
      scrollX: 0
    };
    Position = function() {
      function Position2(positions) {
        if (positions === void 0) {
          positions = {};
        }
        this.positions = defaultPositions;
        this.positions = Object.assign({}, defaultPositions, positions);
      }
      Position2.prototype.getRelativeOffset = function(target) {
        var offsets = {
          left: target.offsetLeft,
          top: target.offsetTop
        };
        while (target.offsetParent && getComputedStyle(target.offsetParent).position === "static") {
          offsets.left += target.offsetLeft;
          offsets.top += target.offsetTop;
          target = target.offsetParent;
        }
        return offsets;
      };
      Position2.prototype.getAbsoluteOffset = function(target) {
        var currentNode = target;
        var margins = {
          top: 0,
          left: 0
        };
        while (currentNode.offsetParent) {
          var computed = getComputedStyle(currentNode.offsetParent);
          if (computed.position === "static" && computed.marginLeft && computed.marginTop) {
            if (parseInt(computed.marginTop, 10)) {
              margins.top += parseInt(computed.marginTop, 10);
            }
            if (parseInt(computed.marginLeft, 10)) {
              margins.left += parseInt(computed.marginLeft, 10);
            }
          }
          currentNode = currentNode.offsetParent;
        }
        var targetRect = target.getBoundingClientRect();
        var relativeRect = document.body.getBoundingClientRect();
        return {
          top: targetRect.top - relativeRect.top + margins.top,
          left: targetRect.left - relativeRect.left + margins.left
        };
      };
      Position2.prototype.findRelative = function(reference, target, placement) {
        var referenceOffset = this.getRelativeOffset(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
      };
      Position2.prototype.findAbsolute = function(reference, target, placement) {
        var referenceOffset = this.getAbsoluteOffset(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
      };
      Position2.prototype.findPosition = function(reference, target, placement, offsetFunction) {
        if (offsetFunction === void 0) {
          offsetFunction = this.getAbsoluteOffset;
        }
        var referenceOffset = offsetFunction(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
      };
      Position2.prototype.findPositionAt = function(offset, target, placement) {
        return this.calculatePosition(offset, { height: 0, width: 0 }, target, placement);
      };
      Position2.prototype.getPlacementBox = function(target, position) {
        var targetBottom = target.offsetHeight + position.top;
        var targetRight = target.offsetWidth + position.left;
        return {
          top: position.top,
          bottom: targetBottom,
          left: position.left,
          right: targetRight
        };
      };
      Position2.prototype.addOffset = function(position, top2, left2) {
        if (top2 === void 0) {
          top2 = 0;
        }
        if (left2 === void 0) {
          left2 = 0;
        }
        return Object.assign({}, position, {
          top: position.top + top2,
          left: position.left + left2
        });
      };
      Position2.prototype.setElement = function(element, position) {
        element.style.top = position.top + "px";
        element.style.left = position.left + "px";
      };
      Position2.prototype.findBestPlacement = function(reference, target, placements, containerFunction, positionFunction) {
        var _this = this;
        if (containerFunction === void 0) {
          containerFunction = this.defaultContainerFunction;
        }
        if (positionFunction === void 0) {
          positionFunction = this.findPosition;
        }
        var weightedPlacements = placements.map(function(placement) {
          var pos = positionFunction(reference, target, placement);
          var box = _this.getPlacementBox(target, pos);
          var hiddenHeight = box.bottom - containerFunction().height;
          var hiddenWidth = box.right - containerFunction().width;
          hiddenHeight = hiddenHeight < 0 ? target.offsetHeight : hiddenHeight;
          hiddenWidth = hiddenWidth < 0 ? target.offsetWidth : hiddenWidth;
          var area2 = target.offsetHeight * target.offsetWidth;
          var hiddenArea = hiddenHeight * hiddenWidth;
          var visibleArea = area2 - hiddenArea;
          visibleArea = visibleArea === 0 ? area2 : visibleArea;
          var visiblePercent = visibleArea / area2;
          return {
            placement,
            weight: visiblePercent
          };
        });
        weightedPlacements.sort(function(a, b) {
          return b.weight - a.weight;
        });
        return weightedPlacements[0].placement;
      };
      Position2.prototype.findBestPlacementAt = function(offset, target, placements, containerFunction) {
        var _this = this;
        if (containerFunction === void 0) {
          containerFunction = this.defaultContainerFunction;
        }
        var positionAt = function(_, target2, placement) {
          return _this.findPositionAt(offset, target2, placement);
        };
        return this.findBestPlacement(null, target, placements, containerFunction, positionAt);
      };
      Position2.prototype.defaultContainerFunction = function() {
        return {
          width: windowRef.innerHeight - windowRef.scrollY,
          height: windowRef.innerWidth - windowRef.scrollX
        };
      };
      Position2.prototype.calculatePosition = function(referenceOffset, referenceRect, target, placement) {
        if (this.positions[placement]) {
          return this.positions[placement](referenceOffset, target, referenceRect);
        }
        console.error("No function found for placement, defaulting to 0,0");
        return { left: 0, top: 0 };
      };
      return Position2;
    }();
    new Position();
    TIME_INTERVALS = [
      ["15seconds", 15 * 1e3],
      ["minute", 60 * 1e3],
      ["30minutes", 30 * 60 * 1e3],
      ["hourly", 60 * 60 * 1e3],
      ["daily", 24 * 60 * 60 * 1e3],
      ["monthly", 30 * 24 * 60 * 60 * 1e3],
      ["quarterly", 3 * 30 * 24 * 60 * 60 * 1e3],
      ["yearly", 12 * 30 * 24 * 60 * 60 * 1e3]
    ];
    __extends$1m = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Threshold = function(_super) {
      __extends$1m(Threshold2, _super);
      function Threshold2(model, services) {
        var _this = _super.call(this, model, services) || this;
        _this.type = "threshold";
        _this.renderType = RenderTypes.SVG;
        _this.positionService = new Position();
        return _this;
      }
      Threshold2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = false;
        }
        var axesOptions = Tools.getProperty(this.getOptions(), "axes");
        var thresholdData = [];
        Object.keys(axesOptions).forEach(function(axisPosition) {
          var _a22, _b;
          if (Object.values(AxisPositions).includes(axisPosition)) {
            var axisOptions = axesOptions[axisPosition];
            if (axisOptions.thresholds && axisOptions.thresholds.length > 0) {
              thresholdData.push({
                axisPosition,
                thresholds: axisOptions.thresholds,
                correspondingDatasets: (_a22 = axisOptions) === null || _a22 === void 0 ? void 0 : _a22.correspondingDatasets,
                mapsTo: (_b = axisOptions) === null || _b === void 0 ? void 0 : _b.mapsTo
              });
            }
          }
        });
        var svg = this.getComponentContainer({ withinChartClip: true });
        var thresholdAxisGroups = svg.selectAll("g.axis-thresholds").data(thresholdData, function(thresholdData2) {
          return thresholdData2.axisPosition;
        });
        thresholdAxisGroups.exit().attr("opacity", 0).remove();
        var thresholdAxisGroupsEnter = thresholdAxisGroups.enter().append("g");
        var thresholdAxisGroupsMerge = thresholdAxisGroupsEnter.merge(thresholdAxisGroups);
        thresholdAxisGroupsMerge.attr("class", function(d) {
          return "axis-thresholds " + d.axisPosition;
        });
        var thresholdGroups = thresholdAxisGroupsMerge.selectAll("g.threshold-group").data(function(d) {
          return d.thresholds.map(function(threshold) {
            threshold.axisPosition = d.axisPosition;
            threshold.datum = _this.constructDatumObj(d, threshold);
            return threshold;
          });
        });
        thresholdGroups.exit().attr("opacity", 0).remove();
        var thresholdGroupsEnter = thresholdGroups.enter().append("g");
        thresholdGroupsEnter.append("line").attr("class", "threshold-line");
        thresholdGroupsEnter.append("rect").attr("class", "threshold-hoverable-area");
        var thresholdGroupsMerge = thresholdGroupsEnter.merge(thresholdGroups);
        thresholdGroupsMerge.attr("class", "threshold-group");
        var self2 = this;
        thresholdAxisGroupsMerge.each(function(_a22) {
          var axisPosition = _a22.axisPosition;
          var scale = self2.services.cartesianScales.getScaleByPosition(axisPosition);
          var scaleType = self2.services.cartesianScales.getScaleTypeByPosition(axisPosition);
          var xScale = null;
          var yScale = null;
          if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
            yScale = scale;
            xScale = self2.services.cartesianScales.getMainXScale();
          } else {
            xScale = scale;
            yScale = self2.services.cartesianScales.getMainYScale();
          }
          var isScaleTypeLabels = scaleType === ScaleTypes.LABELS;
          var _b = xScale.range(), xScaleStart = _b[0], xScaleEnd = _b[1];
          var _c = yScale.range(), yScaleEnd = _c[0], yScaleStart = _c[1];
          var cartesianScales = self2.services.cartesianScales;
          var orientation = cartesianScales.getOrientation();
          var getDomainValue = function(d) {
            return cartesianScales.getDomainValue(d);
          };
          var getRangeValue = function(d) {
            return cartesianScales.getRangeValue(d);
          };
          var _d2 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _d2[0], getYValue = _d2[1];
          var group = select(this);
          if (axisPosition === AxisPositions.TOP || axisPosition === AxisPositions.BOTTOM) {
            group.selectAll("line.threshold-line").transition().call(function(t2) {
              return self2.services.transitions.setupTransition({
                transition: t2,
                name: "threshold-line-update",
                animate
              });
            }).attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", function(_a32) {
              var datum2 = _a32.datum;
              return getXValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            }).attr("x2", function(_a32) {
              var datum2 = _a32.datum;
              return getXValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            }).style("stroke", function(_a32) {
              var fillColor = _a32.fillColor;
              return fillColor;
            });
            group.selectAll("rect.threshold-hoverable-area").attr("x", 0).attr("y", function(_a32) {
              var datum2 = _a32.datum;
              return -getXValue(datum2);
            }).attr("width", Math.abs(yScaleEnd - yScaleStart)).classed("rotate", true);
          } else {
            group.selectAll("line.threshold-line").transition().call(function(t2) {
              return self2.services.transitions.setupTransition({
                transition: t2,
                name: "threshold-line-update",
                animate
              });
            }).attr("x1", xScaleStart).attr("x2", xScaleEnd).attr("y1", function(_a32) {
              var datum2 = _a32.datum;
              return getYValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            }).attr("y2", function(_a32) {
              var datum2 = _a32.datum;
              return getYValue(datum2) + (isScaleTypeLabels ? scale.step() / 2 : 0);
            }).style("stroke", function(_a32) {
              var fillColor = _a32.fillColor;
              return fillColor;
            });
            group.selectAll("rect.threshold-hoverable-area").attr("x", xScaleStart).attr("y", function(_a32) {
              var datum2 = _a32.datum;
              return getYValue(datum2);
            }).attr("width", Math.abs(xScaleEnd - xScaleStart)).classed("rotate", false);
          }
        });
        this.services.events.addEventListener(Events$1.Threshold.SHOW, function(e3) {
          _this.setThresholdLabelPosition(e3.detail);
          _this.label.classed("hidden", false);
        });
        this.services.events.addEventListener(Events$1.Threshold.HIDE, function(e3) {
          _this.label.classed("hidden", true);
        });
        this.appendThresholdLabel();
        this.addEventListeners();
      };
      Threshold2.prototype.getFormattedValue = function(datum2) {
        var value2 = datum2.value, axisPosition = datum2.axisPosition;
        var options2 = this.getOptions();
        var scaleType = this.services.cartesianScales.getScaleTypeByPosition(axisPosition);
        if (scaleType === ScaleTypes.TIME) {
          var isVertical = [
            AxisPositions.LEFT,
            AxisPositions.RIGHT
          ].includes(axisPosition);
          var mainXScale = this.services.cartesianScales.getMainXScale();
          var mainYScale = this.services.cartesianScales.getMainYScale();
          var scale = isVertical ? mainYScale : mainXScale;
          var timeScaleOptions = Tools.getProperty(options2, "timeScale");
          var timeInterval = computeTimeIntervalName(scale.ticks());
          return formatTick(value2, 0, scale.ticks(), timeInterval, timeScaleOptions);
        }
        return value2.toLocaleString("en");
      };
      Threshold2.prototype.appendThresholdLabel = function() {
        var holder = select(this.services.domUtils.getHolder());
        var chartprefix = Tools.getProperty(this.getOptions(), "style", "prefix");
        this.label = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--threshold--label").classed("hidden", true);
      };
      Threshold2.prototype.setThresholdLabelPosition = function(_a22) {
        var event = _a22.event, datum2 = _a22.datum;
        var holder = this.services.domUtils.getHolder();
        var mouseRelativePos = pointer(event, holder);
        var formattedValue = datum2.valueFormatter ? datum2.valueFormatter(datum2.value) : this.getFormattedValue(datum2);
        this.label.html((datum2.label || "Threshold") + ": " + formattedValue).style("background-color", datum2.fillColor);
        var target = this.label.node();
        var bestPlacementOption = this.positionService.findBestPlacementAt({
          left: mouseRelativePos[0],
          top: mouseRelativePos[1]
        }, target, [
          PLACEMENTS.RIGHT,
          PLACEMENTS.LEFT,
          PLACEMENTS.TOP,
          PLACEMENTS.BOTTOM
        ], function() {
          return {
            width: holder.offsetWidth,
            height: holder.offsetHeight
          };
        });
        var pos = this.positionService.findPositionAt({
          left: mouseRelativePos[0],
          top: mouseRelativePos[1]
        }, target, bestPlacementOption);
        this.positionService.setElement(target, pos);
      };
      Threshold2.prototype.constructDatumObj = function(d, element) {
        var datum2 = {};
        if (d.correspondingDatasets) {
          datum2["group"] = Tools.getProperty(d, "correspondingDatasets", 0);
        }
        datum2[d["mapsTo"]] = element.value;
        return datum2;
      };
      Threshold2.prototype.addEventListeners = function() {
        var self2 = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        svg.selectAll("rect.threshold-hoverable-area").on("mouseover mousemove", function(event) {
          select(this.parentNode).select("line.threshold-line").classed("active", true);
          self2.services.events.dispatchEvent(Events$1.Threshold.SHOW, {
            event,
            hoveredElement: select(this),
            datum: select(this).datum()
          });
        }).on("mouseout", function(event) {
          select(this.parentNode).select("line.threshold-line").classed("active", false);
          self2.services.events.dispatchEvent(Events$1.Threshold.HIDE, {
            event,
            hoveredElement: select(this),
            datum: select(this).datum()
          });
        });
      };
      return Threshold2;
    }(Component);
    __extends$1l = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Title = function(_super) {
      __extends$1l(Title2, _super);
      function Title2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "title";
        _this.renderType = RenderTypes.HTML;
        return _this;
      }
      Title2.prototype.render = function() {
        var svg = this.getComponentContainer();
        var title = Tools.getProperty(this.getOptions(), "title");
        var text = svg.selectAll("p.title").data([title]);
        text.enter().append("p").classed("title", true).attr("role", "heading").attr("aria-level", 2).merge(text).html(function(d) {
          return d;
        });
        if (text.node() && text.node().offsetWidth < text.node().scrollWidth) {
          var self_1 = this;
          text.on("mouseover", function(event) {
            self_1.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement: text,
              content: text.text()
            });
          }).on("mousemove", function(event) {
            self_1.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
              event
            });
          }).on("mouseout", function() {
            self_1.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
          });
        }
        text.exit().remove();
      };
      Title2.prototype.truncateTitle = function(title, maxWidth) {
        if (maxWidth <= 0) {
          return;
        }
        var untruncatedTitle = title.text();
        if (title.node().getComputedTextLength() > maxWidth) {
          title.append("tspan").text("...");
          var tspanLength = DOMUtils.appendOrSelect(title, "tspan").node().getComputedTextLength();
          var titleString = title.text();
          var substringIndex = this.getSubstringIndex(title.node(), 0, titleString.length - 1, maxWidth - tspanLength);
          title.html(titleString.substring(0, substringIndex - 1)).append("tspan").text("...");
          var self_2 = this;
          title.on("mouseover", function(event) {
            self_2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement: title,
              content: untruncatedTitle
            });
          }).on("mousemove", function(event) {
            self_2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
              event
            });
          }).on("mouseout", function() {
            self_2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
          });
        }
      };
      Title2.prototype.getMaxTitleWidth = function() {
        return DOMUtils.getSVGElementSize(this.parent.node(), {
          useAttrs: true
        }).width;
      };
      Title2.prototype.getSubstringIndex = function(title, start2, end, width) {
        var mid = Math.floor((end + start2) / 2);
        if (title.getSubStringLength(0, mid) > width) {
          return this.getSubstringIndex(title, start2, mid, width);
        } else if (title.getSubStringLength(0, mid) < width) {
          if (title.getSubStringLength(0, mid + 1) > width) {
            return mid;
          }
          return this.getSubstringIndex(title, mid, end, width);
        } else {
          return mid;
        }
      };
      return Title2;
    }(Component);
    __extends$1k = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    MeterTitle = function(_super) {
      __extends$1k(MeterTitle2, _super);
      function MeterTitle2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "meter-title";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      MeterTitle2.prototype.render = function() {
        var dataset = Tools.getProperty(this.model.getDisplayData(), 0);
        var options2 = this.getOptions();
        var svg = this.getComponentContainer();
        var groupMapsTo = options2.data.groupMapsTo;
        var proportional = Tools.getProperty(options2, "meter", "proportional");
        if (proportional) {
          this.displayTotal();
          this.displayBreakdownTitle();
        } else {
          var title = svg.selectAll("text.meter-title").data([dataset[groupMapsTo]]);
          title.enter().append("text").classed("meter-title", true).merge(title).attr("x", 0).attr("y", "1em").text(function(d) {
            return d;
          });
          title.exit().remove();
          this.appendPercentage();
        }
        this.displayStatus();
        var maxWidth = this.getMaxTitleWidth();
        var titleElement = DOMUtils.appendOrSelect(svg, "text.meter-title");
        if (maxWidth > 0 && titleElement.node().getComputedTextLength() > maxWidth) {
          this.truncateTitle(titleElement, maxWidth);
        }
      };
      MeterTitle2.prototype.displayBreakdownTitle = function() {
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var datasetsTotal = this.model.getMaximumDomain(this.model.getDisplayData());
        var total = Tools.getProperty(options2, "meter", "proportional", "total");
        var unit2 = Tools.getProperty(options2, "meter", "proportional", "unit") ? Tools.getProperty(options2, "meter", "proportional", "unit") : "";
        var data;
        if (datasetsTotal === total) {
          data = null;
        } else {
          var difference = total !== null ? total - datasetsTotal : datasetsTotal;
          var breakdownFormatter = Tools.getProperty(options2, "meter", "proportional", "breakdownFormatter");
          data = breakdownFormatter !== null ? breakdownFormatter({
            datasetsTotal,
            total
          }) : datasetsTotal + " " + unit2 + " used (" + difference + " " + unit2 + " available)";
        }
        var title = svg.selectAll("text.proportional-meter-title").data([data]);
        title.enter().append("text").classed("proportional-meter-title", true).merge(title).attr("x", 0).attr("y", "1em").text(function(d) {
          return d;
        });
        title.exit().remove();
        var maxWidth = this.getMaxTitleWidth();
        var titleElement = DOMUtils.appendOrSelect(svg, "text.proportional-meter-title");
        if (maxWidth > 0 && titleElement.node().getComputedTextLength() > maxWidth) {
          this.truncateTitle(titleElement, maxWidth);
        }
      };
      MeterTitle2.prototype.displayTotal = function() {
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var total = Tools.getProperty(options2, "meter", "proportional", "total");
        var totalValue = total ? Tools.getProperty(options2, "meter", "proportional", "total") : this.model.getMaximumDomain(this.model.getDisplayData());
        var unit2 = Tools.getProperty(options2, "meter", "proportional", "unit") ? Tools.getProperty(options2, "meter", "proportional", "unit") : "";
        var totalFormatter = Tools.getProperty(options2, "meter", "proportional", "totalFormatter");
        var totalString = totalFormatter !== null ? totalFormatter(totalValue) : total + " " + unit2 + " total";
        var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
        var containerWidth = containerBounds.width ? containerBounds.width : this.parent.node().getAttribute("width");
        var title = svg.selectAll("text.proportional-meter-total").data([totalString]);
        title.enter().append("text").classed("proportional-meter-total", true).merge(title).attr("x", this.model.getStatus() ? containerWidth - meter.total.paddingRight : containerWidth).attr("y", "1em").attr("text-anchor", "end").text(function(d) {
          return d;
        });
        title.exit().remove();
      };
      MeterTitle2.prototype.displayStatus = function() {
        var self2 = this;
        var svg = this.getComponentContainer();
        var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
        var containerWidth = containerBounds.width ? containerBounds.width : 0;
        var status = this.model.getStatus();
        var radius = meter.status.indicatorSize / 2;
        var statusGroup = DOMUtils.appendOrSelect(svg, "g.status-indicator").attr("class", status !== null ? "status-indicator status--" + status : "").attr("transform", "translate(" + (containerWidth - radius) + ", 0)");
        var data = status ? [status] : [];
        var icon = statusGroup.selectAll("circle.status").data(data);
        icon.enter().append("circle").merge(icon).attr("class", "status").attr("r", radius).attr("cx", 0).attr("cy", "calc(1em / 2)");
        var innerIcon = statusGroup.selectAll("path.innerFill").data(data);
        innerIcon.enter().append("path").merge(innerIcon).attr("d", self2.getStatusIconPathString(status)).attr("transform", "translate(-" + radius + ", 0)").attr("class", "innerFill");
        innerIcon.exit().remove();
        icon.exit().remove();
      };
      MeterTitle2.prototype.appendPercentage = function() {
        var dataValue = Tools.getProperty(this.model.getDisplayData(), 0, "value");
        var svg = this.getComponentContainer();
        var title = DOMUtils.appendOrSelect(svg, "text.meter-title");
        var data = Tools.getProperty(this.getOptions(), "meter", "statusBar", "percentageIndicator", "enabled") === true ? [dataValue] : [];
        var percentage = svg.selectAll("text.percent-value").data(data);
        var offset = meter.statusBar.paddingRight;
        percentage.enter().append("text").classed("percent-value", true).merge(percentage).text(function(d) {
          return d + "%";
        }).attr("x", +title.attr("x") + title.node().getComputedTextLength() + offset).attr("y", title.attr("y"));
        percentage.exit().remove();
      };
      MeterTitle2.prototype.truncateTitle = function(title, maxWidth) {
        _super.prototype.truncateTitle.call(this, title, maxWidth);
        var tspan = DOMUtils.appendOrSelect(this.parent, "tspan");
        var offset = meter.statusBar.paddingRight;
        var tspanLength = Math.ceil(tspan.node().getComputedTextLength());
        var percentage = DOMUtils.appendOrSelect(this.parent, "text.percent-value");
        percentage.attr("x", +title.attr("x") + title.node().getComputedTextLength() + tspanLength + offset);
      };
      MeterTitle2.prototype.getMaxTitleWidth = function() {
        var containerBounds = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
        var proportional = Tools.getProperty(this.getOptions(), "meter", "proportional");
        var containerWidth = containerBounds.width ? containerBounds.width : this.parent.node().getAttribute("width");
        if (proportional !== null) {
          var total = DOMUtils.appendOrSelect(this.parent, "text.proportional-meter-total").node();
          var totalWidth = DOMUtils.getSVGElementSize(total, {
            useBBox: true
          }).width;
          return containerWidth - totalWidth - meter.total.paddingLeft;
        } else {
          var percentage = DOMUtils.appendOrSelect(this.parent, "text.percent-value");
          var offset = meter.statusBar.paddingRight;
          var percentageWidth = percentage.node().getComputedTextLength();
          var statusGroup = DOMUtils.appendOrSelect(this.parent, "g.status-indicator").node();
          var statusWidth = DOMUtils.getSVGElementSize(statusGroup, { useBBox: true }).width + meter.status.paddingLeft;
          return containerWidth - percentageWidth - offset - statusWidth;
        }
      };
      MeterTitle2.prototype.getStatusIconPathString = function(status) {
        switch (status) {
          case Statuses.SUCCESS:
            return "M6.875 11.3125 3.75 8.1875 4.74375 7.25 6.875 9.34375 11.50625 4.75 12.5 5.7375 Z";
          case Statuses.DANGER:
            return "M10.7 11.5 4.5 5.3 5.3 4.5 11.5 10.7 Z";
          case Statuses.WARNING:
            return "M7.9375,11.125 C7.41973305,11.125 7,11.544733 7,12.0625 C7,12.580267 7.41973305,13 7.9375,13 C8.45526695,13 8.875,12.580267 8.875,12.0625 C8.875,11.544733 8.45526695,11.125 7.9375,11.125 M7.3125, 3 8.5625, 3 8.5625, 9.875 7.3125, 9.875, 7.3125, 3 Z";
        }
      };
      return MeterTitle2;
    }(Title);
    __extends$1j = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Tooltip = function(_super) {
      __extends$1j(Tooltip2, _super);
      function Tooltip2(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "tooltip";
        _this.renderType = RenderTypes.HTML;
        _this.isEventListenerAdded = false;
        _this.positionService = new Position();
        _this.handleShowTooltip = function(e3) {
          var data = e3.detail.data || e3.detail.items;
          var defaultHTML = _this.getTooltipHTML(e3);
          var tooltipTextContainer = DOMUtils.appendOrSelect(_this.tooltip, "div.content-box");
          if (Tools.getProperty(_this.getOptions(), "tooltip", "customHTML")) {
            if (e3.detail.content) {
              var labelHTML = '<div class="title-tooltip"><p>' + e3.detail.content + "</p></div>";
              tooltipTextContainer.html(labelHTML);
            } else {
              tooltipTextContainer.html(_this.model.getOptions().tooltip.customHTML(data, defaultHTML));
            }
          } else {
            tooltipTextContainer.html(defaultHTML);
          }
          _this.positionTooltip(e3);
          _this.tooltip.classed("hidden", false).attr("aria-hidden", false);
        };
        _this.handleHideTooltip = function() {
          _this.tooltip.classed("hidden", true).attr("aria-hidden", true);
        };
        _this.init();
        return _this;
      }
      Tooltip2.prototype.addTooltipEventListener = function() {
        var _this = this;
        this.services.events.addEventListener(Events$1.Tooltip.MOVE, function(e3) {
          if (_this.tooltip.classed("hidden") === false) {
            _this.positionTooltip(e3);
          }
        });
        this.services.events.addEventListener(Events$1.Tooltip.SHOW, this.handleShowTooltip);
        this.services.events.addEventListener(Events$1.Tooltip.HIDE, this.handleHideTooltip);
        this.services.events.addEventListener(Events$1.Chart.MOUSEOUT, this.handleHideTooltip);
      };
      Tooltip2.prototype.removeTooltipEventListener = function() {
        this.services.events.removeEventListener(Events$1.Tooltip.MOVE, null);
        this.services.events.removeEventListener(Events$1.Tooltip.SHOW, this.handleShowTooltip);
        this.services.events.removeEventListener(Events$1.Tooltip.HIDE, this.handleHideTooltip);
        this.services.events.removeEventListener(Events$1.Chart.MOUSEOUT, this.handleHideTooltip);
      };
      Tooltip2.prototype.getItems = function(e3) {
        if (e3.detail.items) {
          return e3.detail.items;
        }
        return [];
      };
      Tooltip2.prototype.formatItems = function(items) {
        var _this = this;
        var options2 = this.getOptions();
        var truncationType = Tools.getProperty(options2, "tooltip", "truncation", "type");
        var truncationThreshold = Tools.getProperty(options2, "tooltip", "truncation", "threshold");
        var truncationNumCharacter = Tools.getProperty(options2, "tooltip", "truncation", "numCharacter");
        if (truncationType !== TruncationTypes.NONE) {
          return items.map(function(item) {
            var labelIconSize = item.labelIcon ? 12 : 0;
            item.value = item.value ? _this.valueFormatter(item.value, item.label) : item.value;
            if (item.label && item.label.length + labelIconSize > truncationThreshold) {
              item.label = Tools.truncateLabel(item.label, truncationType, truncationNumCharacter);
            }
            if (item.value && item.value.length > truncationThreshold) {
              item.value = Tools.truncateLabel(item.value, truncationType, truncationNumCharacter);
            }
            return item;
          });
        }
        return items;
      };
      Tooltip2.prototype.getTooltipHTML = function(e3) {
        var defaultHTML;
        if (e3.detail.content) {
          defaultHTML = '<div class="title-tooltip"><p>' + e3.detail.content + "</p></div>";
        } else {
          var items = this.getItems(e3);
          var formattedItems = this.formatItems(items);
          defaultHTML = '<ul class="multi-tooltip">' + formattedItems.map(function(item) {
            return '<li>\n							<div class="datapoint-tooltip ' + (item.bold ? "bold" : "") + '">\n								' + (item.class ? '<div class="tooltip-color ' + item.class + '"></div>' : "") + "\n								" + (item.color ? '<div style="background-color: ' + item.color + '" class="tooltip-color"></div>' : "") + '\n								<div class="label">\n								<p>' + (item.label || "") + "</p>\n								" + (item.labelIcon ? '<span class="label-icon"/>' + item.labelIcon + "</span>" : "") + "\n								</div>\n								" + (item.value === void 0 || item.value === null ? "" : '<p class="value"/>' + item.value + "</p>") + "\n							</div>\n						</li>";
          }).join("") + "</ul>";
        }
        return defaultHTML;
      };
      Tooltip2.prototype.valueFormatter = function(value2, label) {
        var options2 = this.getOptions();
        var valueFormatter = Tools.getProperty(options2, "tooltip", "valueFormatter");
        if (valueFormatter) {
          return valueFormatter(value2, label);
        }
        if (typeof value2.getTime === "function") {
          return format2(value2, "MMM d, yyyy");
        }
        return value2.toLocaleString();
      };
      Tooltip2.prototype.render = function() {
        var options2 = this.getOptions();
        var isTooltipEnabled = Tools.getProperty(options2, "tooltip", "enabled");
        if (isTooltipEnabled) {
          var holder = select(this.services.domUtils.getHolder());
          var chartprefix = Tools.getProperty(options2, "style", "prefix");
          this.tooltip = DOMUtils.appendOrSelect(holder, "div." + settings$1.prefix + "--" + chartprefix + "--tooltip");
          this.tooltip.style("max-width", null).attr("role", "tooltip");
          if (!this.isEventListenerAdded) {
            this.addTooltipEventListener();
            this.isEventListenerAdded = true;
          }
          this.tooltip.classed("hidden", true);
        } else if (!isTooltipEnabled && this.isEventListenerAdded) {
          this.removeTooltipEventListener();
          this.isEventListenerAdded = false;
        }
      };
      Tooltip2.prototype.positionTooltip = function(e3) {
        var holder = this.services.domUtils.getHolder();
        var target = this.tooltip.node();
        var options2 = this.getOptions();
        var isTopZoomBarEnabled = Tools.getProperty(options2, "zoomBar", "top", "enabled");
        var mouseRelativePos = Tools.getProperty(e3, "detail", "mousePosition");
        if (!mouseRelativePos) {
          mouseRelativePos = pointer(Tools.getProperty(e3, "detail", "event"), holder);
        } else {
          var zoombarType = Tools.getProperty(options2, "zoomBar", "top", "type");
          var zoombarHeight = zoomBar.height[zoombarType];
          if (isTopZoomBarEnabled) {
            mouseRelativePos[1] += zoombarHeight + zoomBar.spacerHeight;
          }
        }
        var pos;
        var holderWidth = holder.offsetWidth;
        var holderHeight = holder.offsetHeight;
        var bestPlacementOption;
        if (mouseRelativePos[0] / holderWidth > 0.9) {
          bestPlacementOption = PLACEMENTS.LEFT;
        } else if (mouseRelativePos[0] / holderWidth < 0.1) {
          bestPlacementOption = PLACEMENTS.RIGHT;
        } else {
          bestPlacementOption = this.positionService.findBestPlacementAt({
            left: mouseRelativePos[0],
            top: mouseRelativePos[1]
          }, target, [
            PLACEMENTS.RIGHT,
            PLACEMENTS.LEFT,
            PLACEMENTS.TOP,
            PLACEMENTS.BOTTOM
          ], function() {
            return {
              width: holderWidth,
              height: holderHeight
            };
          });
        }
        var horizontalOffset = tooltips.horizontalOffset;
        if (bestPlacementOption === PLACEMENTS.LEFT) {
          horizontalOffset *= -1;
        }
        pos = this.positionService.findPositionAt({
          left: mouseRelativePos[0] + horizontalOffset,
          top: mouseRelativePos[1]
        }, target, bestPlacementOption);
        this.positionService.setElement(target, pos);
      };
      return Tooltip2;
    }(Component);
    __extends$1i = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$i = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    AxisChartsTooltip = function(_super) {
      __extends$1i(AxisChartsTooltip2, _super);
      function AxisChartsTooltip2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AxisChartsTooltip2.prototype.getItems = function(e3) {
        var _this = this;
        if (e3.detail.items) {
          return e3.detail.items;
        }
        var data = e3.detail.data;
        if (!data.length || !data[0]) {
          return [];
        }
        var options2 = this.getOptions();
        var cartesianScales = this.services.cartesianScales;
        var domainIdentifier = cartesianScales.getDomainIdentifier();
        var dualAxes = cartesianScales.isDualAxes();
        var groupMapsTo = options2.data.groupMapsTo;
        var domainLabel = cartesianScales.getDomainLabel();
        var rangeLabel = cartesianScales.getRangeLabel();
        var domainValue = data[0][domainIdentifier];
        var items;
        if (data.length === 1) {
          var datum2 = data[0];
          var rangeIdentifier = cartesianScales.getRangeIdentifier(datum2);
          if (dualAxes) {
            var position = cartesianScales.getRangeAxisPosition({
              datum: datum2,
              groups: [datum2[groupMapsTo]]
            });
            rangeLabel = cartesianScales.getScaleLabel(position);
          }
          var value2 = datum2[rangeIdentifier];
          items = __spreadArrays$i([
            {
              label: domainLabel,
              value: domainValue
            }
          ], Array.isArray(value2) && value2.length === 2 ? [
            {
              label: "Start",
              value: value2[0]
            },
            {
              label: "End",
              value: value2[1]
            }
          ] : [
            {
              label: rangeLabel,
              value: datum2[rangeIdentifier]
            }
          ]);
          if (e3.detail.additionalItems) {
            e3.detail.additionalItems.forEach(function(additionalItem) {
              return items.push({
                label: additionalItem.label,
                value: additionalItem.value
              });
            });
          }
          items.push({
            label: options2.tooltip.groupLabel,
            value: datum2[groupMapsTo],
            color: this.model.getFillColor(datum2[groupMapsTo]),
            class: this.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.TOOLTIP],
              dataGroupName: datum2[groupMapsTo]
            })
          });
        } else if (data.length > 1) {
          items = [
            {
              label: domainLabel,
              value: domainValue
            }
          ];
          items = items.concat(data.map(function(datum3) {
            var value3 = datum3[cartesianScales.getRangeIdentifier(datum3)];
            return {
              label: datum3[groupMapsTo],
              value: Array.isArray(value3) && value3.length === 2 ? value3[0] + " - " + value3[1] : value3,
              color: _this.model.getFillColor(datum3[groupMapsTo]),
              class: _this.model.getColorClassName({
                classNameTypes: [ColorClassNameTypes.TOOLTIP],
                dataGroupName: datum3[groupMapsTo]
              })
            };
          }).sort(function(a, b) {
            return b.value - a.value;
          }));
          if (!dualAxes && Tools.getProperty(options2, "tooltip", "showTotal") === true) {
            var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
            items.push({
              label: get$3(options2, "tooltip.totalLabel") || "Total",
              value: data.reduce(function(accumulator, datum3) {
                return accumulator + datum3[rangeIdentifier_1];
              }, 0),
              bold: true
            });
          }
        }
        return items;
      };
      return AxisChartsTooltip2;
    }(Tooltip);
    __extends$1h = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ChartClip = function(_super) {
      __extends$1h(ChartClip2, _super);
      function ChartClip2(model, services, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "chart-clip";
        _this.renderType = RenderTypes.SVG;
        _this.chartClipId = "chart-clip-id-" + Math.floor(Math.random() * 99999999999);
        _this.init();
        return _this;
      }
      ChartClip2.prototype.init = function() {
        this.model.set({ chartClipId: this.chartClipId }, { skipUpdate: true });
      };
      ChartClip2.prototype.render = function(animate) {
        this.createClipPath();
      };
      ChartClip2.prototype.createClipPath = function() {
        var svg = this.parent;
        var cartesianScales = this.services.cartesianScales;
        var mainXScale = cartesianScales.getMainXScale();
        var mainYScale = cartesianScales.getMainYScale();
        var _a22 = mainXScale.range(), xScaleStart = _a22[0], xScaleEnd = _a22[1];
        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        this.chartClipPath = DOMUtils.appendOrSelect(svg, "clipPath." + this.type).attr("id", this.chartClipId);
        var clipRect = DOMUtils.appendOrSelect(this.chartClipPath, "rect." + this.type);
        clipRect.attr("x", xScaleStart).attr("y", yScaleStart).attr("width", xScaleEnd - xScaleStart).attr("height", yScaleEnd - yScaleStart);
        this.chartClipPath.merge(clipRect).lower();
      };
      return ChartClip2;
    }(Component);
    __extends$1g = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CanvasChartClip = function(_super) {
      __extends$1g(CanvasChartClip2, _super);
      function CanvasChartClip2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "canvas-chart-clip";
        _this.chartClipId = "canvas-chart-clip-id-" + Math.floor(Math.random() * 99999999999);
        return _this;
      }
      CanvasChartClip2.prototype.createClipPath = function() {
        var svg = this.parent;
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        this.chartClipPath = DOMUtils.appendOrSelect(svg, "clipPath." + this.type).attr("id", this.chartClipId);
        var clipRect = DOMUtils.appendOrSelect(this.chartClipPath, "rect." + this.type);
        clipRect.attr("x", 0).attr("y", 0).attr("width", width).attr("height", height);
        this.chartClipPath.merge(clipRect).lower();
      };
      return CanvasChartClip2;
    }(ChartClip);
    __extends$1f = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __rest = globalThis && globalThis.__rest || function(s3, e3) {
      var t2 = {};
      for (var p in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p) && e3.indexOf(p) < 0)
          t2[p] = s3[p];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p = Object.getOwnPropertySymbols(s3); i2 < p.length; i2++) {
          if (e3.indexOf(p[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p[i2]))
            t2[p[i2]] = s3[p[i2]];
        }
      return t2;
    };
    Highlight = function(_super) {
      __extends$1f(Highlight2, _super);
      function Highlight2(model, services) {
        var _this = _super.call(this, model, services) || this;
        _this.type = "highlight";
        _this.renderType = RenderTypes.SVG;
        _this.positionService = new Position();
        _this.highlightStrokeWidth = 1;
        return _this;
      }
      Highlight2.prototype.render = function(animate) {
        if (animate === void 0) {
          animate = false;
        }
        var axesOptions = Tools.getProperty(this.getOptions(), "axes");
        var highlightData = [];
        Object.keys(axesOptions).forEach(function(axisPosition) {
          if (Object.values(AxisPositions).includes(axisPosition)) {
            var axisOptions = axesOptions[axisPosition];
            if (axisOptions.highlights && axisOptions.highlights.data.length > 0) {
              highlightData.push({
                axisPosition,
                highlightStartMapsTo: axisOptions.highlights.highlightStartMapsTo,
                highlightEndMapsTo: axisOptions.highlights.highlightEndMapsTo,
                labelMapsTo: axisOptions.highlights.labelMapsTo,
                highlight: axisOptions.highlights.data,
                color: axisOptions.highlights.color
              });
            }
          }
        });
        var svg = this.getComponentContainer({ withinChartClip: true });
        var highlightAxisGroups = svg.selectAll("g.axis-highlight").data(highlightData, function(highlightData2) {
          return highlightData2.axisPosition;
        });
        highlightAxisGroups.exit().attr("opacity", 0).remove();
        var highlightAxisGroupsEnter = highlightAxisGroups.enter().append("g");
        var highlightAxisGroupsMerge = highlightAxisGroupsEnter.merge(highlightAxisGroups);
        highlightAxisGroupsMerge.attr("class", function(d) {
          return "axis-highlight " + d.axisPosition;
        });
        var highlightGroups = highlightAxisGroupsMerge.selectAll("g.highlight-group").data(function(d) {
          return d.highlight.map(function(highlight) {
            highlight.axisPosition = d.axisPosition;
            highlight.highlightStartMapsTo = d.highlightStartMapsTo;
            highlight.labelMapsTo = d.labelMapsTo;
            highlight.color = d.color;
            highlight.highlightEndMapsTo = d.highlightEndMapsTo;
            return highlight;
          });
        });
        highlightGroups.exit().attr("opacity", 0).remove();
        var highlightGroupsEnter = highlightGroups.enter().append("g");
        highlightGroupsEnter.append("rect").attr("class", "highlight-bar");
        highlightGroupsEnter.append("line").attr("class", "highlight-line");
        var highlightGroupsMerge = highlightGroupsEnter.merge(highlightGroups);
        highlightGroupsMerge.attr("class", "highlight-group");
        var self2 = this;
        highlightAxisGroupsMerge.each(function(_a22) {
          var axisPosition = _a22.axisPosition;
          var mainXScale = self2.services.cartesianScales.getMainXScale();
          var mainYScale = self2.services.cartesianScales.getMainYScale();
          var _b = mainXScale.range(), xScaleStart = _b[0], xScaleEnd = _b[1];
          var _c = mainYScale.range(), yScaleEnd = _c[0], yScaleStart = _c[1];
          var cartesianScales = self2.services.cartesianScales;
          var orientation = cartesianScales.getOrientation();
          var getDomainValue = function(d) {
            return cartesianScales.getDomainValue(d);
          };
          var getRangeValue = function(d) {
            return cartesianScales.getRangeValue(d);
          };
          var _d2 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _d2[0], getYValue = _d2[1];
          var group = select(this);
          if (axisPosition === AxisPositions.TOP || axisPosition === AxisPositions.BOTTOM) {
            group.selectAll("rect.highlight-bar").transition().call(function(t2) {
              return self2.services.transitions.setupTransition({
                transition: t2,
                name: "highlight-bar-update",
                animate
              });
            }).attr("y", Math.max(yScaleStart + self2.highlightStrokeWidth, 0)).attr("height", Math.max(yScaleEnd - 2 * self2.highlightStrokeWidth, 0)).attr("x", function(_a32) {
              var highlightStartMapsTo = _a32.highlightStartMapsTo, d = __rest(_a32, ["highlightStartMapsTo"]);
              return getXValue(d[highlightStartMapsTo]);
            }).attr("width", function(_a32) {
              var highlightStartMapsTo = _a32.highlightStartMapsTo, highlightEndMapsTo = _a32.highlightEndMapsTo, d = __rest(_a32, ["highlightStartMapsTo", "highlightEndMapsTo"]);
              return Math.max(getXValue(d[highlightEndMapsTo]) - getXValue(d[highlightStartMapsTo]), 0);
            }).style("stroke", function(_a32) {
              var color2 = _a32.color, labelMapsTo = _a32.labelMapsTo, data = __rest(_a32, ["color", "labelMapsTo"]);
              return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
            }).style("stroke-dasharray", "2, 2").attr("stroke-width", self2.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", function(_a32) {
              var color2 = _a32.color, labelMapsTo = _a32.labelMapsTo, data = __rest(_a32, ["color", "labelMapsTo"]);
              return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
            });
          } else {
            group.selectAll("rect.highlight-bar").transition().call(function(t2) {
              return self2.services.transitions.setupTransition({
                transition: t2,
                name: "highlight-bar-update",
                animate
              });
            }).attr("x", xScaleStart).attr("width", Math.max(xScaleEnd - xScaleStart, 0)).attr("y", function(_a32) {
              var highlightEndMapsTo = _a32.highlightEndMapsTo, d = __rest(_a32, ["highlightEndMapsTo"]);
              return getYValue(d[highlightEndMapsTo]);
            }).attr("height", function(_a32) {
              var highlightStartMapsTo = _a32.highlightStartMapsTo, highlightEndMapsTo = _a32.highlightEndMapsTo, d = __rest(_a32, ["highlightStartMapsTo", "highlightEndMapsTo"]);
              return Math.max(getYValue(d[highlightStartMapsTo]) - getYValue(d[highlightEndMapsTo]), 0);
            }).style("stroke", function(_a32) {
              var color2 = _a32.color, labelMapsTo = _a32.labelMapsTo, data = __rest(_a32, ["color", "labelMapsTo"]);
              return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
            }).style("stroke-dasharray", "2, 2").attr("stroke-width", self2.highlightStrokeWidth + "px").style("fill-opacity", 0.1).style("fill", function(_a32) {
              var color2 = _a32.color, labelMapsTo = _a32.labelMapsTo, data = __rest(_a32, ["color", "labelMapsTo"]);
              return color2 && color2.scale[data[labelMapsTo]] ? color2.scale[data[labelMapsTo]] : null;
            });
          }
        });
      };
      return Highlight2;
    }(Component);
    __extends$1e = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Area = function(_super) {
      __extends$1e(Area2, _super);
      function Area2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "area";
        _this.renderType = RenderTypes.SVG;
        _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          _this.parent.selectAll("path.area").transition("legend-hover-area").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-area"
            });
          }).attr("opacity", function(group) {
            if (group.name !== hoveredElement.datum()["name"]) {
              return area$1.opacity.unselected;
            }
            return area$1.opacity.selected;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.area").transition("legend-mouseout-area").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-area"
            });
          }).attr("opacity", area$1.opacity.selected);
        };
        return _this;
      }
      Area2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Area2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.getOptions();
        var domain = [0, 0];
        var cartesianScales = this.services.cartesianScales;
        var orientation = cartesianScales.getOrientation();
        var areaGenerator = area().curve(this.services.curves.getD3Curve()).defined(function(datum2, i2) {
          var rangeIdentifier = cartesianScales.getRangeIdentifier();
          var value2 = datum2[rangeIdentifier];
          if (value2 === null || value2 === void 0) {
            return false;
          }
          return true;
        });
        var groupedData = this.model.getGroupedData(this.configs.groups);
        var bounds = Tools.getProperty(options2, "bounds");
        var boundsEnabled = bounds && groupedData && groupedData.length === 1;
        if (!boundsEnabled && bounds) {
          console.warn("Bounds can only be shown when having 1 single datagroup, you've supplied " + groupedData.length);
        }
        var upperBoundRangeValue = 0;
        var includeZeroInRangeValue = function(position, domain2) {
          if (Tools.getProperty(options2, "axes", position, "includeZero") === false) {
            if (domain2[0] > 0 && domain2[1] > 0) {
              upperBoundRangeValue = domain2[0];
            }
          }
        };
        var upperBound = function(d, i2) {
          return boundsEnabled ? cartesianScales.getBoundedScaledValues(d, i2)[0] : cartesianScales.getRangeValue(upperBoundRangeValue);
        };
        var lowerBound = function(d, i2) {
          return boundsEnabled ? cartesianScales.getBoundedScaledValues(d, i2)[1] : cartesianScales.getRangeValue(d, i2);
        };
        if (orientation === CartesianOrientations.VERTICAL) {
          domain = cartesianScales.getMainYScale().domain();
          includeZeroInRangeValue(cartesianScales.getMainYAxisPosition(), domain);
          areaGenerator.x(function(d, i2) {
            return cartesianScales.getDomainValue(d, i2);
          }).y0(function(d, i2) {
            return upperBound(d, i2);
          }).y1(function(d, i2) {
            return lowerBound(d, i2);
          });
        } else {
          domain = cartesianScales.getMainXScale().domain();
          includeZeroInRangeValue(cartesianScales.getMainXAxisPosition(), domain);
          areaGenerator.x0(function(d, i2) {
            return upperBound(d, i2);
          }).x1(function(d, i2) {
            return lowerBound(d, i2);
          }).y(function(d, i2) {
            return cartesianScales.getDomainValue(d, i2);
          });
        }
        var isGradientEnabled = Tools.getProperty(options2, "color", "gradient", "enabled");
        var isGradientAllowed = groupedData && groupedData.length === 1 && isGradientEnabled;
        if (groupedData.length > 1 && isGradientEnabled) {
          console.error("Gradients can only be enabled when having 1 single dataset");
        }
        var areas = svg.selectAll("path.area").data(groupedData, function(group) {
          return group.name;
        });
        var chartMainContainer = select(this.services.domUtils.getMainContainer());
        areas.exit().attr("opacity", 0).remove();
        if (!groupedData.length) {
          return;
        }
        if (isGradientAllowed) {
          var strokePathElement = chartMainContainer.select("path." + this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            dataGroupName: groupedData[0].name
          })).node();
          var colorValue = void 0;
          if (strokePathElement) {
            colorValue = getComputedStyle(strokePathElement, null).getPropertyValue("stroke");
          } else {
            var sparklineColorObject = Tools.getProperty(this.model.getOptions(), "color", "scale");
            if (sparklineColorObject !== null) {
              var sparklineColorObjectKeys = Object.keys(sparklineColorObject);
              colorValue = sparklineColorObject[sparklineColorObjectKeys[0]];
            }
          }
          GradientUtils.appendOrUpdateLinearGradient({
            svg: this.parent,
            id: this.services.domUtils.generateElementIDString(groupedData[0].name.replace(" ", "") + "_" + this.gradient_id),
            x1: "0%",
            x2: "0%",
            y1: "0%",
            y2: "100%",
            stops: GradientUtils.getStops(domain, colorValue)
          });
        } else {
          if (!this.parent.selectAll("defs linearGradient").empty()) {
            this.parent.selectAll("defs linearGradient").each(function() {
              this.parentNode.remove();
            });
          }
        }
        var self2 = this;
        var enteringAreas = areas.enter().append("path");
        if (isGradientAllowed) {
          enteringAreas.merge(areas).style("fill", function(group) {
            return "url(#" + _this.services.domUtils.generateElementIDString(group.name.replace(" ", "") + "_" + _this.gradient_id) + ")";
          }).attr("class", "area").attr("class", function(group) {
            return _this.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.FILL],
              dataGroupName: group.name,
              originalClassName: "area"
            });
          }).attr("d", function(group) {
            var data = group.data;
            return areaGenerator(data);
          });
        } else {
          enteringAreas.attr("opacity", 0).merge(areas).attr("class", "area").attr("class", function(group) {
            return _this.model.getColorClassName({
              classNameTypes: [
                ColorClassNameTypes.FILL,
                ColorClassNameTypes.STROKE
              ],
              dataGroupName: group.name,
              originalClassName: "area"
            });
          }).style("fill", function(group) {
            return self2.model.getFillColor(group.name);
          }).transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "area-update-enter",
              animate
            });
          }).attr("opacity", boundsEnabled ? 1 : area$1.opacity.selected).attr("d", function(group) {
            var data = group.data;
            return areaGenerator(data);
          });
          if (boundsEnabled) {
            enteringAreas.attr("fill-opacity", area$1.opacity.selected).style("stroke", function(group) {
              return self2.model.getStrokeColor(group.name);
            }).style("stroke-dasharray", "2, 2").attr("stroke-width", 0.7 + "px");
          }
        }
      };
      Area2.prototype.destroy = function() {
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return Area2;
    }(Component);
    __extends$1d = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    StackedArea = function(_super) {
      __extends$1d(StackedArea2, _super);
      function StackedArea2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "area-stacked";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var options2 = _this.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          _this.parent.selectAll("path.area").transition("legend-hover-area").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-area"
            });
          }).attr("opacity", function(d) {
            if (Tools.getProperty(d, 0, groupMapsTo) !== hoveredElement.datum().name) {
              return area$1.opacity.unselected;
            }
            return area$1.opacity.selected;
          });
        };
        _this.handleLegendMouseOut = function() {
          _this.parent.selectAll("path.area").transition("legend-mouseout-area").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-area"
            });
          }).attr("opacity", area$1.opacity.selected);
        };
        return _this;
      }
      StackedArea2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      StackedArea2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var svg = this.getComponentContainer({ withinChartClip: true });
        var self2 = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var percentage = Object.keys(options2.axes).some(function(axis2) {
          return options2.axes[axis2].percentage;
        });
        var stackedData = this.model.getStackedData({
          percentage,
          groups: this.configs.groups
        });
        var firstDatum = Tools.getProperty(stackedData, 0, 0);
        var domainAxisPosition = this.services.cartesianScales.getDomainAxisPosition({ firstDatum });
        var rangeAxisPosition = this.services.cartesianScales.getRangeAxisPosition({ firstDatum });
        var mainYScale = this.services.cartesianScales.getScaleByPosition(rangeAxisPosition);
        var areas = svg.selectAll("path.area").data(stackedData, function(d) {
          return Tools.getProperty(d, 0, groupMapsTo);
        });
        this.areaGenerator = area().x(function(d, i2) {
          return _this.services.cartesianScales.getValueThroughAxisPosition(domainAxisPosition, d.data.sharedStackKey, i2);
        }).y0(function(d) {
          return mainYScale(d[0]);
        }).y1(function(d) {
          return mainYScale(d[1]);
        }).curve(this.services.curves.getD3Curve());
        areas.exit().attr("opacity", 0).remove();
        var enteringAreas = areas.enter().append("path").attr("opacity", 0);
        enteringAreas.merge(areas).data(stackedData, function(d) {
          return Tools.getProperty(d, 0, groupMapsTo);
        }).attr("class", "area").attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: Tools.getProperty(d, 0, groupMapsTo),
            originalClassName: "area"
          });
        }).style("fill", function(d) {
          return self2.model.getFillColor(Tools.getProperty(d, 0, groupMapsTo));
        }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "area").attr("aria-label", function(d) {
          return Tools.getProperty(d, 0, groupMapsTo);
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "area-update-enter",
            animate
          });
        }).attr("opacity", area$1.opacity.selected).attr("d", this.areaGenerator);
      };
      return StackedArea2;
    }(Component);
    __extends$1c = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Bar = function(_super) {
      __extends$1c(Bar2, _super);
      function Bar2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Bar2.prototype.getBarWidth = function(allDataLabels) {
        var options2 = this.getOptions();
        if (options2.bars.width) {
          return options2.bars.width;
        }
        var numberOfDatapoints = this.model.getDisplayData().length;
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var chartWidth = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }).width;
        if (!mainXScale.step) {
          var spacingFactor = Tools.getProperty(options2, "bars", "spacingFactor");
          return Math.min(options2.bars.maxWidth, chartWidth * spacingFactor / numberOfDatapoints);
        }
        return Math.min(options2.bars.maxWidth, mainXScale.step() / 2);
      };
      Bar2.prototype.isOutsideZoomedDomain = function(x0, x1) {
        var dataCount = this.model.getDisplayData().length;
        if (dataCount <= 1) {
          return false;
        }
        var zoomDomain = this.model.get("zoomDomain");
        if (zoomDomain !== void 0) {
          var domainScale = this.services.cartesianScales.getDomainScale();
          return x0 < domainScale(zoomDomain[0]) || x1 > domainScale(zoomDomain[1]);
        }
        return false;
      };
      return Bar2;
    }(Component);
    __extends$1b = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    SimpleBar = function(_super) {
      __extends$1b(SimpleBar2, _super);
      function SimpleBar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "simple-bar";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-simple-bar"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-simple-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      SimpleBar2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      SimpleBar2.prototype.render = function(animate) {
        var _this = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var data = this.model.getDisplayData(this.configs.groups);
        var orientation = this.services.cartesianScales.getOrientation();
        var bars = svg.selectAll("path.bar").data(data, function(datum2) {
          return datum2[groupMapsTo];
        });
        bars.exit().attr("opacity", 0).remove();
        var barsEnter = bars.enter().append("path").attr("opacity", 0);
        barsEnter.merge(bars).classed("bar", true).attr("width", this.getBarWidth.bind(this)).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "bar-update-enter",
            animate
          });
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: "bar"
          });
        }).style("fill", function(d) {
          return _this.model.getFillColor(d[groupMapsTo]);
        }).attr("d", function(d, i2) {
          var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier();
          var barWidth = _this.getBarWidth();
          var value2 = d[rangeIdentifier];
          var x0 = _this.services.cartesianScales.getDomainValue(d, i2) - barWidth / 2;
          var x1 = x0 + barWidth;
          var y0, y1;
          if (Array.isArray(value2) && value2.length === 2) {
            y0 = _this.services.cartesianScales.getRangeValue(value2[0]);
            y1 = _this.services.cartesianScales.getRangeValue(value2[1], i2);
          } else {
            var rangeScale = _this.services.cartesianScales.getRangeScale();
            var yScaleDomainStart = rangeScale.domain()[0];
            y0 = _this.services.cartesianScales.getRangeValue(Math.max(0, yScaleDomainStart));
            y1 = _this.services.cartesianScales.getRangeValue(d, i2);
          }
          var difference = Math.abs(y1 - y0);
          if (difference !== 0 && difference < 2) {
            if (value2 > 0 && orientation === CartesianOrientations.VERTICAL || value2 < 0 && orientation === CartesianOrientations.HORIZONTAL) {
              y1 = y0 - 2;
            } else {
              y1 = y0 + 2;
            }
          }
          if (_this.isOutsideZoomedDomain(x0, x1)) {
            return;
          }
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
          return d.value;
        });
        this.addEventListeners();
      };
      SimpleBar2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            data: [datum2]
          });
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      SimpleBar2.prototype.destroy = function() {
        this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return SimpleBar2;
    }(Bar);
    __extends$1a = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    GroupedBar = function(_super) {
      __extends$1a(GroupedBar2, _super);
      function GroupedBar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "grouped-bar";
        _this.renderType = RenderTypes.SVG;
        _this.padding = 5;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-bar"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      GroupedBar2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      GroupedBar2.prototype.render = function(animate) {
        var _this = this;
        var displayData = this.model.getDisplayData(this.configs.groups);
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        this.setGroupScale();
        var svg = this.getComponentContainer({ withinChartClip: true });
        var allDataLabels = Tools.removeArrayDuplicates(displayData.map(function(datum2) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
          return datum2[domainIdentifier] && typeof datum2[domainIdentifier].toString === "function" ? datum2[domainIdentifier].toString() : datum2[domainIdentifier];
        }));
        var barGroups = svg.selectAll("g.bars").data(allDataLabels, function(label) {
          return label;
        });
        barGroups.exit().attr("opacity", 0).remove();
        var barGroupsEnter = barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP).attr("data-name", "bars");
        var allBarGroups = barGroupsEnter.merge(barGroups);
        allBarGroups.transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "bar-group-update-enter",
            animate
          });
        }).attr("transform", function(label, i2) {
          var scaleValue = _this.services.cartesianScales.getDomainValue(label, i2);
          var translateBy = scaleValue - _this.getGroupWidth() / 2;
          if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
            return "translate(" + translateBy + ", 0)";
          } else {
            return "translate(0, " + translateBy + ")";
          }
        });
        var bars = allBarGroups.selectAll("path.bar").data(function(label) {
          return _this.getDataCorrespondingToLabel(label);
        }, function(d) {
          return d[groupMapsTo];
        });
        bars.exit().attr("opacity", 0).remove();
        var barsEnter = bars.enter().append("path").attr("opacity", 0);
        barsEnter.merge(bars).classed("bar", true).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "bar-update-enter",
            animate
          });
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: "bar"
          });
        }).style("fill", function(d) {
          return _this.model.getFillColor(d[groupMapsTo]);
        }).attr("d", function(d) {
          var startX = _this.groupScale(d[groupMapsTo]);
          var barWidth = _this.getBarWidth();
          var x0 = startX;
          var x1 = startX + barWidth;
          var rangeAxis = _this.services.cartesianScales.getRangeAxisPosition({ datum: d });
          var y0 = _this.services.cartesianScales.getValueThroughAxisPosition(rangeAxis, 0);
          var y1 = _this.services.cartesianScales.getRangeValue(d);
          if (_this.isOutsideZoomedDomain(x0, x1)) {
            return;
          }
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
        }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
          return d.value;
        });
        this.addEventListeners();
      };
      GroupedBar2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            data: [datum2]
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      GroupedBar2.prototype.destroy = function() {
        this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      GroupedBar2.prototype.getDataCorrespondingToLabel = function(label) {
        var _this = this;
        var displayData = this.model.getDisplayData(this.configs.groups);
        return displayData.filter(function(datum2) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
          return datum2[domainIdentifier] === label;
        });
      };
      GroupedBar2.prototype.getGroupWidth = function() {
        var activeData = this.model.getGroupedData(this.configs.groups);
        var totalGroupPadding = this.getTotalGroupPadding();
        return this.getBarWidth() * activeData.length + totalGroupPadding;
      };
      GroupedBar2.prototype.getTotalGroupPadding = function() {
        var activeData = this.model.getGroupedData(this.configs.groups);
        if (activeData.length === 1) {
          return 0;
        }
        var domainScale = this.services.cartesianScales.getDomainScale();
        var padding = Math.min(5, 5 * (domainScale.step() / 70));
        return padding * (activeData.length - 1);
      };
      GroupedBar2.prototype.getBarWidth = function() {
        var options2 = this.getOptions();
        var providedWidth = Tools.getProperty(options2, "bars", "width");
        var providedMaxWidth = Tools.getProperty(options2, "bars", "maxWidth");
        if (providedWidth !== null) {
          if (providedMaxWidth === null || providedWidth <= providedMaxWidth) {
            return providedWidth;
          }
        }
        var activeData = this.model.getGroupedData(this.configs.groups);
        var numOfActiveDataGroups = activeData.length;
        var totalGroupPadding = this.getTotalGroupPadding();
        var domainScale = this.services.cartesianScales.getDomainScale();
        return Math.min(providedMaxWidth, (domainScale.step() - totalGroupPadding) / numOfActiveDataGroups);
      };
      GroupedBar2.prototype.setGroupScale = function() {
        var activeData = this.model.getActiveDataGroupNames(this.configs.groups);
        this.groupScale = band().domain(activeData).rangeRound([0, this.getGroupWidth()]);
      };
      return GroupedBar2;
    }(Bar);
    __extends$19 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    StackedBar = function(_super) {
      __extends$19(StackedBar2, _super);
      function StackedBar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "stacked-bar";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.model.getOptions().data.groupMapsTo;
          _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-bar"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      StackedBar2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      StackedBar2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var stackData = this.model.getStackedData({
          groups: this.configs.groups,
          divergent: true
        });
        var activeDataGroupNames = this.model.getActiveDataGroupNames();
        var barGroups = svg.selectAll("g.bars").data(stackData, function(d) {
          return Tools.getProperty(d, 0, groupMapsTo);
        });
        barGroups.exit().attr("opacity", 0).remove();
        barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP).attr("data-name", "bars");
        var bars = svg.selectAll("g.bars").selectAll("path.bar").data(function(d) {
          return d;
        }, function(d) {
          return d.data.sharedStackKey;
        });
        bars.exit().remove();
        bars.enter().append("path").merge(bars).classed("bar", true).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "bar-update-enter",
            animate
          });
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: "bar"
          });
        }).style("fill", function(d) {
          return _this.model.getFillColor(d[groupMapsTo]);
        }).attr("d", function(d, i2) {
          var key2 = d.data.sharedStackKey;
          var barWidth = _this.getBarWidth();
          var x0 = _this.services.cartesianScales.getDomainValue(key2, i2) - barWidth / 2;
          var x1 = x0 + barWidth;
          var y0 = _this.services.cartesianScales.getRangeValue(d[0], i2);
          var y1 = _this.services.cartesianScales.getRangeValue(d[1], i2);
          if (_this.isOutsideZoomedDomain(x0, x1)) {
            return;
          }
          if (Math.abs(y1 - y0) > 0 && Math.abs(y1 - y0) > options2.bars.dividerSize) {
            var barIsNegative = d[0] < 0 && d[1] <= 0;
            if (barIsNegative && activeDataGroupNames.length > 1) {
              if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
                y1 += d[1] === 0 ? 2 : 1;
              } else {
                y1 -= 1;
              }
            } else if (!barIsNegative) {
              if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
                y1 += 1;
              } else {
                y1 -= 1;
              }
            }
          }
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
        }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
          return d[1] - d[0];
        });
        this.addEventListeners();
      };
      StackedBar2.prototype.addEventListeners = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var self2 = this;
        this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
          var _a22;
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          var displayData = self2.model.getDisplayData(self2.configs.groups);
          var matchingDataPoint = displayData.find(function(d) {
            var domainIdentifier2 = self2.services.cartesianScales.getDomainIdentifier(d);
            var rangeIdentifier2 = self2.services.cartesianScales.getRangeIdentifier(d);
            return d[rangeIdentifier2] === datum2.data[datum2[groupMapsTo]] && d[domainIdentifier2].toString() === datum2.data.sharedStackKey && d[groupMapsTo] === datum2[groupMapsTo];
          });
          if (matchingDataPoint === void 0) {
            var domainIdentifier = self2.services.cartesianScales.getDomainIdentifier();
            var rangeIdentifier = self2.services.cartesianScales.getRangeIdentifier();
            matchingDataPoint = (_a22 = {}, _a22[domainIdentifier] = datum2.data.sharedStackKey, _a22[rangeIdentifier] = datum2.data[datum2[groupMapsTo]], _a22[groupMapsTo] = datum2[groupMapsTo], _a22);
          }
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            data: [matchingDataPoint]
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      StackedBar2.prototype.getBarWidth = function() {
        var options2 = this.getOptions();
        if (Tools.getProperty(options2, "bars", "width")) {
          return options2.bars.width;
        }
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var chartWidth = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }).width;
        var numberOfDomainValues = this.model.getStackKeys().length;
        var spacingFactor = Tools.getProperty(options2, "bars", "spacingFactor");
        if (!mainXScale.step) {
          return Math.min(options2.bars.maxWidth, chartWidth * spacingFactor / numberOfDomainValues);
        }
        return Math.min(options2.bars.maxWidth, mainXScale.step() / 2);
      };
      StackedBar2.prototype.destroy = function() {
        this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return StackedBar2;
    }(Bar);
    __extends$18 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Boxplot = function(_super) {
      __extends$18(Boxplot2, _super);
      function Boxplot2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "boxplot";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Boxplot2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var dataGroupNames = this.model.getDataGroupNames();
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var mainYScale = this.services.cartesianScales.getMainYScale();
        var _a22 = mainXScale.range(), xScaleStart = _a22[0], xScaleEnd = _a22[1];
        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        var width = xScaleEnd - xScaleStart;
        var height = yScaleEnd - yScaleStart;
        if (width === 0) {
          return;
        }
        var cartesianScales = this.services.cartesianScales;
        var orientation = cartesianScales.getOrientation();
        var isInVerticalOrientation = orientation === CartesianOrientations.VERTICAL;
        var _c = Tools.flipDomainAndRangeBasedOnOrientation(function(d, i2) {
          return _this.services.cartesianScales.getDomainValue(d, i2);
        }, function(d, i2) {
          return _this.services.cartesianScales.getRangeValue(d, i2);
        }, orientation), getXValue = _c[0], getYValue = _c[1];
        var gridSize = Math.floor((isInVerticalOrientation ? width : height) / dataGroupNames.length);
        var boxWidth = Math.min(gridSize / 2, 16);
        var boxplotData = this.model.getBoxplotData();
        var boxGroups = svg.selectAll(".box-group").data(boxplotData);
        boxGroups.exit().remove();
        var boxGroupsEnter = boxGroups.enter().append("g").attr("class", "box-group");
        var allBoxGroups = boxGroups.merge(boxGroupsEnter);
        boxGroupsEnter.append("path").merge(boxGroups.select("path.vertical-line.start")).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            originalClassName: "vertical-line start"
          });
        }).attr("stroke-width", boxplot.strokeWidth.default).attr("fill", "none").transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-verticalstartline",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]);
          var x1 = x0;
          var y0 = cartesianScales.getRangeValue(d.whiskers.min);
          var y1 = cartesianScales.getRangeValue(d.quartiles.q_25);
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.vertical-line.end")).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            originalClassName: "vertical-line end"
          });
        }).attr("stroke-width", boxplot.strokeWidth.default).attr("fill", "none").transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-verticalendline",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]);
          var x1 = x0;
          var y0 = cartesianScales.getRangeValue(d.whiskers.max);
          var y1 = cartesianScales.getRangeValue(d.quartiles.q_75);
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.box")).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [
              ColorClassNameTypes.FILL,
              ColorClassNameTypes.STROKE
            ],
            originalClassName: "box"
          });
        }).attr("fill-opacity", boxplot.box.opacity.default).attr("stroke-width", boxplot.strokeWidth.default).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "box").attr("aria-label", function(d) {
          return d[groupMapsTo];
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-quartiles",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
          var x1 = x0 + boxWidth;
          var y0 = cartesianScales.getRangeValue(Math[isInVerticalOrientation ? "max" : "min"](d.quartiles.q_75, d.quartiles.q_25));
          var y1 = y0 + Math.abs(cartesianScales.getRangeValue(d.quartiles.q_75) - cartesianScales.getRangeValue(d.quartiles.q_25));
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.highlight-area")).attr("class", "highlight-area").attr("opacity", 0).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
          var x1 = x0 + boxWidth;
          var y0 = cartesianScales.getRangeValue(d.whiskers.min);
          var y1 = cartesianScales.getRangeValue(d.whiskers.max);
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.whisker.start")).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            originalClassName: "whisker start"
          });
        }).attr("stroke-width", boxplot.strokeWidth.thicker).attr("fill", "none").transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-startingwhisker",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 4;
          var x1 = x0 + boxWidth / 2;
          var y0 = cartesianScales.getRangeValue(d.whiskers.min);
          var y1 = cartesianScales.getRangeValue(d.whiskers.min);
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.median")).attr("fill", "none").attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            originalClassName: "median"
          });
        }).attr("stroke-width", 2).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-median",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 2;
          var x1 = x0 + boxWidth;
          var y0 = cartesianScales.getRangeValue(d.quartiles.q_50);
          var y1 = y0;
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        boxGroupsEnter.append("path").merge(boxGroups.select("path.whisker.end")).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            originalClassName: "whisker end"
          });
        }).attr("stroke-width", boxplot.strokeWidth.thicker).attr("fill", "none").transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-endingwhisker",
            animate
          });
        }).attr("d", function(d) {
          var x0 = cartesianScales.getDomainValue(d[groupMapsTo]) - boxWidth / 4;
          var x1 = x0 + boxWidth / 2;
          var y0 = cartesianScales.getRangeValue(d.whiskers.max);
          var y1 = cartesianScales.getRangeValue(d.whiskers.max);
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, orientation);
        });
        var circles = allBoxGroups.selectAll("circle.outlier").data(function(d) {
          return d.outliers.map(function(outlier) {
            var _a32;
            return _a32 = {
              min: d.whiskers.min,
              max: d.whiskers.max
            }, _a32[groupMapsTo] = d[groupMapsTo], _a32.value = outlier, _a32;
          });
        });
        circles.exit().remove();
        var circlesEnter = circles.enter().append("circle");
        circles.merge(circlesEnter).attr("r", boxplot.circle.radius).attr("class", function() {
          return _this.model.getColorClassName({
            classNameTypes: [
              ColorClassNameTypes.FILL,
              ColorClassNameTypes.STROKE
            ],
            originalClassName: "outlier"
          });
        }).attr("fill-opacity", boxplot.circle.opacity.default).attr("cx", getXValue).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "boxplot-update-circles",
            animate
          });
        }).attr("cy", getYValue);
        this.addBoxEventListeners();
        this.addCircleEventListeners();
      };
      Boxplot2.prototype.addBoxEventListeners = function() {
        var self2 = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        this.parent.selectAll("path.highlight-area").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          var parentElement = select(this.parentNode);
          parentElement.select("path.box").classed("hovered", true).attr("fill-opacity", boxplot.box.opacity.hovered);
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: options2.tooltip.groupLabel,
                value: datum2[groupMapsTo],
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP]
                })
              },
              {
                label: "Minimum",
                value: datum2.whiskers.min
              },
              {
                label: "Q1",
                value: datum2.quartiles.q_25
              },
              {
                label: "Median",
                value: datum2.quartiles.q_50
              },
              {
                label: "Q3",
                value: datum2.quartiles.q_75
              },
              {
                label: "Maximum",
                value: datum2.whiskers.max
              },
              {
                label: "IQR",
                value: datum2.quartiles.q_75 - datum2.quartiles.q_25
              }
            ]
          });
          self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          var parentElement = select(this.parentNode);
          parentElement.select("path.box").classed("hovered", false).attr("fill-opacity", boxplot.box.opacity.default);
          self2.services.events.dispatchEvent(Events$1.Boxplot.BOX_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      Boxplot2.prototype.addCircleEventListeners = function() {
        var self2 = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        this.parent.selectAll("circle").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true).attr("fill-opacity", boxplot.circle.opacity.hovered).classed("unfilled", false);
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: options2.tooltip.groupLabel,
                value: datum2[groupMapsTo],
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP]
                })
              },
              {
                label: "Outlier",
                value: datum2[rangeIdentifier]
              }
            ]
          });
          self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false).attr("fill-opacity", boxplot.circle.opacity.default);
          self2.services.events.dispatchEvent(Events$1.Boxplot.OUTLIER_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      return Boxplot2;
    }(Component);
    __extends$17 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Scatter = function(_super) {
      __extends$17(Scatter2, _super);
      function Scatter2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "scatter";
        _this.renderType = RenderTypes.SVG;
        _this.handleChartHolderOnHover = function(event) {
          _this.parent.selectAll("circle.dot").transition("chart-holder-hover-scatter").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "chart-holder-hover-scatter"
            });
          }).attr("opacity", 1);
        };
        _this.handleChartHolderOnMouseOut = function(event) {
          _this.parent.selectAll("circle.dot").transition("chart-holder-mouseout-scatter").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "chart-holder-mouseout-scatter"
            });
          }).attr("opacity", 0);
        };
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("circle.dot").transition("legend-hover-scatter").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-scatter"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("circle.dot").transition("legend-mouseout-scatter").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-scatter"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      Scatter2.prototype.init = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
        var fadeInOnChartHolderMouseover = this.configs.fadeInOnChartHolderMouseover;
        if (fadeInOnChartHolderMouseover) {
          events.addEventListener(Events$1.Chart.MOUSEOVER, this.handleChartHolderOnHover);
          events.addEventListener(Events$1.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
        }
      };
      Scatter2.prototype.filterBasedOnZoomDomain = function(data) {
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier(data);
        var zoomDomain = this.model.get("zoomDomain");
        if (zoomDomain !== void 0) {
          return data.filter(function(d) {
            return d[domainIdentifier].getTime() >= zoomDomain[0].getTime() && d[domainIdentifier].getTime() <= zoomDomain[1].getTime();
          });
        }
        return data;
      };
      Scatter2.prototype.getScatterData = function() {
        var _this = this;
        var options2 = this.getOptions();
        var stacked = this.configs.stacked;
        var scatterData;
        if (stacked) {
          var percentage = Object.keys(options2.axes).some(function(axis2) {
            return options2.axes[axis2].percentage;
          });
          scatterData = this.model.getStackedData({
            groups: this.configs.groups,
            percentage
          });
        } else {
          scatterData = this.model.getDisplayData(this.configs.groups).filter(function(d) {
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
            return d[rangeIdentifier] !== void 0 && d[rangeIdentifier] !== null;
          });
        }
        return this.filterBasedOnZoomDomain(scatterData);
      };
      Scatter2.prototype.render = function(animate) {
        var isScatterEnabled = Tools.getProperty(this.getOptions(), "points", "enabled") || Tools.getProperty(this.getOptions(), "bubble", "enabled");
        if (!isScatterEnabled) {
          return;
        }
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
        var circles = svg.selectAll("circle.dot").data(this.getScatterData(), function(datum2) {
          return datum2[groupMapsTo] + "-" + datum2[domainIdentifier];
        });
        circles.exit().attr("opacity", 0).remove();
        var enteringCircles = circles.enter().append("circle").classed("dot", true).attr("opacity", 0);
        var circlesToStyle = enteringCircles.merge(circles);
        this.styleCircles(circlesToStyle, animate);
        this.addEventListeners();
      };
      Scatter2.prototype.isDatapointThresholdAnomaly = function(datum2, index2) {
        var _this = this;
        var handleThresholds = this.configs.handleThresholds;
        if (!handleThresholds) {
          return false;
        }
        var cartesianScales = this.services.cartesianScales;
        var orientation = cartesianScales.getOrientation();
        var _a22 = Tools.flipDomainAndRangeBasedOnOrientation(this.services.cartesianScales.getHighestDomainThreshold(), this.services.cartesianScales.getHighestRangeThreshold(), orientation), xThreshold = _a22[0], yThreshold = _a22[1];
        var _b = Tools.flipDomainAndRangeBasedOnOrientation(function(d, i2) {
          return _this.services.cartesianScales.getDomainValue(d, i2);
        }, function(d, i2) {
          return _this.services.cartesianScales.getRangeValue(d, i2);
        }, orientation), getXValue = _b[0], getYValue = _b[1];
        var xValue = getXValue(datum2, index2);
        var yValue = getYValue(datum2, index2);
        if (yThreshold && xThreshold) {
          return yValue <= yThreshold.scaleValue && xValue >= xThreshold.scaleValue;
        }
        if (yThreshold) {
          return yValue <= yThreshold.scaleValue;
        }
        if (xThreshold) {
          return xValue >= xThreshold.scaleValue;
        }
      };
      Scatter2.prototype.styleCircles = function(selection2, animate) {
        var _this = this;
        var options2 = this.getOptions();
        var _a22 = options2.points, filled = _a22.filled, fillOpacity = _a22.fillOpacity;
        var _b = this.services, cartesianScales = _b.cartesianScales;
        _b.transitions;
        var groupMapsTo = options2.data.groupMapsTo;
        var getDomainValue = function(d, i2) {
          return cartesianScales.getDomainValue(d, i2);
        };
        var getRangeValue = function(d, i2) {
          return cartesianScales.getRangeValue(d, i2);
        };
        var _c = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _c[0], getYValue = _c[1];
        var fadeInOnChartHolderMouseover = this.configs.fadeInOnChartHolderMouseover;
        selection2.raise().classed("dot", true).attr("class", function(d) {
          var domainIdentifier = cartesianScales.getDomainIdentifier(d);
          var isFilled = _this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
          var classNamesNeeded = isFilled ? [ColorClassNameTypes.FILL, ColorClassNameTypes.STROKE] : [ColorClassNameTypes.STROKE];
          return _this.model.getColorClassName({
            classNameTypes: classNamesNeeded,
            dataGroupName: d[groupMapsTo],
            originalClassName: "dot"
          });
        }).classed("threshold-anomaly", function(d, i2) {
          return _this.isDatapointThresholdAnomaly(d, i2);
        }).classed("filled", function(d) {
          var domainIdentifier = cartesianScales.getDomainIdentifier(d);
          return _this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
        }).classed("unfilled", function(d) {
          var domainIdentifier = cartesianScales.getDomainIdentifier(d);
          return !_this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled);
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "scatter-update-enter",
            animate
          });
        }).attr("cx", getXValue).attr("cy", getYValue).attr("r", options2.points.radius).style("fill", function(d) {
          var domainIdentifier = cartesianScales.getDomainIdentifier(d);
          if (_this.model.getIsFilled(d[groupMapsTo], d[domainIdentifier], d, filled)) {
            return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
          }
        }).style("stroke", function(d) {
          var domainIdentifier = cartesianScales.getDomainIdentifier(d);
          return _this.model.getStrokeColor(d[groupMapsTo], d[domainIdentifier], d);
        }).attr("fill-opacity", filled ? fillOpacity : 1).attr("opacity", fadeInOnChartHolderMouseover ? 0 : 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "point").attr("aria-label", function(d) {
          var rangeIdentifier = cartesianScales.getRangeIdentifier(d);
          return d[rangeIdentifier];
        });
        this.addEventListeners();
      };
      Scatter2.prototype.getTooltipAdditionalItems = function(datum2) {
        return null;
      };
      Scatter2.prototype.addEventListeners = function() {
        var self2 = this;
        var groupMapsTo = self2.getOptions().data.groupMapsTo;
        this.parent.selectAll("circle").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true).attr("class", function(d) {
            return self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.FILL],
              dataGroupName: d[groupMapsTo],
              originalClassName: hoveredElement.attr("class")
            });
          }).style("fill", function(d) {
            var domainIdentifier = self2.services.cartesianScales.getDomainIdentifier(d);
            return self2.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
          }).classed("unfilled", false);
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            data: [datum2],
            additionalItems: self2.getTooltipAdditionalItems(datum2)
          });
          self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          if (!self2.configs.filled) {
            var filled_1 = self2.getOptions().points.filled;
            var domainIdentifier_1 = self2.services.cartesianScales.getDomainIdentifier(datum2);
            var isFilled_1 = self2.model.getIsFilled(datum2[groupMapsTo], datum2[domainIdentifier_1], datum2, filled_1);
            hoveredElement.classed("unfilled", !isFilled_1).style("fill", function(d) {
              if (isFilled_1 || filled_1) {
                return self2.model.getFillColor(d[groupMapsTo], d[domainIdentifier_1], d);
              }
              return null;
            });
          }
          self2.services.events.dispatchEvent(Events$1.Scatter.SCATTER_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      Scatter2.prototype.destroy = function() {
        this.parent.selectAll("circle").on("mousemove", null).on("mouseout", null);
        var events = this.services.events;
        events.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
        events.removeEventListener(Events$1.Chart.MOUSEOVER, this.handleChartHolderOnHover);
        events.removeEventListener(Events$1.Chart.MOUSEOUT, this.handleChartHolderOnMouseOut);
      };
      return Scatter2;
    }(Component);
    __extends$16 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Bubble = function(_super) {
      __extends$16(Bubble2, _super);
      function Bubble2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "bubble";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Bubble2.prototype.getRadiusScale = function(selection2) {
        var options2 = this.getOptions();
        var radiusMapsTo = options2.bubble.radiusMapsTo;
        var data = selection2.data();
        var allRadii = data.map(function(d) {
          return d[radiusMapsTo];
        }).filter(function(radius) {
          return radius;
        });
        var chartSize = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
        var radiusDataIsValid = allRadii.length > 0;
        var domain = radiusDataIsValid ? extent(allRadii) : [1, 1];
        return linear().domain(domain).range(radiusDataIsValid ? options2.bubble.radiusRange(chartSize, data) : [4, 4]);
      };
      Bubble2.prototype.styleCircles = function(selection2, animate) {
        var _this = this;
        var options2 = this.getOptions();
        var radiusMapsTo = options2.bubble.radiusMapsTo;
        var radiusScale = this.getRadiusScale(selection2);
        var groupMapsTo = options2.data.groupMapsTo;
        var cartesianScales = this.services.cartesianScales;
        var getDomainValue = function(d, i2) {
          return cartesianScales.getDomainValue(d, i2);
        };
        var getRangeValue = function(d, i2) {
          return cartesianScales.getRangeValue(d, i2);
        };
        var _a22 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _a22[0], getYValue = _a22[1];
        selection2.raise().classed("dot", true).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
          var rangeIdentifier = cartesianScales.getRangeIdentifier(d);
          return d[rangeIdentifier];
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "bubble-update-enter",
            animate
          });
        }).attr("cx", getXValue).attr("cy", getYValue).attr("r", function(d) {
          return radiusScale(d[radiusMapsTo] || 1);
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [
              ColorClassNameTypes.FILL,
              ColorClassNameTypes.STROKE
            ],
            dataGroupName: d[groupMapsTo],
            originalClassName: "dot"
          });
        }).style("fill", function(d) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
          return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
        }).style("stroke", function(d) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
          return _this.model.getStrokeColor(d[groupMapsTo], d[domainIdentifier], d);
        }).attr("fill-opacity", options2.bubble.fillOpacity).attr("opacity", 1);
      };
      Bubble2.prototype.getTooltipAdditionalItems = function(datum2) {
        var bubbleOptions = Tools.getProperty(this.getOptions(), "bubble");
        return [
          {
            label: Tools.getProperty(bubbleOptions, "radiusLabel"),
            value: datum2[Tools.getProperty(bubbleOptions, "radiusMapsTo")]
          }
        ];
      };
      return Bubble2;
    }(Scatter);
    __extends$15 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Bullet = function(_super) {
      __extends$15(Bullet2, _super);
      function Bullet2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "bullet";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("path.bar").transition("legend-hover-simple-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-simple-bar"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.bar").transition("legend-mouseout-simple-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-simple-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      Bullet2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Bullet2.prototype.render = function(animate) {
        var _this = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var data = this.model.getDisplayData(this.configs.groups);
        var rangeScale = this.services.cartesianScales.getRangeScale();
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        var _a22 = rangeScale.range(), rangeScaleStart = _a22[0], rangeScaleEnd = _a22[1];
        var _b = rangeScale.domain();
        _b[0];
        var rangeScaleDomainMax = _b[1];
        var renderRangeBoxes = function() {
          var rangeBoxData = [];
          data.forEach(function(datum2) {
            if (datum2.ranges) {
              datum2.ranges.forEach(function(range2, i2) {
                if (range2 !== null && range2 !== void 0 && range2 < rangeScaleDomainMax) {
                  rangeBoxData.push({
                    datum: datum2,
                    value: range2,
                    order: i2 + 1
                  });
                }
              });
            } else {
              rangeBoxData.push({
                datum: datum2,
                order: 1
              });
            }
          });
          var rangeBoxes = DOMUtils.appendOrSelect(svg, "g.range-boxes").selectAll("path.range-box").data(rangeBoxData, function(datum2) {
            return datum2[groupMapsTo] + "-" + datum2.order;
          });
          rangeBoxes.exit().attr("opacity", 0).remove();
          var rangeBoxesEnter = rangeBoxes.enter().append("path").attr("opacity", 0);
          rangeBoxesEnter.merge(rangeBoxes).attr("class", function(d) {
            return "range-box order-" + d.order;
          }).transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "bullet-range-box-update-enter",
              animate
            });
          }).attr("d", function(d, i2) {
            var lineHeight = 16;
            var x0, x1, y0, y1;
            if (d.order === 1) {
              x0 = _this.services.cartesianScales.getDomainValue(d.datum, i2) - lineHeight / 2;
              x1 = x0 + lineHeight;
              y0 = rangeScaleEnd - 2;
              y1 = rangeScaleStart + 1;
            } else {
              x0 = _this.services.cartesianScales.getDomainValue(d.datum, i2) - lineHeight / 2;
              x1 = x0 + lineHeight;
              y0 = _this.services.cartesianScales.getRangeValue(d.value, i2);
              y1 = rangeScaleEnd;
            }
            return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
          }).attr("opacity", 1);
        };
        var renderBars = function() {
          var bars = DOMUtils.appendOrSelect(svg, "g.bars").selectAll("path.bar").data(data, function(datum2) {
            return datum2[groupMapsTo];
          });
          bars.exit().attr("opacity", 0).remove();
          var barsEnter = bars.enter().append("path").attr("opacity", 0);
          barsEnter.merge(bars).classed("bar", true).transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "bullet-bar-update-enter",
              animate
            });
          }).attr("class", function(d) {
            return _this.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.FILL],
              dataGroupName: d[groupMapsTo],
              originalClassName: "bar"
            });
          }).style("fill", function(d) {
            return _this.model.getFillColor(d[groupMapsTo]);
          }).attr("d", function(d, i2) {
            var barWidth = 8;
            var x0 = _this.services.cartesianScales.getDomainValue(d, i2) - barWidth / 2;
            var x1 = x0 + barWidth;
            var y0 = _this.services.cartesianScales.getRangeValue(0) + 1;
            var y1 = _this.services.cartesianScales.getRangeValue(d, i2);
            return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
          }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
            return d.value;
          });
        };
        var renderTargetLines = function() {
          var lines2 = DOMUtils.appendOrSelect(svg, "g.markers").selectAll("path.marker").data(data.filter(function(d) {
            return Tools.getProperty(d, "marker") !== null;
          }), function(datum2) {
            return datum2[groupMapsTo];
          });
          lines2.exit().attr("opacity", 0).remove();
          var linesEnter = lines2.enter().append("path").attr("opacity", 0);
          linesEnter.merge(lines2).classed("marker", true).transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "bullet-marker-update-enter",
              animate
            });
          }).attr("d", function(d, i2) {
            var lineHeight = 24;
            var x0 = _this.services.cartesianScales.getDomainValue(d, i2) - lineHeight / 2;
            var x1 = x0 + lineHeight;
            var y0 = _this.services.cartesianScales.getRangeValue(d.marker, i2);
            var y1 = y0;
            return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
          }).attr("opacity", 1);
        };
        var renderTargetQuartiles = function() {
          var quartilesData = [];
          data.filter(function(d) {
            return Tools.getProperty(d, "marker") !== null;
          }).forEach(function(d) {
            var value2 = d.marker;
            var barValue = d[rangeIdentifier];
            quartilesData = quartilesData.concat([
              { datum: d, value: value2 * 0.25, barValue },
              { datum: d, value: value2 * 0.5, barValue },
              { datum: d, value: value2 * 0.75, barValue }
            ]);
          });
          var lines2 = DOMUtils.appendOrSelect(svg, "g.quartiles").selectAll("path.quartile").data(quartilesData, function(datum2) {
            return datum2[groupMapsTo];
          });
          lines2.exit().attr("opacity", 0).remove();
          var linesEnter = lines2.enter().append("path").attr("opacity", 0);
          linesEnter.merge(lines2).attr("class", function(d) {
            return "quartile " + (d.value <= d.barValue ? "over-bar" : "");
          }).transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "bullet-quartile-update-enter",
              animate
            });
          }).attr("d", function(_a32, i2) {
            var d = _a32.datum, value2 = _a32.value;
            var lineHeight = 4;
            if (d.ranges && d.ranges.indexOf(value2) !== -1) {
              lineHeight = 8;
            }
            var x0 = _this.services.cartesianScales.getDomainValue(d, i2) - lineHeight / 2;
            var x1 = x0 + lineHeight;
            var y0 = _this.services.cartesianScales.getRangeValue(value2, i2);
            var y1 = y0;
            return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
          }).attr("opacity", 1);
        };
        renderRangeBoxes();
        renderBars();
        renderTargetLines();
        renderTargetQuartiles();
        this.addEventListeners();
      };
      Bullet2.prototype.addEventListeners = function() {
        var self2 = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          var performanceAreaTitles = Tools.getProperty(options2, "bullet", "performanceAreaTitles");
          var matchingRangeIndex = self2.model.getMatchingRangeIndexForDatapoint(datum2);
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: options2.tooltip.groupLabel || "Group",
                value: datum2[groupMapsTo],
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP],
                  dataGroupName: datum2[groupMapsTo]
                })
              },
              {
                label: "Value",
                value: datum2[rangeIdentifier]
              },
              {
                label: "Target",
                value: datum2.marker
              },
              {
                label: "Percentage",
                value: Math.floor(datum2[rangeIdentifier] / datum2.marker * 100) + "%"
              },
              {
                label: "Performance",
                value: performanceAreaTitles[matchingRangeIndex]
              }
            ]
          });
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Bar.BAR_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      Bullet2.prototype.destroy = function() {
        this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return Bullet2;
    }(Component);
    __extends$14 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Histogram = function(_super) {
      __extends$14(Histogram2, _super);
      function Histogram2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "histogram";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var options2 = _this.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          _this.parent.selectAll("path.bar").transition("legend-hover-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-bar"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.bar").transition("legend-mouseout-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      Histogram2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Histogram2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer();
        var options2 = this.model.getOptions();
        var groupIdentifier = options2.groupIdentifier;
        var groupMapsTo = options2.data.groupMapsTo;
        var binnedStackedData = this.model.getBinnedStackedData();
        var x22 = this.services.cartesianScales.getMainXScale();
        var barGroups = svg.selectAll("g.bars").data(binnedStackedData, function(d) {
          return get$3(d, "0." + groupMapsTo);
        });
        barGroups.exit().attr("opacity", 0).remove();
        barGroups.enter().append("g").classed("bars", true).attr("role", Roles.GROUP);
        var bars = svg.selectAll("g.bars").selectAll("path.bar").data(function(data) {
          return data;
        });
        bars.exit().remove();
        bars.enter().append("path").merge(bars).classed("bar", true).attr(groupIdentifier, function(d, i2) {
          return i2;
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "histogram-bar-update-enter",
            animate
          });
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: "bar"
          });
        }).style("fill", function(d) {
          return _this.model.getFillColor(d[groupMapsTo]);
        }).attr("d", function(d, i2) {
          var bin2 = get$3(d, "data");
          if (!bin2) {
            return;
          }
          var barWidth = x22(bin2.x1) - x22(bin2.x0) - 1;
          var x0 = _this.services.cartesianScales.getDomainValue(bin2.x0, i2);
          var x1 = x0 + barWidth;
          var y0 = _this.services.cartesianScales.getRangeValue(d[0], i2);
          var y1 = _this.services.cartesianScales.getRangeValue(d[1], i2);
          if (Math.abs(y1 - y0) > 0 && Math.abs(y1 - y0) > options2.bars.dividerSize) {
            if (_this.services.cartesianScales.getOrientation() === CartesianOrientations.VERTICAL) {
              y1 += 1;
            } else {
              y1 -= 1;
            }
          }
          return Tools.generateSVGPathString({ x0, x1, y0, y1 }, _this.services.cartesianScales.getOrientation());
        }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "bar").attr("aria-label", function(d) {
          return Tools.getProperty(d, "data", d[groupMapsTo]);
        });
        this.addEventListeners();
      };
      Histogram2.prototype.addEventListeners = function() {
        var options2 = this.model.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var self2 = this;
        this.parent.selectAll("path.bar").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          var x0 = parseFloat(get$3(datum2, "data.x0"));
          var x1 = parseFloat(get$3(datum2, "data.x1"));
          var rangeAxisPosition = self2.services.cartesianScales.getRangeAxisPosition();
          var rangeScaleLabel = self2.services.cartesianScales.getScaleLabel(rangeAxisPosition);
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: get$3(options2, "bins.rangeLabel") || "Range",
                value: x0 + " \u2013 " + x1
              },
              {
                label: options2.tooltip.groupLabel || "Group",
                value: datum2[groupMapsTo],
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP],
                  dataGroupName: datum2[groupMapsTo]
                })
              },
              {
                label: rangeScaleLabel,
                value: get$3(datum2, "data." + datum2[groupMapsTo])
              }
            ]
          });
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
        });
      };
      Histogram2.prototype.destroy = function() {
        this.parent.selectAll("path.bar").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return Histogram2;
    }(Component);
    __extends$13 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Line = function(_super) {
      __extends$13(Line2, _super);
      function Line2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "line";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          _this.parent.selectAll("path.line").transition("legend-hover-line").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-line"
            });
          }).attr("opacity", function(group) {
            if (group.name !== hoveredElement.datum()["name"]) {
              return lines.opacity.unselected;
            }
            return lines.opacity.selected;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.line").transition("legend-mouseout-line").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-line"
            });
          }).attr("opacity", lines.opacity.selected);
        };
        return _this;
      }
      Line2.prototype.init = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Line2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var svg = this.getComponentContainer({ withinChartClip: true });
        var _a22 = this.services, cartesianScales = _a22.cartesianScales, curves = _a22.curves;
        var getDomainValue = function(d, i2) {
          return cartesianScales.getDomainValue(d, i2);
        };
        var getRangeValue = function(d, i2) {
          return cartesianScales.getRangeValue(d, i2);
        };
        var _b = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, cartesianScales.getOrientation()), getXValue = _b[0], getYValue = _b[1];
        var options2 = this.getOptions();
        var lineGenerator = line().x(getXValue).y(getYValue).curve(curves.getD3Curve()).defined(function(datum2, i2) {
          var rangeIdentifier = cartesianScales.getRangeIdentifier(datum2);
          var value2 = datum2[rangeIdentifier];
          if (value2 === null || value2 === void 0) {
            return false;
          }
          return true;
        });
        var data = [];
        if (this.configs.stacked) {
          var percentage = Object.keys(options2.axes).some(function(axis2) {
            return options2.axes[axis2].percentage;
          });
          var groupMapsTo_1 = options2.data.groupMapsTo;
          var stackedData = this.model.getStackedData({
            groups: this.configs.groups,
            percentage
          });
          data = stackedData.map(function(d) {
            var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
            return {
              name: Tools.getProperty(d, 0, groupMapsTo_1),
              data: d.map(function(datum2) {
                var _a32;
                return _a32 = {}, _a32[domainIdentifier] = datum2.data.sharedStackKey, _a32[groupMapsTo_1] = datum2[groupMapsTo_1], _a32[rangeIdentifier] = datum2[1], _a32;
              }),
              hidden: !Tools.some(d, function(datum2) {
                return datum2[0] !== datum2[1];
              })
            };
          });
        } else {
          data = this.model.getGroupedData(this.configs.groups);
        }
        var lines2 = svg.selectAll("path.line").data(data, function(group) {
          return group.name;
        });
        lines2.exit().attr("opacity", 0).remove();
        var enteringLines = lines2.enter().append("path").classed("line", true).attr("opacity", 0);
        enteringLines.merge(lines2).data(data, function(group) {
          return group.name;
        }).attr("class", function(group) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            dataGroupName: group.name,
            originalClassName: "line"
          });
        }).style("stroke", function(group) {
          return _this.model.getStrokeColor(group.name);
        }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "line").attr("aria-label", function(group) {
          var groupData = group.data;
          return groupData.map(function(datum2) {
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datum2);
            return datum2[rangeIdentifier];
          }).join(",");
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "line-update-enter",
            animate
          });
        }).attr("opacity", function(d) {
          return d.hidden ? 0 : 1;
        }).attr("d", function(group) {
          var groupData = group.data;
          return lineGenerator(groupData);
        });
      };
      Line2.prototype.destroy = function() {
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      return Line2;
    }(Component);
    __extends$12 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Lollipop = function(_super) {
      __extends$12(Lollipop2, _super);
      function Lollipop2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "lollipop";
        _this.renderType = RenderTypes.SVG;
        _this.handleScatterOnHover = function(event) {
          var hoveredElement = event.detail;
          var options2 = _this.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          _this.parent.selectAll("line.line").attr("stroke-width", function(d) {
            if (d[groupMapsTo] !== hoveredElement.datum[groupMapsTo]) {
              return lines.weight.unselected;
            }
            return lines.weight.selected;
          });
        };
        _this.handleScatterOnMouseOut = function(event) {
          _this.parent.selectAll("line.line").attr("stroke-width", lines.weight.unselected);
        };
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var options2 = _this.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          _this.parent.selectAll("line.line").transition("legend-hover-line").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-line"
            });
          }).attr("opacity", function(d) {
            if (d[groupMapsTo] !== hoveredElement.datum()["name"]) {
              return lines.opacity.unselected;
            }
            return lines.opacity.selected;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("line.line").transition("legend-mouseout-line").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-line"
            });
          }).attr("opacity", lines.opacity.selected);
        };
        return _this;
      }
      Lollipop2.prototype.init = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Lollipop2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.model.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var cartesianScales = this.services.cartesianScales;
        var mainXScale = cartesianScales.getMainXScale();
        var mainYScale = cartesianScales.getMainYScale();
        var domainIdentifier = cartesianScales.getDomainIdentifier();
        var getDomainValue = function(d, i2) {
          return cartesianScales.getDomainValue(d, i2);
        };
        var getRangeValue = function(d, i2) {
          return cartesianScales.getRangeValue(d, i2);
        };
        var orientation = cartesianScales.getOrientation();
        var _a22 = Tools.flipDomainAndRangeBasedOnOrientation(getDomainValue, getRangeValue, orientation), getXValue = _a22[0], getYValue = _a22[1];
        var lines2 = svg.selectAll("line.line").data(this.getScatterData(), function(datum2) {
          return datum2[groupMapsTo] + "-" + datum2[domainIdentifier];
        });
        lines2.exit().attr("opacity", 0).remove();
        var enteringLines = lines2.enter().append("line").attr("opacity", 0);
        var allLines = enteringLines.merge(lines2).classed("line", true).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            dataGroupName: d[groupMapsTo],
            originalClassName: "line"
          });
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "lollipop-line-update-enter",
            animate
          });
        }).style("stroke", function(d) {
          return _this.model.getFillColor(d[groupMapsTo], d[domainIdentifier], d);
        }).attr("opacity", 1);
        if (orientation === CartesianOrientations.HORIZONTAL) {
          allLines.attr("y1", getYValue).attr("y2", getYValue).attr("x1", mainXScale.range()[0]).attr("x2", function(d, i2) {
            return getXValue(d, i2) - options2.points.radius;
          });
        } else {
          allLines.attr("x1", getXValue).attr("x2", getXValue).attr("y1", mainYScale.range()[0]).attr("y2", function(d, i2) {
            return getYValue(d, i2) + options2.points.radius;
          });
        }
        this.addScatterPointEventListeners();
      };
      Lollipop2.prototype.addScatterPointEventListeners = function() {
        this.services.events.addEventListener(Events$1.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover);
        this.services.events.addEventListener(Events$1.Scatter.SCATTER_MOUSEOUT, this.handleScatterOnMouseOut);
      };
      Lollipop2.prototype.destroy = function() {
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
        eventsFragment.removeEventListener(Events$1.Scatter.SCATTER_MOUSEOVER, this.handleScatterOnHover);
        eventsFragment.removeEventListener(Events$1.Scatter.SCATTER_MOUSEOUT, this.handleScatterOnMouseOut);
      };
      return Lollipop2;
    }(Scatter);
    __extends$11 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    StackedScatter = function(_super) {
      __extends$11(StackedScatter2, _super);
      function StackedScatter2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "scatter-stacked";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      StackedScatter2.prototype.render = function(animate) {
        var _this = this;
        var isScatterEnabled = Tools.getProperty(this.getOptions(), "points", "enabled");
        if (!isScatterEnabled) {
          return;
        }
        var svg = this.getComponentContainer({ withinChartClip: true });
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var percentage = Object.keys(options2.axes).some(function(axis2) {
          return options2.axes[axis2].percentage;
        });
        var stackedData = this.model.getStackedData({
          groups: this.configs.groups,
          percentage
        });
        var circleGroups = svg.selectAll("g.dots").data(stackedData, function(d) {
          return Tools.getProperty(d, 0, groupMapsTo);
        });
        circleGroups.exit().attr("opacity", 0).remove();
        var circleGroupsEnter = circleGroups.enter().append("g").classed("dots", true).attr("role", Roles.GROUP);
        var circles = circleGroupsEnter.merge(circleGroups).selectAll("circle.dot").data(function(d) {
          return d;
        });
        circles.exit().attr("opacity", 0).remove();
        var enteringCircles = circles.enter().append("circle").classed("dot", true).attr("opacity", 0);
        var circlesToStyle = enteringCircles.merge(circles).datum(function(d) {
          var _a22;
          var group = d[groupMapsTo];
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(d);
          var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
          return _a22 = {}, _a22[groupMapsTo] = group, _a22[domainIdentifier] = d["data"]["sharedStackKey"], _a22[rangeIdentifier] = d[1], _a22;
        });
        this.styleCircles(circlesToStyle, animate);
        this.addEventListeners();
      };
      StackedScatter2.prototype.getTooltipData = function(hoveredX, hoveredY) {
        var _this = this;
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var percentage = Object.keys(options2.axes).some(function(axis2) {
          return options2.axes[axis2].percentage;
        });
        var stackedData = this.model.getStackedData({
          groups: this.configs.groups,
          percentage
        });
        var tooltipData = [];
        stackedData.forEach(function(groupData, groupDataIndex) {
          groupData.forEach(function(datum2, dataIndex) {
            var _a22;
            var group = datum2[groupMapsTo];
            var domainValue = datum2["data"]["sharedStackKey"];
            var rangeValue = datum2["data"][group];
            var stackedRangeValue = datum2[1];
            var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datum2);
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datum2);
            if (rangeValue !== null && rangeValue !== void 0 && hoveredX === _this.services.cartesianScales.getDomainValue(domainValue) && hoveredY === _this.services.cartesianScales.getRangeValue(stackedRangeValue)) {
              if (percentage) {
                rangeValue = _this.model.getStackedData({
                  groups: _this.configs.groups
                })[groupDataIndex][dataIndex]["data"][group];
              }
              if (rangeValue !== null) {
                tooltipData.push((_a22 = {}, _a22[groupMapsTo] = group, _a22[domainIdentifier] = domainValue, _a22[rangeIdentifier] = rangeValue, _a22));
              }
            }
          });
        });
        return this.model.getDisplayData(this.configs.groups).filter(function(datapoint) {
          var domainIdentifier = _this.services.cartesianScales.getDomainIdentifier(datapoint);
          var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(datapoint);
          return tooltipData.find(function(tooltipDatapoint) {
            return tooltipDatapoint[groupMapsTo] == datapoint[groupMapsTo] && tooltipDatapoint[domainIdentifier] == datapoint[domainIdentifier] && tooltipDatapoint[rangeIdentifier] == datapoint[rangeIdentifier];
          }) !== void 0;
        });
      };
      return StackedScatter2;
    }(Scatter);
    __extends$10 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Pie = function(_super) {
      __extends$10(Pie2, _super);
      function Pie2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "pie";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("path.slice").transition("legend-hover-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-bar"
            });
          }).attr("opacity", function(d) {
            return d.data[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("path.slice").transition("legend-mouseout-bar").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-bar"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      Pie2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Pie2.prototype.getInnerRadius = function() {
        return pie$1.innerRadius;
      };
      Pie2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var self2 = this;
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var valueMapsTo = options2.pie.valueMapsTo;
        var displayData = this.model.getDisplayData().filter(function(data) {
          return data[valueMapsTo] > 0;
        });
        var radius = this.computeRadius();
        this.arc = arc().innerRadius(this.getInnerRadius()).outerRadius(radius);
        this.hoverArc = arc().innerRadius(this.getInnerRadius()).outerRadius(radius + pie$1.hoverArc.outerRadiusOffset);
        var pieLayout = pie().value(function(d) {
          return d[valueMapsTo];
        }).sort(Tools.getProperty(options2, "pie", "sortFunction")).padAngle(pie$1.padAngle);
        var pieLayoutData = pieLayout(displayData);
        var slicesGroup = DOMUtils.appendOrSelect(svg, "g.slices").attr("role", Roles.GROUP).attr("data-name", "slices");
        var paths = slicesGroup.selectAll("path.slice").data(pieLayoutData, function(d) {
          return d.data[groupMapsTo];
        });
        paths.exit().attr("opacity", 0).remove();
        var enteringPaths = paths.enter().append("path").classed("slice", true).attr("opacity", 0);
        var allPaths = enteringPaths.merge(paths).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d.data[groupMapsTo],
            originalClassName: "slice"
          });
        }).style("fill", function(d) {
          return self2.model.getFillColor(d.data[groupMapsTo]);
        }).attr("d", this.arc);
        allPaths.transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "pie_slice_enter_update",
            animate
          });
        }).attr("opacity", 1).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "slice").attr("aria-label", function(d) {
          return d[valueMapsTo] + ", " + (Tools.convertValueToPercentage(d.data[valueMapsTo], displayData, valueMapsTo) + "%");
        }).attrTween("d", function(a) {
          return arcTween.bind(this)(a, self2.arc);
        });
        var renderLabels = options2.pie.labels.enabled;
        var labelData = renderLabels ? pieLayoutData.filter(function(x22) {
          return x22.data[valueMapsTo] > 0;
        }) : [];
        var labelsGroup = DOMUtils.appendOrSelect(svg, "g.labels").attr("role", Roles.GROUP).attr("data-name", "labels");
        var labels = labelsGroup.selectAll("text.pie-label").data(labelData, function(d) {
          return d.data[groupMapsTo];
        });
        labels.exit().attr("opacity", 0).remove();
        var enteringLabels = labels.enter().append("text").classed("pie-label", true);
        var calloutData = [];
        enteringLabels.merge(labels).style("text-anchor", "middle").text(function(d) {
          if (options2.pie.labels.formatter) {
            return options2.pie.labels.formatter(d);
          }
          return Tools.convertValueToPercentage(d.data[valueMapsTo], displayData, valueMapsTo) + "%";
        }).datum(function(d) {
          var marginedRadius = radius + 7;
          var theta = (d.endAngle - d.startAngle) / 2 + d.startAngle;
          var deg = theta / Math.PI * 180;
          var textLength = this.getComputedTextLength();
          d.textOffsetX = textLength / 2;
          d.textOffsetY = deg > 90 && deg < 270 ? 10 : 0;
          d.xPosition = (d.textOffsetX + marginedRadius) * Math.sin(theta);
          d.yPosition = (d.textOffsetY + marginedRadius) * -Math.cos(theta);
          return d;
        }).attr("transform", function(d, i2) {
          var totalSlices = labelData.length;
          var sliceAngleDeg = (d.endAngle - d.startAngle) * (180 / Math.PI);
          if (i2 >= totalSlices - 2) {
            if (sliceAngleDeg < pie$1.callout.minSliceDegree) {
              var labelTranslateX = void 0, labelTranslateY = void 0;
              if (d.index === totalSlices - 1) {
                labelTranslateX = d.xPosition + pie$1.callout.offsetX + pie$1.callout.textMargin + d.textOffsetX;
                labelTranslateY = d.yPosition - pie$1.callout.offsetY;
                d.direction = CalloutDirections.RIGHT;
                calloutData.push(d);
              } else {
                labelTranslateX = d.xPosition - pie$1.callout.offsetX - d.textOffsetX - pie$1.callout.textMargin;
                labelTranslateY = d.yPosition - pie$1.callout.offsetY;
                d.direction = CalloutDirections.LEFT;
                calloutData.push(d);
              }
              return "translate(" + labelTranslateX + ", " + labelTranslateY + ")";
            }
          }
          return "translate(" + d.xPosition + ", " + d.yPosition + ")";
        });
        this.renderCallouts(calloutData);
        var optionName = Tools.getProperty(options2, "donut") ? "donut" : "pie";
        var alignment = Tools.getProperty(options2, optionName, "alignment");
        var width = DOMUtils.getSVGElementSize(this.getParent(), {
          useAttrs: true
        }).width;
        var xOffset = renderLabels ? pie$1.xOffset : 0;
        var yOffset = renderLabels ? pie$1.yOffset : 0;
        var pieTranslateX = radius + xOffset;
        if (alignment === Alignments.CENTER) {
          pieTranslateX = width / 2;
        } else if (alignment === Alignments.RIGHT) {
          pieTranslateX = width - radius - pie$1.xOffset;
        }
        var pieTranslateY = radius + yOffset;
        if (calloutData.length > 0) {
          pieTranslateY += pie$1.yOffsetCallout;
        }
        svg.attr("x", pieTranslateX + 7).attr("y", pieTranslateY);
        this.addEventListeners();
      };
      Pie2.prototype.renderCallouts = function(calloutData) {
        var svg = DOMUtils.appendOrSelect(this.getComponentContainer(), "g.callouts").attr("role", Roles.GROUP).attr("data-name", "callouts");
        var callouts = svg.selectAll("g.callout").data(calloutData);
        callouts.exit().remove();
        var enteringCallouts = callouts.enter().append("g").classed("callout", true).attr("role", Roles.GROUP).attr("aria-roledescription", "label callout");
        enteringCallouts.merge(callouts).datum(function(d) {
          var xPosition = d.xPosition, yPosition = d.yPosition, direction = d.direction;
          if (direction === CalloutDirections.RIGHT) {
            d.startPos = {
              x: xPosition,
              y: yPosition + d.textOffsetY
            };
            d.endPos = {
              x: xPosition + pie$1.callout.offsetX,
              y: yPosition - pie$1.callout.offsetY + d.textOffsetY
            };
            d.intersectPointX = d.endPos.x - pie$1.callout.horizontalLineLength;
          } else {
            d.startPos = {
              x: xPosition,
              y: yPosition + d.textOffsetY
            };
            d.endPos = {
              x: xPosition - pie$1.callout.offsetX,
              y: yPosition - pie$1.callout.offsetY + d.textOffsetY
            };
            d.intersectPointX = d.endPos.x + pie$1.callout.horizontalLineLength;
          }
          return d;
        });
        var enteringVerticalLines = enteringCallouts.append("line").classed("vertical-line", true);
        enteringVerticalLines.merge(svg.selectAll("line.vertical-line")).datum(function(d) {
          return select(this.parentNode).datum();
        }).style("stroke-width", "1px").attr("x1", function(d) {
          return d.startPos.x;
        }).attr("y1", function(d) {
          return d.startPos.y;
        }).attr("x2", function(d) {
          return d.intersectPointX;
        }).attr("y2", function(d) {
          return d.endPos.y;
        });
        var enteringHorizontalLines = enteringCallouts.append("line").classed("horizontal-line", true);
        enteringHorizontalLines.merge(svg.selectAll("line.horizontal-line")).datum(function(d) {
          return select(this.parentNode).datum();
        }).style("stroke-width", "1px").attr("x1", function(d) {
          return d.intersectPointX;
        }).attr("y1", function(d) {
          return d.endPos.y;
        }).attr("x2", function(d) {
          return d.endPos.x;
        }).attr("y2", function(d) {
          return d.endPos.y;
        });
      };
      Pie2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("path.slice").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true).transition("pie_slice_mouseover").call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "pie_slice_mouseover"
            });
          }).attr("d", self2.hoverArc);
          self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEOVER, {
            event,
            element: select(this),
            datum: datum2
          });
          var groupMapsTo = self2.getOptions().data.groupMapsTo;
          var valueMapsTo = self2.getOptions().pie.valueMapsTo;
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: datum2.data[groupMapsTo],
                value: datum2.data[valueMapsTo]
              }
            ]
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Pie.SLICE_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false).transition("pie_slice_mouseout").call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "pie_slice_mouseout"
            });
          }).attr("d", self2.arc);
          self2.services.events.dispatchEvent(Events$1.Pie.SLICE_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      Pie2.prototype.computeRadius = function() {
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var options2 = this.getOptions();
        var radius = Math.min(width, height) / 2;
        var renderLabels = options2.pie.labels.enabled;
        return renderLabels ? radius + pie$1.radiusOffset : radius;
      };
      return Pie2;
    }(Component);
    __extends$$ = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ARROW_UP_PATH_STRING = "4,10 8,6 12,10";
    ARROW_DOWN_PATH_STRING = "12,6 8,10 4,6";
    Gauge = function(_super) {
      __extends$$(Gauge2, _super);
      function Gauge2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "gauge";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Gauge2.prototype.getValue = function() {
        var _a22, _b;
        var data = this.model.getData();
        var value2 = (_b = (_a22 = data.find(function(d) {
          return d.group === "value";
        })) === null || _a22 === void 0 ? void 0 : _a22.value, _b !== null && _b !== void 0 ? _b : null);
        return value2;
      };
      Gauge2.prototype.getValueRatio = function() {
        var value2 = Tools.clamp(this.getValue(), 0, 100);
        return value2 / 100;
      };
      Gauge2.prototype.getDelta = function() {
        var _a22, _b;
        var data = this.model.getData();
        var delta = (_b = (_a22 = data.find(function(d) {
          return d.group === "delta";
        })) === null || _a22 === void 0 ? void 0 : _a22.value, _b !== null && _b !== void 0 ? _b : null);
        return delta;
      };
      Gauge2.prototype.getArcRatio = function() {
        var options2 = this.getOptions();
        var type2 = Tools.getProperty(options2, "gauge", "type");
        var arcRatio = type2 === GaugeTypes.FULL ? 1 : 0.5;
        return arcRatio;
      };
      Gauge2.prototype.getArcSize = function() {
        return this.getArcRatio() * Math.PI * 2;
      };
      Gauge2.prototype.getStartAngle = function() {
        var arcSize = this.getArcSize();
        if (arcSize === 2 * Math.PI) {
          return 0;
        }
        return -arcSize / 2;
      };
      Gauge2.prototype.getArrow = function(delta) {
        var options2 = this.getOptions();
        var arrowDirection = Tools.getProperty(options2, "gauge", "deltaArrow", "direction");
        switch (arrowDirection) {
          case ArrowDirections.UP:
            return ARROW_UP_PATH_STRING;
          case ArrowDirections.DOWN:
            return ARROW_DOWN_PATH_STRING;
          default:
            return delta > 0 ? ARROW_UP_PATH_STRING : ARROW_DOWN_PATH_STRING;
        }
      };
      Gauge2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer().attr("width", "100%").attr("height", "100%");
        var options2 = this.getOptions();
        var value2 = this.getValue();
        var valueRatio = this.getValueRatio();
        var arcSize = this.getArcSize();
        var startAngle = this.getStartAngle();
        var rotationAngle = valueRatio * arcSize;
        var currentAngle = startAngle + rotationAngle;
        var endAngle = startAngle + arcSize;
        var radius = this.computeRadius();
        var innerRadius = this.getInnerRadius();
        this.backgroundArc = arc().innerRadius(innerRadius).outerRadius(radius).startAngle(currentAngle).endAngle(endAngle);
        this.arc = arc().innerRadius(innerRadius).outerRadius(radius).startAngle(startAngle).endAngle(currentAngle);
        DOMUtils.appendOrSelect(svg, "path.arc-background").attr("d", this.backgroundArc);
        var arcValue = svg.selectAll("path.arc-foreground").data([value2]);
        var arcEnter = arcValue.enter().append("path");
        arcEnter.merge(arcValue).attr("class", this.model.getColorClassName({
          classNameTypes: [ColorClassNameTypes.FILL],
          dataGroupName: "value",
          originalClassName: "arc-foreground"
        })).style("fill", function(d) {
          return Tools.getProperty(_this.getOptions(), "color", "scale", "value");
        }).attr("d", this.arc).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", function(d) {
          return d;
        });
        this.drawValueNumber();
        this.drawDelta();
        arcValue.exit().remove();
        var alignment = Tools.getProperty(options2, "gauge", "alignment");
        var width = DOMUtils.getSVGElementSize(this.getParent(), {
          useAttrs: true
        }).width;
        var gaugeTranslateX = radius;
        if (alignment === Alignments.CENTER) {
          gaugeTranslateX = width / 2;
        } else if (alignment === Alignments.RIGHT) {
          gaugeTranslateX = width - radius;
        }
        svg.attr("x", gaugeTranslateX).attr("y", radius);
        this.addEventListeners();
      };
      Gauge2.prototype.drawValueNumber = function() {
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var arcType = Tools.getProperty(options2, "gauge", "type");
        var value2 = this.getValue();
        var delta = this.getDelta();
        var radius = this.computeRadius();
        var valueFontSize = Tools.getProperty(options2, "gauge", "valueFontSize");
        var deltaFontSize = Tools.getProperty(options2, "gauge", "deltaFontSize");
        var numberSpacing = Tools.getProperty(options2, "gauge", "numberSpacing");
        var showPercentageSymbol = Tools.getProperty(options2, "gauge", "showPercentageSymbol");
        var numbersYPosition = 0;
        if (arcType === GaugeTypes.FULL && !delta) {
          numbersYPosition = deltaFontSize(radius);
        } else if (arcType === GaugeTypes.SEMI && delta) {
          numbersYPosition = -(deltaFontSize(radius) + numberSpacing);
        }
        var numbersGroup = DOMUtils.appendOrSelect(svg, "g.gauge-numbers").attr("transform", "translate(0, " + numbersYPosition + ")");
        var fontSize = valueFontSize(radius);
        var valueNumberGroup = DOMUtils.appendOrSelect(numbersGroup, "g.gauge-value-number");
        var numberFormatter = Tools.getProperty(options2, "gauge", "numberFormatter");
        var valueNumber = valueNumberGroup.selectAll("text.gauge-value-number").data([value2]);
        valueNumber.enter().append("text").attr("class", "gauge-value-number").merge(valueNumber).style("font-size", fontSize + "px").attr("text-anchor", "middle").text(function(d) {
          return numberFormatter(d);
        });
        var valueNumberWidth = DOMUtils.getSVGElementSize(DOMUtils.appendOrSelect(svg, "text.gauge-value-number"), { useBBox: true }).width;
        var symbolFontSize = fontSize / 2;
        var gaugeSymbol = showPercentageSymbol ? "%" : "";
        var symbol = DOMUtils.appendOrSelect(valueNumberGroup, "text.gauge-value-symbol").style("font-size", symbolFontSize + "px").attr("x", valueNumberWidth / 2).text(gaugeSymbol);
        var _a22 = DOMUtils.getSVGElementSize(symbol, { useBBox: true }), symbolWidth = _a22.width, symbolHeight = _a22.height;
        symbol.attr("y", "-" + symbolHeight / 2 + "px");
        valueNumberGroup.attr("transform", "translate(-" + symbolWidth / 2 + ", 0)");
      };
      Gauge2.prototype.drawDelta = function() {
        var self2 = this;
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var delta = this.getDelta();
        var radius = this.computeRadius();
        var deltaFontSize = delta ? Tools.getProperty(options2, "gauge", "deltaFontSize") : function() {
          return 0;
        };
        var numberFormatter = delta ? Tools.getProperty(options2, "gauge", "numberFormatter") : function() {
          return null;
        };
        var arrowSize = Tools.getProperty(options2, "gauge", "deltaArrow", "size");
        var numberSpacing = Tools.getProperty(options2, "gauge", "numberSpacing");
        var showPercentageSymbol = Tools.getProperty(options2, "gauge", "showPercentageSymbol");
        var numbersGroup = DOMUtils.appendOrSelect(svg, "g.gauge-numbers");
        var deltaGroup = DOMUtils.appendOrSelect(numbersGroup, "g.gauge-delta").attr("transform", "translate(0, " + (deltaFontSize(radius) + numberSpacing) + ")");
        var deltaNumber = DOMUtils.appendOrSelect(deltaGroup, "text.gauge-delta-number");
        var gaugeSymbol = showPercentageSymbol ? "%" : "";
        deltaNumber.data(delta === null ? [] : [delta]);
        deltaNumber.enter().append("text").classed("gauge-delta-number", true).merge(deltaNumber).attr("text-anchor", "middle").style("font-size", deltaFontSize(radius) + "px").text(function(d) {
          return "" + numberFormatter(d) + gaugeSymbol;
        });
        var deltaNumberWidth = DOMUtils.getSVGElementSize(DOMUtils.appendOrSelect(svg, ".gauge-delta-number"), { useBBox: true }).width;
        var arrowEnabled = Tools.getProperty(options2, "gauge", "deltaArrow", "enabled");
        var deltaArrow = deltaGroup.selectAll("svg.gauge-delta-arrow").data(delta !== null && arrowEnabled ? [delta] : []);
        deltaArrow.enter().append("svg").merge(deltaArrow).attr("class", "gauge-delta-arrow").attr("x", -arrowSize(radius) - deltaNumberWidth / 2).attr("y", -arrowSize(radius) / 2 - deltaFontSize(radius) * 0.35).attr("width", arrowSize(radius)).attr("height", arrowSize(radius)).attr("viewBox", "0 0 16 16").each(function() {
          var deltaArrowSelection = select(this);
          DOMUtils.appendOrSelect(deltaArrowSelection, "rect.gauge-delta-arrow-backdrop").attr("width", "16").attr("height", "16").attr("fill", "none");
          var status = Tools.getProperty(options2, "gauge", "status");
          DOMUtils.appendOrSelect(deltaArrowSelection, "polygon.gauge-delta-arrow").attr("class", status !== null ? "gauge-delta-arrow status--" + status : "").attr("points", self2.getArrow(delta));
        });
        deltaArrow.exit().remove();
        deltaNumber.exit().remove();
      };
      Gauge2.prototype.getInnerRadius = function() {
        var radius = this.computeRadius();
        var arcWidth = Tools.getProperty(this.getOptions(), "gauge", "arcWidth");
        return radius - arcWidth;
      };
      Gauge2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("path.arc-foreground").on("mouseover", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEOVER, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Gauge.ARC_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Gauge.ARC_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        });
      };
      Gauge2.prototype.computeRadius = function() {
        var options2 = this.getOptions();
        var arcType = Tools.getProperty(options2, "gauge", "type");
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var radius = arcType === GaugeTypes.SEMI ? Math.min(width / 2, height) : Math.min(width / 2, height / 2);
        return radius;
      };
      return Gauge2;
    }(Component);
    __extends$_ = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Donut = function(_super) {
      __extends$_(Donut2, _super);
      function Donut2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "donut";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Donut2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        _super.prototype.render.call(this, animate);
        var self2 = this;
        if (this.model.isDataEmpty()) {
          this.getComponentContainer().select("g.center").remove();
          return;
        }
        var svg = DOMUtils.appendOrSelect(this.getComponentContainer(), "g.center");
        var options2 = this.getOptions();
        var radius = this.computeRadius();
        var donutTitle = Tools.getProperty(options2, "donut", "center", "label");
        DOMUtils.appendOrSelect(svg, "text.donut-figure").attr("text-anchor", "middle").style("dominant-baseline", function() {
          if (donutTitle === null || donutTitle === "") {
            return "central";
          }
          return "initial";
        }).style("font-size", function() {
          return options2.donut.center.numberFontSize(radius);
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "donut-figure-enter-update",
            animate
          });
        }).tween("text", function() {
          return self2.centerNumberTween(select(this));
        });
        if (donutTitle !== null && donutTitle !== "") {
          DOMUtils.appendOrSelect(svg, "text.donut-title").attr("text-anchor", "middle").style("font-size", function() {
            return options2.donut.center.titleFontSize(radius);
          }).attr("y", options2.donut.center.titleYPosition(radius)).text(donutTitle);
        }
      };
      Donut2.prototype.getInnerRadius = function() {
        var radius = this.computeRadius();
        return radius * (3 / 4);
      };
      Donut2.prototype.centerNumberTween = function(d3Ref) {
        var options2 = this.getOptions();
        var donutCenterFigure = Tools.getProperty(options2, "donut", "center", "number");
        if (donutCenterFigure === null) {
          donutCenterFigure = this.model.getDisplayData().reduce(function(accumulator, d) {
            return accumulator + d[options2.pie.valueMapsTo];
          }, 0);
        }
        var currentValue = parseInt(d3Ref.text().replace(/[, ]+/g, ""), 10) || 0;
        var interpolateFunction;
        if (currentValue % 1 === 0 && donutCenterFigure % 1 === 0) {
          interpolateFunction = interpolateRound;
        } else {
          interpolateFunction = interpolateNumber;
        }
        var i2 = interpolateFunction(currentValue, donutCenterFigure);
        return function(t2) {
          var numberFormatter = options2.donut.center.numberFormatter;
          d3Ref.text(numberFormatter(i2(t2)));
        };
      };
      return Donut2;
    }(Pie);
    __extends$Z = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Skeleton = function(_super) {
      __extends$Z(Skeleton2, _super);
      function Skeleton2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "skeleton";
        return _this;
      }
      Skeleton2.prototype.render = function() {
        var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
        if (isDataLoading) {
          this.renderSkeleton(isDataLoading);
        } else {
          this.removeSkeleton();
        }
      };
      Skeleton2.prototype.renderSkeleton = function(showShimmerEffect) {
        if (this.configs.skeleton === Skeletons.GRID) {
          this.renderGridSkeleton(showShimmerEffect);
        } else if (this.configs.skeleton === Skeletons.VERT_OR_HORIZ) {
          this.renderVertOrHorizSkeleton(showShimmerEffect);
        } else if (this.configs.skeleton === Skeletons.PIE) {
          this.renderPieSkeleton(showShimmerEffect);
        } else if (this.configs.skeleton === Skeletons.DONUT) {
          this.renderDonutSkeleton(showShimmerEffect);
        } else {
          throw new Error('"' + this.configs.skeleton + '" is not a valid Skeleton type.');
        }
      };
      Skeleton2.prototype.renderGridSkeleton = function(showShimmerEffect) {
        this.setScales();
        this.drawBackdrop(showShimmerEffect);
        this.drawXGrid(showShimmerEffect);
        this.drawYGrid(showShimmerEffect);
        if (showShimmerEffect) {
          this.setShimmerEffect("shimmer-lines");
        }
      };
      Skeleton2.prototype.renderVertOrHorizSkeleton = function(showShimmerEffect) {
        var orientation = this.services.cartesianScales.getOrientation();
        this.setScales();
        this.drawBackdrop(showShimmerEffect);
        if (orientation === CartesianOrientations.VERTICAL) {
          this.drawYGrid(showShimmerEffect);
        }
        if (orientation === CartesianOrientations.HORIZONTAL) {
          this.drawXGrid(showShimmerEffect);
        }
        this.setShimmerEffect("shimmer-lines");
      };
      Skeleton2.prototype.renderPieSkeleton = function(showShimmerEffect) {
        var outerRadius = this.computeOuterRadius();
        var innerRadius = 0;
        this.drawRing(outerRadius, innerRadius, showShimmerEffect);
        if (showShimmerEffect) {
          this.setShimmerEffect("shimmer-areas");
        }
      };
      Skeleton2.prototype.renderDonutSkeleton = function(showShimmerEffect) {
        var outerRadius = this.computeOuterRadius();
        var innerRadius = this.computeInnerRadius();
        this.drawRing(outerRadius, innerRadius, showShimmerEffect);
        if (showShimmerEffect) {
          this.setShimmerEffect("shimmer-areas");
        }
      };
      Skeleton2.prototype.setScales = function() {
        var xRange = this.services.cartesianScales.getMainXScale().range();
        var yRange = this.services.cartesianScales.getMainYScale().range();
        this.xScale = linear().domain([0, 1]).range(xRange);
        this.yScale = linear().domain([0, 1]).range(yRange);
      };
      Skeleton2.prototype.drawBackdrop = function(showShimmerEffect) {
        var svg = this.parent;
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton.DAII").attr("width", width).attr("height", height);
        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
        backdropRect.attr("width", "100%").attr("height", "100%");
        var _b = this.xScale.range(), xScaleStart = _b[0];
        _b[1];
        var _c = this.yScale.range();
        _c[0];
        var yScaleStart = _c[1];
        this.backdrop.merge(backdropRect).attr("x", xScaleStart).attr("y", yScaleStart);
        backdropRect.classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
      };
      Skeleton2.prototype.drawXGrid = function(showShimmerEffect) {
        var width = this.backdrop.attr("width");
        var ticksNumber = Tools.getProperty(this.getOptions(), "grid", "x", "numberOfTicks");
        var ticksValues = this.xScale.ticks(ticksNumber).map(function(d) {
          return d * width;
        });
        var xGridG = DOMUtils.appendOrSelect(this.backdrop, "g.x.skeleton");
        var update = xGridG.selectAll("line").data(ticksValues);
        update.enter().append("line").merge(update).attr("x1", function(d) {
          return d;
        }).attr("x2", function(d) {
          return d;
        }).attr("y1", 0).attr("y2", "100%");
        xGridG.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
      };
      Skeleton2.prototype.drawYGrid = function(showShimmerEffect) {
        var height = this.backdrop.attr("height");
        var width = this.backdrop.attr("width");
        var ticksNumber = Tools.getProperty(this.getOptions(), "grid", "y", "numberOfTicks");
        var ticksValues = this.xScale.ticks(ticksNumber).map(function(d) {
          return d * height;
        });
        var yGridG = DOMUtils.appendOrSelect(this.backdrop, "g.y.skeleton");
        var update = yGridG.selectAll("line").data(ticksValues);
        update.enter().append("line").merge(update).attr("x1", 0).attr("x2", width).attr("y1", function(d) {
          return d;
        }).attr("y2", function(d) {
          return d;
        });
        yGridG.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
      };
      Skeleton2.prototype.drawRing = function(outerRadius, innerRadius, shimmer) {
        if (shimmer === void 0) {
          shimmer = true;
        }
        var svg = this.parent;
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var container = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton").attr("width", width).attr("height", height);
        var optionName = innerRadius === 0 ? "pie" : "donut";
        var alignment = Tools.getProperty(this.getOptions(), optionName, "alignment");
        DOMUtils.appendOrSelect(container, "rect.chart-skeleton-area-container").attr("width", width).attr("height", height).attr("fill", "none");
        var arcPathGenerator = arc().innerRadius(innerRadius).outerRadius(outerRadius).startAngle(0).endAngle(Math.PI * 2);
        var tcx = outerRadius + Math.abs(pie$1.radiusOffset);
        var tcy = outerRadius + (Math.min(width, height) - outerRadius * 2) / 2;
        var skeletonAreaShape = DOMUtils.appendOrSelect(container, "path").attr("class", "skeleton-area-shape").attr("transform", "translate(" + tcx + ", " + tcy + ")").attr("d", arcPathGenerator).classed("shimmer-effect-areas", shimmer).classed("empty-state-areas", !shimmer).style("fill", shimmer ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-areas") + ")" : null);
        var translateX2 = outerRadius + pie$1.xOffset;
        if (alignment === Alignments.CENTER) {
          translateX2 = width / 2;
        } else if (alignment === Alignments.RIGHT) {
          translateX2 = width - outerRadius - pie$1.xOffset;
        }
        var translateY2 = outerRadius + pie$1.yOffset;
        skeletonAreaShape.attr("transform", "translate(" + translateX2 + ", " + translateY2 + ")");
      };
      Skeleton2.prototype.computeOuterRadius = function() {
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var radius = Math.min(width, height) / 2;
        return radius + pie$1.radiusOffset;
      };
      Skeleton2.prototype.computeInnerRadius = function() {
        return this.computeOuterRadius() * (3 / 4);
      };
      Skeleton2.prototype.setShimmerEffect = function(gradientId) {
        var animationDuration = 2e3;
        var delay = 1e3;
        var shimmerWidth = 0.2;
        var stopBgShimmerClass = "stop-bg-shimmer";
        var stopShimmerClass = "stop-shimmer";
        var container = this.parent.select(".chart-skeleton");
        var width = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }).width;
        var startPoint = 0;
        var endPoint = width;
        var defs = DOMUtils.appendOrSelect(container, "defs").lower();
        var linearGradient = DOMUtils.appendOrSelect(defs, "linearGradient").attr("id", this.services.domUtils.generateElementIDString(gradientId)).attr("class", gradientId).attr("x1", startPoint - 3 * shimmerWidth * width).attr("x2", endPoint).attr("y1", 0).attr("y2", 0).attr("gradientUnits", "userSpaceOnUse").attr("gradientTransform", "translate(0, 0)");
        var stops = '\n			<stop class="' + stopBgShimmerClass + '" offset="' + startPoint + '"></stop>\n			<stop class="' + stopShimmerClass + '" offset="' + (startPoint + shimmerWidth) + '"></stop>\n			<stop class="' + stopBgShimmerClass + '" offset="' + (startPoint + 2 * shimmerWidth) + '"></stop>\n		';
        linearGradient.html(stops);
        repeat();
        function repeat() {
          linearGradient.attr("gradientTransform", "translate(" + (startPoint - 3 * shimmerWidth * width) + ", 0)").transition().duration(animationDuration).delay(delay).ease(linear$2).attr("gradientTransform", "translate(" + (endPoint + 3 * shimmerWidth * width) + ", 0)").on("end", repeat);
        }
      };
      Skeleton2.prototype.removeSkeleton = function() {
        var container = this.parent.select(".chart-skeleton");
        container.remove();
      };
      return Skeleton2;
    }(Component);
    __extends$Y = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    SkeletonLines = function(_super) {
      __extends$Y(SkeletonLines2, _super);
      function SkeletonLines2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "skeleton-lines";
        return _this;
      }
      SkeletonLines2.prototype.render = function() {
        var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
        var isSparkline = !Tools.getProperty(this.getOptions(), "grid", "x", "enabled") && !Tools.getProperty(this.getOptions(), "grid", "y", "enabled") && !Tools.getProperty(this.getOptions(), "axes", "bottom", "visible") && !Tools.getProperty(this.getOptions(), "axes", "left", "visible");
        if (isDataLoading && !isSparkline) {
          _super.prototype.renderGridSkeleton.call(this, isDataLoading);
        } else if (isDataLoading && isSparkline) {
          this.renderSparklineSkeleton(isDataLoading);
        } else {
          this.removeSkeleton();
        }
      };
      SkeletonLines2.prototype.renderSparklineSkeleton = function(showShimmerEffect) {
        this.setScales();
        this.drawBackdrop(showShimmerEffect);
        this.drawSparkline(showShimmerEffect);
        this.updateBackdropStyle();
        if (showShimmerEffect) {
          this.setShimmerEffect("shimmer-lines");
        }
      };
      SkeletonLines2.prototype.drawSparkline = function(showShimmerEffect) {
        var width = this.backdrop.attr("width");
        var ticksValues = [100];
        var sparklineSkeleton = DOMUtils.appendOrSelect(this.backdrop, "g.y.skeleton");
        var update = sparklineSkeleton.selectAll("line").data(ticksValues);
        update.enter().append("line").merge(update).attr("x1", 0).attr("x2", width).attr("y1", function(d) {
          return d;
        }).attr("y2", function(d) {
          return d;
        });
        sparklineSkeleton.selectAll("line").classed("shimmer-effect-lines", showShimmerEffect).classed("empty-state-lines", !showShimmerEffect).style("stroke", showShimmerEffect ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
      };
      SkeletonLines2.prototype.updateBackdropStyle = function() {
        var svg = this.parent;
        this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-skeleton.DAII");
        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, "rect.chart-skeleton-backdrop");
        backdropRect.classed("shimmer-effect-lines", false).classed("shimmer-effect-sparkline", true).style("stroke", null);
      };
      return SkeletonLines2;
    }(Skeleton);
    Node$2.prototype = hierarchy.prototype = {
      constructor: Node$2,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };
    TreeNode.prototype = Object.create(Node$2.prototype);
    phi = (1 + Math.sqrt(5)) / 2;
    squarify = function custom8(ratio) {
      function squarify2(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }
      squarify2.ratio = function(x22) {
        return custom8((x22 = +x22) > 1 ? x22 : 1);
      };
      return squarify2;
    }(phi);
    __extends$X = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    NODE_OFFSET = 6;
    Tree = function(_super) {
      __extends$X(Tree2, _super);
      function Tree2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "tree";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Tree2.prototype.getLongestLabel = function(data) {
        var _this = this;
        var longestLabel = "";
        data.forEach(function(d) {
          var longestLabelInChildren = d.children ? _this.getLongestLabel(d.children) : "";
          if (longestLabelInChildren.length > longestLabel.length || d.name.length > longestLabel.length) {
            longestLabel = longestLabelInChildren.length > d.name.length ? longestLabelInChildren : d.name;
          }
        });
        return longestLabel;
      };
      Tree2.prototype.getMockLabelWidth = function(svg, label) {
        var mockLabel = svg.append("text").attr("dy", "0.31em").attr("x", 0).attr("text-anchor", "end").text(label);
        var mockLabelWidth = DOMUtils.getSVGElementSize(mockLabel.node(), {
          useBBox: true
        }).width;
        mockLabel.remove();
        return mockLabelWidth;
      };
      Tree2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer();
        svg.html("");
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        if (width < 1 || height < 1) {
          return;
        }
        var options2 = this.model.getOptions();
        var displayData = this.model.getDisplayData();
        var rootTitle = Tools.getProperty(options2, "tree", "rootTitle") || "Tree";
        var mockRootTitleWidth = this.getMockLabelWidth(svg, rootTitle);
        var longestLabel = this.getLongestLabel(displayData);
        var mockLongestLabelWidth = this.getMockLabelWidth(svg, longestLabel);
        var margin = {
          top: 0,
          right: 0,
          bottom: 0,
          left: mockRootTitleWidth > 0 ? mockRootTitleWidth + NODE_OFFSET : 30 - NODE_OFFSET
        };
        var root2 = hierarchy({
          name: rootTitle,
          children: displayData
        });
        var dx = 10;
        var dy = width / 6;
        var update = function(source) {
          var nodes = root2.descendants().reverse();
          var links = root2.links();
          var left2 = root2;
          var right2 = root2;
          root2.eachBefore(function(node) {
            if (node.x < left2.x)
              left2 = node;
            if (node.x > right2.x)
              right2 = node;
          });
          var height2 = right2.x - left2.x;
          var transition = svg.transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "tree-update-viewbox",
              animate: true
            });
          }).attr("viewBox", [-margin.left, left2.x, width, height2]);
          var nodeGroups = nodeGroup.selectAll("g").data(nodes, function(d) {
            return d.id;
          });
          var self2 = _this;
          var nodeGroupsEnter = nodeGroups.enter().append("g").attr("transform", function() {
            return "translate(" + source.y0 + "," + source.x0 + ")";
          }).attr("class", function(d) {
            return d.depth !== 0 && d.children && d.children.length > 0 ? "clickable" : null;
          }).on("mouseover", function(event, d) {
            self2.services.events.dispatchEvent(Events$1.Tree.NODE_MOUSEOVER, {
              event,
              element: select(this),
              datum: d
            });
          }).on("click", function(event, d) {
            if (d.depth !== 0) {
              d.children = d.children ? null : d._children;
              update(d);
            }
            self2.services.events.dispatchEvent(Events$1.Tree.NODE_CLICK, {
              event,
              element: select(this),
              datum: d
            });
          }).on("mouseout", function(event, d) {
            self2.services.events.dispatchEvent(Events$1.Tree.NODE_MOUSEOUT, {
              event,
              element: select(this),
              datum: d
            });
          });
          nodeGroupsEnter.append("circle").attr("r", 2.5).attr("class", function(d) {
            return d._children ? "parent" : "child";
          }).attr("stroke-width", 10);
          nodeGroupsEnter.append("text").attr("dy", "0.31em").attr("x", function(d) {
            return d._children ? -NODE_OFFSET : NODE_OFFSET;
          }).attr("text-anchor", function(d) {
            return d._children ? "end" : "start";
          }).text(function(d) {
            return d.data.name;
          }).clone(true).attr("class", "text-stroke").lower();
          nodeGroups.merge(nodeGroupsEnter).transition(transition).attr("transform", function(d) {
            return "translate(" + d.y + "," + d.x + ")";
          }).attr("fill-opacity", 1).attr("stroke-opacity", 1);
          nodeGroups.exit().transition(transition).remove().attr("transform", function() {
            return "translate(" + source.y + "," + source.x + ")";
          }).attr("fill-opacity", 0).attr("stroke-opacity", 0);
          var linkPaths = linkGroup.selectAll("path").data(links, function(d) {
            return d.target.id;
          });
          var linkPathsEnter = linkPaths.enter().append("path").attr("d", function(d) {
            var o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
          });
          linkPaths.merge(linkPathsEnter).transition(transition).attr("d", diagonal);
          linkPaths.exit().transition(transition).remove().attr("d", function() {
            var o = { x: source.x, y: source.y };
            return diagonal({ source: o, target: o });
          });
          root2.eachBefore(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        };
        var descendants = root2.descendants();
        var maxDepth = descendants[descendants.length - 1].depth;
        var tree = Tools.getProperty(options2, "tree", "type") === TreeTypes.DENDROGRAM ? d3Cluster().size([
          height,
          width - mockLongestLabelWidth - maxDepth * NODE_OFFSET - mockRootTitleWidth
        ]) : d3Tree().nodeSize([dx, dy]).size([
          height,
          width - mockLongestLabelWidth - maxDepth * NODE_OFFSET - mockRootTitleWidth
        ]);
        var diagonal = linkHorizontal$1().x(function(d) {
          return d.y;
        }).y(function(d) {
          return d.x;
        });
        root2.x0 = dy / 2;
        root2.y0 = 0;
        root2.descendants().forEach(function(d, i2) {
          d.id = i2;
          d._children = d.children;
        });
        tree(root2);
        svg.attr("viewBox", [-margin.left, -margin.top, width, dx]).style("user-select", "none");
        var linkGroup = svg.append("g").attr("class", "links");
        var nodeGroup = svg.append("g").attr("class", "nodes");
        update(root2);
      };
      return Tree2;
    }(Component);
    black = "#000000";
    white = "#ffffff";
    yellow10 = "#fcf4d6";
    yellow20 = "#fddc69";
    yellow30 = "#f1c21b";
    yellow40 = "#d2a106";
    yellow50 = "#b28600";
    yellow60 = "#8e6a00";
    yellow70 = "#684e00";
    yellow80 = "#483700";
    yellow90 = "#302400";
    yellow100 = "#1c1500";
    unstable_yellow = {
      10: yellow10,
      20: yellow20,
      30: yellow30,
      40: yellow40,
      50: yellow50,
      60: yellow60,
      70: yellow70,
      80: yellow80,
      90: yellow90,
      100: yellow100
    };
    orange10 = "#fff2e8";
    orange20 = "#ffd9be";
    orange30 = "#ffb784";
    orange40 = "#ff832b";
    orange50 = "#eb6200";
    orange60 = "#ba4e00";
    orange70 = "#8a3800";
    orange80 = "#5e2900";
    orange90 = "#3e1a00";
    orange100 = "#231000";
    unstable_orange = {
      10: orange10,
      20: orange20,
      30: orange30,
      40: orange40,
      50: orange50,
      60: orange60,
      70: orange70,
      80: orange80,
      90: orange90,
      100: orange100
    };
    red10 = "#fff1f1";
    red20 = "#ffd7d9";
    red30 = "#ffb3b8";
    red40 = "#ff8389";
    red50 = "#fa4d56";
    red60 = "#da1e28";
    red70 = "#a2191f";
    red80 = "#750e13";
    red90 = "#520408";
    red100 = "#2d0709";
    red = {
      10: red10,
      20: red20,
      30: red30,
      40: red40,
      50: red50,
      60: red60,
      70: red70,
      80: red80,
      90: red90,
      100: red100
    };
    magenta10 = "#fff0f7";
    magenta20 = "#ffd6e8";
    magenta30 = "#ffafd2";
    magenta40 = "#ff7eb6";
    magenta50 = "#ee5396";
    magenta60 = "#d02670";
    magenta70 = "#9f1853";
    magenta80 = "#740937";
    magenta90 = "#510224";
    magenta100 = "#2a0a18";
    magenta = {
      10: magenta10,
      20: magenta20,
      30: magenta30,
      40: magenta40,
      50: magenta50,
      60: magenta60,
      70: magenta70,
      80: magenta80,
      90: magenta90,
      100: magenta100
    };
    purple10 = "#f6f2ff";
    purple20 = "#e8daff";
    purple30 = "#d4bbff";
    purple40 = "#be95ff";
    purple50 = "#a56eff";
    purple60 = "#8a3ffc";
    purple70 = "#6929c4";
    purple80 = "#491d8b";
    purple90 = "#31135e";
    purple100 = "#1c0f30";
    purple = {
      10: purple10,
      20: purple20,
      30: purple30,
      40: purple40,
      50: purple50,
      60: purple60,
      70: purple70,
      80: purple80,
      90: purple90,
      100: purple100
    };
    blue10 = "#edf5ff";
    blue20 = "#d0e2ff";
    blue30 = "#a6c8ff";
    blue40 = "#78a9ff";
    blue50 = "#4589ff";
    blue60 = "#0f62fe";
    blue70 = "#0043ce";
    blue80 = "#002d9c";
    blue90 = "#001d6c";
    blue100 = "#001141";
    blue = {
      10: blue10,
      20: blue20,
      30: blue30,
      40: blue40,
      50: blue50,
      60: blue60,
      70: blue70,
      80: blue80,
      90: blue90,
      100: blue100
    };
    cyan10 = "#e5f6ff";
    cyan20 = "#bae6ff";
    cyan30 = "#82cfff";
    cyan40 = "#33b1ff";
    cyan50 = "#1192e8";
    cyan60 = "#0072c3";
    cyan70 = "#00539a";
    cyan80 = "#003a6d";
    cyan90 = "#012749";
    cyan100 = "#061727";
    cyan = {
      10: cyan10,
      20: cyan20,
      30: cyan30,
      40: cyan40,
      50: cyan50,
      60: cyan60,
      70: cyan70,
      80: cyan80,
      90: cyan90,
      100: cyan100
    };
    teal10 = "#d9fbfb";
    teal20 = "#9ef0f0";
    teal30 = "#3ddbd9";
    teal40 = "#08bdba";
    teal50 = "#009d9a";
    teal60 = "#007d79";
    teal70 = "#005d5d";
    teal80 = "#004144";
    teal90 = "#022b30";
    teal100 = "#081a1c";
    teal = {
      10: teal10,
      20: teal20,
      30: teal30,
      40: teal40,
      50: teal50,
      60: teal60,
      70: teal70,
      80: teal80,
      90: teal90,
      100: teal100
    };
    green10 = "#defbe6";
    green20 = "#a7f0ba";
    green30 = "#6fdc8c";
    green40 = "#42be65";
    green50 = "#24a148";
    green60 = "#198038";
    green70 = "#0e6027";
    green80 = "#044317";
    green90 = "#022d0d";
    green100 = "#071908";
    green = {
      10: green10,
      20: green20,
      30: green30,
      40: green40,
      50: green50,
      60: green60,
      70: green70,
      80: green80,
      90: green90,
      100: green100
    };
    coolGray10 = "#f2f4f8";
    coolGray20 = "#dde1e6";
    coolGray30 = "#c1c7cd";
    coolGray40 = "#a2a9b0";
    coolGray50 = "#878d96";
    coolGray60 = "#697077";
    coolGray70 = "#4d5358";
    coolGray80 = "#343a3f";
    coolGray90 = "#21272a";
    coolGray100 = "#121619";
    coolGray = {
      10: coolGray10,
      20: coolGray20,
      30: coolGray30,
      40: coolGray40,
      50: coolGray50,
      60: coolGray60,
      70: coolGray70,
      80: coolGray80,
      90: coolGray90,
      100: coolGray100
    };
    gray10 = "#f4f4f4";
    gray20 = "#e0e0e0";
    gray30 = "#c6c6c6";
    gray40 = "#a8a8a8";
    gray50 = "#8d8d8d";
    gray60 = "#6f6f6f";
    gray70 = "#525252";
    gray80 = "#393939";
    gray90 = "#262626";
    gray100 = "#161616";
    gray = {
      10: gray10,
      20: gray20,
      30: gray30,
      40: gray40,
      50: gray50,
      60: gray60,
      70: gray70,
      80: gray80,
      90: gray90,
      100: gray100
    };
    warmGray10 = "#f7f3f2";
    warmGray20 = "#e5e0df";
    warmGray30 = "#cac5c4";
    warmGray40 = "#ada8a8";
    warmGray50 = "#8f8b8b";
    warmGray60 = "#726e6e";
    warmGray70 = "#565151";
    warmGray80 = "#3c3838";
    warmGray90 = "#272525";
    warmGray100 = "#171414";
    warmGray = {
      10: warmGray10,
      20: warmGray20,
      30: warmGray30,
      40: warmGray40,
      50: warmGray50,
      60: warmGray60,
      70: warmGray70,
      80: warmGray80,
      90: warmGray90,
      100: warmGray100
    };
    colors = {
      black: {
        100: black
      },
      blue,
      coolGray,
      cyan,
      gray,
      green,
      magenta,
      orange: unstable_orange,
      purple,
      red,
      teal,
      warmGray,
      white: {
        0: white
      },
      yellow: unstable_yellow
    };
    __extends$W = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    findColorShade = function(hex2) {
      if (!hex2) {
        return null;
      }
      for (var _i = 0, _a22 = Object.keys(colors); _i < _a22.length; _i++) {
        var colorName = _a22[_i];
        var colorShades = colors[colorName];
        for (var _b = 0, _c = Object.keys(colorShades); _b < _c.length; _b++) {
          var colorShadeLevel = _c[_b];
          var colorShade = colorShades[colorShadeLevel];
          if (colorShade === hex2) {
            return colorShadeLevel;
          }
        }
      }
      return null;
    };
    textFillColor = function() {
      var correspondingLeaf = select(this.parentNode).select("rect.leaf");
      var correspondingLeafFill = getComputedStyle(correspondingLeaf.node(), null).getPropertyValue("fill");
      var cl = color(correspondingLeafFill);
      var colorShade;
      if (cl) {
        colorShade = findColorShade(cl ? cl.hex() : null);
      }
      if (colorShade === null || colorShade === void 0) {
        var lightness = hsl(cl).l;
        colorShade = Math.abs(lightness * 100 - 100);
      }
      return colorShade > 50 ? "white" : "black";
    };
    uidCounter = 0;
    Treemap = function(_super) {
      __extends$W(Treemap2, _super);
      function Treemap2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "treemap";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          _this.parent.selectAll("g[data-name='leaf']").transition("legend-hover-treemap").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-treemap"
            });
          }).attr("opacity", function(d) {
            return d.parent.data.name === hoveredElement.datum()["name"] ? 1 : 0.3;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("g[data-name='leaf']").transition("legend-mouseout-treemap").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-treemap"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      Treemap2.prototype.init = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Treemap2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var svg = this.getComponentContainer();
        this.model.getData();
        var displayData = this.model.getDisplayData();
        var options2 = this.model.getOptions();
        var windowLocation = Tools.getProperty(window, "location");
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var hierarchy$1 = hierarchy({
          name: options2.title || "Treemap",
          children: displayData
        }).sum(function(d) {
          return d.value;
        }).sort(function(a, b) {
          return b.value - a.value;
        });
        var root2 = d3Treemap().size([width, height]).paddingInner(1).paddingOuter(0).round(true)(hierarchy$1);
        this.services.transitions;
        var leafGroups = svg.selectAll("g[data-name='leaf']").data(root2.leaves(), function(leaf) {
          return leaf.data.name;
        });
        leafGroups.exit().attr("opacity", 0).remove();
        var enteringLeafGroups = leafGroups.enter().append("g").attr("data-name", "leaf").attr("data-uid", function() {
          return uidCounter++;
        });
        var allLeafGroups = enteringLeafGroups.merge(leafGroups);
        allLeafGroups.attr("data-name", "leaf").transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "treemap-group-update",
            animate
          });
        }).attr("transform", function(d) {
          return "translate(" + d.x0 + "," + d.y0 + ")";
        });
        var rects = allLeafGroups.selectAll("rect.leaf").data(function(d) {
          return [d];
        });
        rects.exit().attr("width", 0).attr("height", 0).remove();
        var enteringRects = rects.enter().append("rect").classed("leaf", true);
        enteringRects.merge(rects).attr("width", 0).attr("height", 0).attr("id", function() {
          var uid = select(this.parentNode).attr("data-uid");
          return options2.style.prefix + "-leaf-" + uid;
        }).attr("class", function(d) {
          while (d.depth > 1)
            d = d.parent;
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d.data.name,
            originalClassName: "leaf"
          });
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "treemap-leaf-update-enter",
            animate
          });
        }).attr("width", function(d) {
          return d.x1 - d.x0;
        }).attr("height", function(d) {
          return d.y1 - d.y0;
        }).style("fill", function(d) {
          while (d.depth > 1)
            d = d.parent;
          return _this.model.getFillColor(d.data.name);
        });
        allLeafGroups.selectAll("clipPath").data(function(d) {
          if (d.data.showLabel !== true) {
            return [];
          }
          return [1];
        }, function(d) {
          return d;
        }).join(function(enter) {
          enter.append("clipPath").attr("id", function() {
            var uid = select(this.parentNode).attr("data-uid");
            return options2.style.prefix + "-clip-" + uid;
          }).append("use").attr("xlink:href", function() {
            var uid = select(this.parentNode.parentNode).attr("data-uid");
            var leafID = options2.style.prefix + "-leaf-" + uid;
            return new URL("#" + leafID, windowLocation) + "";
          });
        }, function(update) {
          return null;
        }, function(exit) {
          return exit.remove();
        });
        allLeafGroups.selectAll("text").data(function(d) {
          if (d.data.showLabel !== true) {
            return [];
          }
          var parent = d;
          while (parent.depth > 1)
            parent = parent.parent;
          var color2 = hsl(_this.model.getFillColor(parent.data.name));
          return [
            {
              text: d.data.name,
              color: color2.l < 0.5 ? "white" : "black"
            }
          ];
        }, function(d) {
          return d;
        }).join(function(enter) {
          var addedText = enter.append("text").text(function(d) {
            return d.text;
          }).style("fill", textFillColor).attr("x", 7).attr("y", 18);
          if (windowLocation) {
            addedText.attr("clip-path", function() {
              var uid = select(this.parentNode).attr("data-uid");
              var clipPathID = options2.style.prefix + "-clip-" + uid;
              return "url(" + (new URL("#" + clipPathID, windowLocation) + "") + ")";
            });
          }
        }, function(update) {
          return update.text(function(d) {
            return d.text;
          }).style("fill", textFillColor);
        }, function(exit) {
          return exit.remove();
        });
        this.addEventListeners();
      };
      Treemap2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("rect.leaf").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          var fillColor = getComputedStyle(this, null).getPropertyValue("fill");
          var parent = datum2;
          while (parent.depth > 1)
            parent = parent.parent;
          hoveredElement.transition("graph_element_mouseover_fill_update").call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "graph_element_mouseover_fill_update"
            });
          }).style("fill", function(d) {
            var customColor = self2.model.getFillColor(d.parent.data.name);
            if (customColor) {
              fillColor = customColor;
            }
            return color(fillColor).darker(0.7).toString();
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                color: fillColor,
                label: parent.data.name,
                bold: true
              },
              {
                label: datum2.data.name,
                value: datum2.data.value
              }
            ]
          });
          self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          var parent = datum2;
          while (parent.depth > 1)
            parent = parent.parent;
          hoveredElement.transition().call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "graph_element_mouseout_fill_update"
            });
          }).style("fill", function(d) {
            return self2.model.getFillColor(d.parent.data.name);
          });
          self2.services.events.dispatchEvent(Events$1.Treemap.LEAF_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      return Treemap2;
    }(Component);
    __extends$V = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Radar = function(_super) {
      __extends$V(Radar2, _super);
      function Radar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "radar";
        _this.renderType = RenderTypes.SVG;
        _this.getLabelDimensions = function(label) {
          var tmpTick = DOMUtils.appendOrSelect(_this.getComponentContainer(), "g.tmp-tick");
          var tmpTickText = DOMUtils.appendOrSelect(tmpTick, "text").text(label);
          var _a22 = DOMUtils.getSVGElementSize(tmpTickText.node(), { useBBox: true }), width = _a22.width, height = _a22.height;
          tmpTick.remove();
          return { width, height };
        };
        _this.normalizeFlatData = function(dataset) {
          var options2 = _this.getOptions();
          var _a22 = Tools.getProperty(options2, "radar", "axes"), angle = _a22.angle, value2 = _a22.value;
          var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
          var completeBlankData = Tools.flatMapDeep(_this.uniqueKeys.map(function(key2) {
            return _this.uniqueGroups.map(function(group) {
              var _a32;
              return _a32 = {}, _a32[angle] = key2, _a32[groupMapsTo] = group, _a32[value2] = null, _a32;
            });
          }));
          return Tools.merge(completeBlankData, dataset);
        };
        _this.normalizeGroupedData = function(dataset) {
          var options2 = _this.getOptions();
          var _a22 = Tools.getProperty(options2, "radar", "axes"), angle = _a22.angle, value2 = _a22.value;
          var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
          return dataset.map(function(_a32) {
            var name = _a32.name, data = _a32.data;
            var completeBlankData = _this.uniqueKeys.map(function(k) {
              var _a42;
              return _a42 = {}, _a42[groupMapsTo] = name, _a42[angle] = k, _a42[value2] = null, _a42;
            });
            return { name, data: Tools.merge(completeBlankData, data) };
          });
        };
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          _this.parent.selectAll("g.blobs path").transition("legend-hover-blob").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-blob"
            });
          }).style("fill-opacity", function(group) {
            if (group.name !== hoveredElement.datum().name) {
              return radar.opacity.unselected;
            }
            return radar.opacity.selected;
          }).style("stroke-opacity", function(group) {
            if (group.name !== hoveredElement.datum().name) {
              return radar.opacity.unselected;
            }
            return 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("g.blobs path").transition("legend-mouseout-blob").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-blob"
            });
          }).style("fill-opacity", radar.opacity.selected).style("stroke-opacity", 1);
        };
        return _this;
      }
      Radar2.prototype.init = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Radar2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var svg = this.getComponentContainer();
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var data = this.model.getData();
        var groupedData = this.model.getGroupedData();
        var options2 = this.getOptions();
        var groupMapsTo = Tools.getProperty(options2, "data", "groupMapsTo");
        var valueMapsTo = Tools.getProperty(options2, "radar", "axes", "value");
        var _b = Tools.getProperty(options2, "radar", "axes"), angle = _b.angle, value2 = _b.value;
        var _c = radar, xLabelPadding = _c.xLabelPadding, yLabelPadding = _c.yLabelPadding, yTicksNumber = _c.yTicksNumber, minRange = _c.minRange, xAxisRectHeight = _c.xAxisRectHeight;
        this.uniqueKeys = Array.from(new Set(data.map(function(d) {
          return d[angle];
        })));
        this.uniqueGroups = Array.from(new Set(data.map(function(d) {
          return d[groupMapsTo];
        })));
        this.fullDataNormalized = this.normalizeFlatData(data);
        this.groupedDataNormalized = this.normalizeGroupedData(groupedData);
        var labelHeight = this.getLabelDimensions(this.uniqueKeys[0]).height;
        var margin = 2 * (labelHeight + yLabelPadding);
        var size = Math.min(width, height);
        var diameter = size - margin;
        var radius = diameter / 2;
        if (radius <= 0) {
          return;
        }
        var xScale = band().domain(this.fullDataNormalized.map(function(d) {
          return d[angle];
        })).range([0, 2 * Math.PI].map(function(a) {
          return a - Math.PI / 2;
        }));
        var centerPointMinValue = min$3(this.fullDataNormalized.map(function(d) {
          return d[value2];
        }));
        var yScale = linear().domain([
          centerPointMinValue >= 0 ? 0 : centerPointMinValue,
          max$3(this.fullDataNormalized.map(function(d) {
            return d[value2];
          }))
        ]).range([minRange, radius]).nice(yTicksNumber);
        var yTicks = yScale.ticks(yTicksNumber);
        var colorScale = function(group) {
          return _this.model.getFillColor(group);
        };
        var radialLineGenerator = lineRadial$1().angle(function(d) {
          return xScale(d[angle]) + Math.PI / 2;
        }).radius(function(d) {
          return yScale(d[value2]);
        }).curve(curveLinearClosed);
        var horizSpaceNeededByEachXLabel = this.uniqueKeys.map(function(key2) {
          var tickWidth = _this.getLabelDimensions(key2).width;
          var distanceFromDiameter = distanceBetweenPointOnCircAndVerticalDiameter(xScale(key2), radius);
          return tickWidth + distanceFromDiameter;
        });
        var leftPadding = max$3(horizSpaceNeededByEachXLabel);
        var c = {
          x: leftPadding + xLabelPadding,
          y: height / 2
        };
        var yAxes = DOMUtils.appendOrSelect(svg, "g.y-axes").attr("role", Roles.GROUP);
        var yAxisUpdate = yAxes.selectAll("path").data(yTicks, function(tick) {
          return tick;
        });
        var shapeData = function(tick) {
          return _this.uniqueKeys.map(function(key2) {
            var _a32;
            return _a32 = {}, _a32[angle] = key2, _a32[value2] = tick, _a32;
          });
        };
        yAxisUpdate.join(function(enter) {
          return enter.append("path").attr("opacity", 0).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("fill", "none").call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_axes_enter",
                animate
              });
            }).attr("opacity", 1).attr("d", function(tick) {
              return radialLineGenerator(shapeData(tick));
            });
          });
        }, function(update) {
          return update.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_axes_update",
                animate
              });
            }).attr("opacity", 1).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("d", function(tick) {
              return radialLineGenerator(shapeData(tick));
            });
          });
        }, function(exit) {
          return exit.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_axes_exit",
                animate
              });
            }).attr("d", function(tick) {
              return radialLineGenerator(shapeData(tick));
            }).attr("opacity", 0).remove();
          });
        });
        var xAxes = DOMUtils.appendOrSelect(svg, "g.x-axes").attr("role", Roles.GROUP);
        var xAxisUpdate = xAxes.selectAll("line").data(this.uniqueKeys, function(key2) {
          return key2;
        });
        xAxisUpdate.join(function(enter) {
          return enter.append("line").attr("opacity", 0).attr("class", function(key2) {
            return "x-axis-" + Tools.kebabCase(key2);
          }).attr("stroke-dasharray", "0").attr("x1", function(key2) {
            return polarToCartesianCoords(xScale(key2), 0, c).x;
          }).attr("y1", function(key2) {
            return polarToCartesianCoords(xScale(key2), 0, c).y;
          }).attr("x2", function(key2) {
            return polarToCartesianCoords(xScale(key2), 0, c).x;
          }).attr("y2", function(key2) {
            return polarToCartesianCoords(xScale(key2), 0, c).y;
          }).call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_axes_enter",
                animate
              });
            }).attr("opacity", 1).attr("x1", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[0], c).x;
            }).attr("y1", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[0], c).y;
            }).attr("x2", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1], c).x;
            }).attr("y2", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1], c).y;
            });
          });
        }, function(update) {
          return update.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_axes_update",
                animate
              });
            }).attr("opacity", 1).attr("x1", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[0], c).x;
            }).attr("y1", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[0], c).y;
            }).attr("x2", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1], c).x;
            }).attr("y2", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1], c).y;
            });
          });
        }, function(exit) {
          return exit.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_axes_exit",
                animate
              });
            }).attr("opacity", 0).remove();
          });
        });
        var xLabels = DOMUtils.appendOrSelect(svg, "g.x-labels").attr("role", Roles.GROUP);
        var xLabelUpdate = xLabels.selectAll("text").data(this.uniqueKeys);
        xLabelUpdate.join(function(enter) {
          return enter.append("text").text(function(key2) {
            return key2;
          }).attr("opacity", 0).attr("x", function(key2) {
            return polarToCartesianCoords(xScale(key2), yScale.range()[1] + xLabelPadding, c).x;
          }).attr("y", function(key2) {
            return polarToCartesianCoords(xScale(key2), yScale.range()[1] + xLabelPadding, c).y;
          }).style("text-anchor", function(key2) {
            return radialLabelPlacement(xScale(key2)).textAnchor;
          }).style("dominant-baseline", function(key2) {
            return radialLabelPlacement(xScale(key2)).dominantBaseline;
          }).call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_labels_enter",
                animate
              });
            }).attr("opacity", 1);
          });
        }, function(update) {
          return update.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_labels_update",
                animate
              });
            }).attr("opacity", 1).attr("x", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1] + xLabelPadding, c).x;
            }).attr("y", function(key2) {
              return polarToCartesianCoords(xScale(key2), yScale.range()[1] + xLabelPadding, c).y;
            }).end().finally(function() {
              var alignment = Tools.getProperty(options2, "radar", "alignment");
              var alignmentXOffset = _this.getAlignmentXOffset(alignment, svg, _this.getParent());
              svg.attr("x", alignmentXOffset);
            });
          });
        }, function(exit) {
          return exit.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_x_labels_exit",
                animate
              });
            }).attr("opacity", 0).remove();
          });
        });
        var blobs = DOMUtils.appendOrSelect(svg, "g.blobs").attr("role", Roles.GROUP);
        var blobUpdate = blobs.selectAll("path").data(this.groupedDataNormalized, function(group) {
          return group.name;
        });
        blobUpdate.join(function(enter) {
          return enter.append("path").attr("class", function(group) {
            return _this.model.getColorClassName({
              classNameTypes: [
                ColorClassNameTypes.FILL,
                ColorClassNameTypes.STROKE
              ],
              dataGroupName: group.name,
              originalClassName: "blob"
            });
          }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
            return d["name"];
          }).attr("opacity", 0).attr("transform", animate ? function() {
            return "translate(" + c.x + ", " + c.y + ") scale(" + (1 + Math.random() * 0.35) + ")";
          } : "translate(" + c.x + ", " + c.y + ")").style("fill", function(group) {
            return colorScale(group.name);
          }).style("fill-opacity", radar.opacity.selected).style("stroke", function(group) {
            return colorScale(group.name);
          }).call(function(selection2) {
            var selectionUpdate = selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_blobs_enter",
                animate
              });
            });
            if (animate) {
              selectionUpdate.delay(function() {
                return Math.random() * 30;
              }).attr("transform", "translate(" + c.x + ", " + c.y + ")");
            }
            selectionUpdate.attr("opacity", 1).attr("d", function(group) {
              return radialLineGenerator(group.data);
            });
          });
        }, function(update) {
          update.attr("class", function(group) {
            return _this.model.getColorClassName({
              classNameTypes: [
                ColorClassNameTypes.FILL,
                ColorClassNameTypes.STROKE
              ],
              dataGroupName: group.name,
              originalClassName: "blob"
            });
          }).style("fill", function(group) {
            return colorScale(group.name);
          }).style("stroke", function(group) {
            return colorScale(group.name);
          });
          update.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_blobs_update",
                animate
              });
            }).attr("opacity", 1).attr("transform", "translate(" + c.x + ", " + c.y + ")").attr("d", function(group) {
              return radialLineGenerator(group.data);
            });
          });
        }, function(exit) {
          return exit.call(function(selection2) {
            var selectionUpdate = selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_blobs_exit",
                animate
              });
            });
            if (animate) {
              selectionUpdate.delay(function() {
                return Math.random() * 30;
              }).attr("transform", function() {
                return "translate(" + c.x + ", " + c.y + ") scale(" + (1 + Math.random() * 0.35) + ")";
              });
            }
            selectionUpdate.attr("opacity", 0).remove();
          });
        });
        var dots = DOMUtils.appendOrSelect(svg, "g.dots").attr("role", Roles.GROUP);
        var dotsUpdate = dots.selectAll("circle").data(this.fullDataNormalized.filter(function(d) {
          return Tools.getProperty(d, value2) !== null;
        }));
        dotsUpdate.join(function(enter) {
          return enter.append("circle").attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-label", function(d) {
            return d[valueMapsTo];
          });
        }, function(update) {
          return update;
        }, function(exit) {
          return exit.remove();
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: Tools.kebabCase(d[angle])
          });
        }).attr("cx", function(d) {
          return polarToCartesianCoords(xScale(d[angle]), yScale(d[value2]), c).x;
        }).attr("cy", function(d) {
          return polarToCartesianCoords(xScale(d[angle]), yScale(d[value2]), c).y;
        }).attr("r", 0).attr("opacity", 0).style("fill", function(d) {
          return colorScale(d[groupMapsTo]);
        });
        var xAxesRect = DOMUtils.appendOrSelect(svg, "g.x-axes-rect").attr("role", Roles.GROUP);
        var xAxisRectUpdate = xAxesRect.selectAll("rect").data(this.uniqueKeys);
        xAxisRectUpdate.join(function(enter) {
          return enter.append("rect");
        }, function(update) {
          return update;
        }, function(exit) {
          return exit.remove();
        }).attr("x", c.x).attr("y", c.y - xAxisRectHeight / 2).attr("width", yScale.range()[1]).attr("height", xAxisRectHeight).style("fill", "red").style("fill-opacity", 0).attr("transform", function(key2) {
          return "rotate(" + radToDeg(xScale(key2)) + ", " + c.x + ", " + c.y + ")";
        });
        var yLabels = DOMUtils.appendOrSelect(svg, "g.y-labels").attr("role", Roles.GROUP);
        var yLabelUpdate = yLabels.selectAll("text").data(extent(yTicks));
        yLabelUpdate.join(function(enter) {
          return enter.append("text").attr("opacity", 0).text(function(tick) {
            return tick;
          }).attr("x", function(tick) {
            return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).x + yLabelPadding;
          }).attr("y", function(tick) {
            return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).y;
          }).style("text-anchor", "start").style("dominant-baseline", "middle").call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_labels_enter",
                animate
              });
            }).attr("opacity", 1);
          });
        }, function(update) {
          return update.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_labels_update",
                animate
              });
            }).text(function(tick) {
              return tick;
            }).attr("opacity", 1).attr("x", function(tick) {
              return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).x + yLabelPadding;
            }).attr("y", function(tick) {
              return polarToCartesianCoords(-Math.PI / 2, yScale(tick), c).y;
            });
          });
        }, function(exit) {
          return exit.call(function(selection2) {
            return selection2.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "radar_y_labels_exit",
                animate
              });
            }).attr("opacity", 0).remove();
          });
        });
        this.addEventListeners();
      };
      Radar2.prototype.getAlignmentXOffset = function(alignment, svg, parent) {
        var svgDimensions = DOMUtils.getSVGElementSize(svg, {
          useBBox: true
        });
        var width = DOMUtils.getSVGElementSize(parent, {
          useAttrs: true
        }).width;
        var alignmentOffset = 0;
        if (alignment === Alignments.CENTER) {
          alignmentOffset = Math.floor((width - svgDimensions.width) / 2);
        } else if (alignment === Alignments.RIGHT) {
          alignmentOffset = width - svgDimensions.width;
        }
        return alignmentOffset;
      };
      Radar2.prototype.destroy = function() {
        this.parent.selectAll(".x-axes-rect > rect").on("mouseover", null).on("mousemove", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      Radar2.prototype.addEventListeners = function() {
        var self2 = this;
        var angle = Tools.getProperty(this.getOptions(), "radar").axes.angle;
        this.parent.selectAll(".x-axes-rect > rect").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          var axisLine = self2.parent.select(".x-axes .x-axis-" + Tools.kebabCase(datum2));
          var dots = self2.parent.selectAll(".dots circle." + Tools.kebabCase(datum2));
          var activeDataGroupNames = self2.model.getActiveDataGroupNames();
          var options2 = self2.getOptions();
          var groupMapsTo = options2.data.groupMapsTo;
          var valueMapsTo = Tools.getProperty(options2, "radar", "axes", "value");
          axisLine.classed("hovered", true).attr("stroke-dasharray", "4 4");
          dots.classed("hovered", true).attr("opacity", function(d) {
            return activeDataGroupNames.indexOf(d[groupMapsTo]) !== -1 ? 1 : 0;
          }).attr("r", radar.dotsRadius);
          var itemsToHighlight = self2.fullDataNormalized.filter(function(d) {
            return d[angle] === datum2 && activeDataGroupNames.indexOf(d[groupMapsTo]) !== -1;
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: itemsToHighlight.filter(function(datum3) {
              return typeof datum3[valueMapsTo] === "number";
            }).map(function(datum3) {
              return {
                label: datum3[groupMapsTo],
                value: datum3[valueMapsTo],
                color: self2.model.getFillColor(datum3[groupMapsTo]),
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP],
                  dataGroupName: datum3[groupMapsTo]
                })
              };
            })
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          var axisLine = self2.parent.select(".x-axes .x-axis-" + Tools.kebabCase(datum2));
          var dots = self2.parent.selectAll(".dots circle." + Tools.kebabCase(datum2));
          axisLine.classed("hovered", false).attr("stroke-dasharray", "0");
          dots.classed("hovered", false).attr("opacity", 0).attr("r", 0);
          self2.services.events.dispatchEvent(Events$1.Radar.X_AXIS_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
        });
      };
      return Radar2;
    }(Component);
    __extends$U = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$h = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    CirclePack = function(_super) {
      __extends$U(CirclePack2, _super);
      function CirclePack2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "circle-pack";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          _this.parent.selectAll("circle.node").transition("legend-hover-circlepack").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-circlepack"
            });
          }).attr("opacity", function(d) {
            return d.data.dataGroupName === hoveredElement.datum()["name"] ? 1 : circlePack.circles.fillOpacity;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("circle.node").transition("legend-mouseout-circlepack").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-circlepack"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      CirclePack2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        var _a22 = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        if (width < 1 || height < 1) {
          return;
        }
        var displayData = this.model.getDisplayData();
        var parentNode = this.model.hasParentNode();
        var hierarchyLevel = this.model.getHierarchyLevel();
        var options2 = this.getOptions();
        var canvasZoomEnabled = Tools.getProperty(options2, "canvasZoom", "enabled");
        if (parentNode && Tools.getProperty(displayData, 0, "children")) {
          displayData = Tools.getProperty(displayData, 0, "children");
        }
        var root2 = hierarchy({ children: displayData }).sum(function(d) {
          return d.value;
        }).sort(function(a, b) {
          return b.value - a.value;
        });
        var packLayout = D3Pack().size([width, height]).padding(function(d) {
          return d.depth >= 1 ? circlePack.padding.children + 3 : circlePack.padding.mainGroup + 3;
        });
        var nodeData = packLayout(root2).descendants().splice(1).filter(function(node) {
          return node.depth <= hierarchyLevel;
        });
        var circles = svg.selectAll("circle.node").data(nodeData);
        circles.exit().attr("width", 0).attr("height", 0).remove();
        var enteringCircles = circles.enter().append("circle").classed("node", true);
        enteringCircles.merge(circles).attr("class", function(d) {
          var originalClass = canvasZoomEnabled && hierarchyLevel === 3 ? _this.getZoomClass(d) : "";
          return _this.model.getColorClassName({
            classNameTypes: [
              ColorClassNameTypes.FILL,
              ColorClassNameTypes.STROKE
            ],
            dataGroupName: d.data.dataGroupName,
            originalClassName: d.children ? "node " + originalClass : "node node-leaf " + originalClass
          });
        }).style("fill", function(d) {
          return _this.model.getFillColor(d.data.dataGroupName);
        }).style("stroke", function(d) {
          return _this.model.getFillColor(d.data.dataGroupName);
        }).attr("cx", function(d) {
          return d.x;
        }).attr("cy", function(d) {
          return d.y;
        }).transition("circlepack-leaf-update-enter").call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "circlepack-leaf-update-enter"
          });
        }).attr("r", function(d) {
          return d.r;
        }).attr("opacity", 1).attr("fill-opacity", circlePack.circles.fillOpacity);
        if (canvasZoomEnabled === true && this.focal) {
          this.services.canvasZoom.zoomIn(this.focal, enteringCircles, canvasZoomSettings);
          this.setBackgroundListeners();
        }
        if (!parentNode) {
          this.addLegendListeners();
        }
        this.addEventListeners();
      };
      CirclePack2.prototype.unhighlightChildren = function(childData) {
        var _this = this;
        var data = childData.map(function(d) {
          return d.data;
        });
        this.parent.selectAll("circle.node").filter(function(d) {
          return data.some(function(datum2) {
            return datum2 === d.data;
          }) && d.depth > 1;
        }).style("stroke", function(d) {
          return _this.model.getFillColor(d.data.dataGroupName);
        });
      };
      CirclePack2.prototype.highlightChildren = function(childData) {
        var data = childData.map(function(d) {
          return d.data;
        });
        this.parent.selectAll("circle.node").filter(function(d) {
          return data.some(function(datum2) {
            return datum2 === d.data;
          }) && d.depth > 1;
        }).style("stroke", circlePack.circles.hover.stroke);
      };
      CirclePack2.prototype.getZoomClass = function(node) {
        if (this.model.getHierarchyLevel() === 3 && this.focal) {
          if (node.data === this.focal.data || this.focal.children.some(function(d) {
            return d.data === node.data;
          })) {
            return "focal";
          }
        }
        return "non-focal";
      };
      CirclePack2.prototype.addLegendListeners = function() {
        var events = this.services.events;
        events.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        events.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      CirclePack2.prototype.removeBackgroundListeners = function() {
        var chartSvg = select(this.services.domUtils.getMainContainer());
        chartSvg.on("click", function() {
          return null;
        });
      };
      CirclePack2.prototype.setBackgroundListeners = function() {
        var chartSvg = select(this.services.domUtils.getMainContainer());
        var self2 = this;
        var canvasSelection = this.parent.selectAll("circle.node");
        var zoomSetting = Tools.getProperty(Configuration, "canvasZoomSettings");
        chartSvg.on("click", function() {
          self2.focal = null;
          self2.model.updateHierarchyLevel(2);
          chartSvg.classed("zoomed-in", false);
          self2.services.canvasZoom.zoomOut(canvasSelection, zoomSetting);
        });
      };
      CirclePack2.prototype.getZoomIcon = function() {
        return '\n		<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10">\n			<polygon points="5.93 3.71 4.45 3.71 4.45 2.23 3.71 2.23 3.71 3.71 2.23 3.71 2.23 4.45 3.71 4.45 3.71 5.93 4.45 5.93 4.45 4.45 5.93 4.45 5.93 3.71"/>\n			<path d="M7.2,6.67a4,4,0,0,0,1-2.59A4.08,4.08,0,1,0,4.07,8.15h0a4,4,0,0,0,2.59-1L9.48,10,10,9.48Zm-3.12.77A3.34,3.34,0,1,1,7.41,4.08,3.34,3.34,0,0,1,4.08,7.44Z"/>\n		</svg>';
      };
      CirclePack2.prototype.addEventListeners = function() {
        var self2 = this;
        this.parent.selectAll("circle.node").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", true);
          var hierarchyLevel = self2.model.getHierarchyLevel();
          var disabled = hierarchyLevel > 2 && !hoveredElement.classed("focal");
          var canvasZoomEnabled = Tools.getProperty(self2.model.getOptions(), "canvasZoom", "enabled");
          var zoomable = false;
          if (!disabled) {
            var childrenData = [];
            var totalValue = [];
            var parentValue = null;
            if (datum2.children) {
              if (datum2.depth > 1 && canvasZoomEnabled) {
                zoomable = true;
                hoveredElement.classed("clickable", true);
              }
              childrenData = datum2.children.map(function(child) {
                if (child !== null) {
                  if (typeof child.data.value === "number") {
                    return {
                      label: child.data.name,
                      value: child.data.value
                    };
                  } else {
                    return {
                      label: child.data.name,
                      labelIcon: canvasZoomEnabled && hierarchyLevel <= 2 ? self2.getZoomIcon() : null,
                      value: child.value
                    };
                  }
                }
              });
              var options2 = self2.model.getOptions();
              totalValue = [
                {
                  label: get$3(options2, "tooltip.totalLabel") || "Total",
                  value: datum2.value,
                  bold: true
                }
              ];
              self2.highlightChildren(datum2.children);
            } else {
              parentValue = datum2.value;
            }
            var fillColor = getComputedStyle(this, null).getPropertyValue("fill");
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement,
              items: __spreadArrays$h([
                {
                  color: fillColor,
                  label: datum2.data.name,
                  labelIcon: zoomable && canvasZoomEnabled && hierarchyLevel <= 2 ? self2.getZoomIcon() : null,
                  value: parentValue
                }
              ], childrenData, totalValue)
            });
          }
          self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          hoveredElement.classed("hovered", false);
          if (datum2.children) {
            self2.unhighlightChildren(datum2.children);
          }
          self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        }).on("click", function(event, datum2) {
          var hoveredElement = select(this);
          var disabled = hoveredElement.classed("non-focal");
          var canvasZoomEnabled = Tools.getProperty(self2.model.getOptions(), "canvasZoom", "enabled");
          if (canvasZoomEnabled && self2.model.getHierarchyLevel() > 2) {
            var canvasSelection = self2.parent.selectAll("circle.node");
            var chartSvg = select(self2.services.domUtils.getMainContainer());
            chartSvg.classed("zoomed-in", false);
            self2.focal = null;
            self2.model.updateHierarchyLevel(2);
            self2.services.canvasZoom.zoomOut(canvasSelection, canvasZoomSettings);
          } else if (datum2.depth === 2 && datum2.children && !disabled && canvasZoomEnabled) {
            var canvasSelection = self2.parent.selectAll("circle.node");
            var chartSvg = select(self2.services.domUtils.getMainContainer());
            chartSvg.classed("zoomed-in", true);
            self2.focal = datum2;
            self2.model.updateHierarchyLevel(3);
            self2.services.canvasZoom.zoomIn(datum2, canvasSelection, canvasZoomSettings);
            event.stopPropagation();
          }
          self2.services.events.dispatchEvent(Events$1.CirclePack.CIRCLE_CLICK, {
            event,
            element: hoveredElement,
            datum: datum2
          });
        });
      };
      CirclePack2.prototype.destroy = function() {
        this.parent.selectAll("circle.node").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
        this.removeBackgroundListeners();
      };
      return CirclePack2;
    }(Component);
    noop$1 = { value: function() {
    } };
    Dispatch$1.prototype = dispatch$2.prototype = {
      constructor: Dispatch$1,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames$1(typename + "", _), t2, i2 = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i2 < n)
            if ((t2 = (typename = T[i2]).type) && (t2 = get$2(_[t2], typename.name)))
              return t2;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i2 < n) {
          if (t2 = (typename = T[i2]).type)
            _[t2] = set$2(_[t2], typename.name, callback);
          else if (callback == null)
            for (t2 in _)
              _[t2] = set$2(_[t2], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy2 = {}, _ = this._;
        for (var t2 in _)
          copy2[t2] = _[t2].slice();
        return new Dispatch$1(copy2);
      },
      call: function(type2, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i2 = 0, n, t2; i2 < n; ++i2)
            args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (t2 = this._[type2], i2 = 0, n = t2.length; i2 < n; ++i2)
          t2[i2].value.apply(that, args);
      },
      apply: function(type2, that, args) {
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (var t2 = this._[type2], i2 = 0, n = t2.length; i2 < n; ++i2)
          t2[i2].value.apply(that, args);
      }
    };
    src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      dispatch: dispatch$2
    }, Symbol.toStringTag, { value: "Module" }));
    require$$0 = /* @__PURE__ */ getAugmentedNamespace(src);
    dispatch$1 = require$$0.dispatch;
    cloudRadians = Math.PI / 180;
    cw = 1 << 11 >> 5;
    ch = 1 << 11;
    d3Cloud = function() {
      var size = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontStyle = cloudFontNormal, fontWeight = cloudFontNormal, rotate = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, words2 = [], timeInterval = Infinity, event = dispatch$1("word", "end"), timer2 = null, random = Math.random, cloud = {}, canvas = cloudCanvas;
      cloud.canvas = function(_) {
        return arguments.length ? (canvas = functor(_), cloud) : canvas;
      };
      cloud.start = function() {
        var contextAndRatio = getContext(canvas()), board = zeroArray((size[0] >> 5) * size[1]), bounds = null, n = words2.length, i2 = -1, tags = [], data = words2.map(function(d, i22) {
          d.text = text.call(this, d, i22);
          d.font = font.call(this, d, i22);
          d.style = fontStyle.call(this, d, i22);
          d.weight = fontWeight.call(this, d, i22);
          d.rotate = rotate.call(this, d, i22);
          d.size = ~~fontSize.call(this, d, i22);
          d.padding = padding.call(this, d, i22);
          return d;
        }).sort(function(a, b) {
          return b.size - a.size;
        });
        if (timer2)
          clearInterval(timer2);
        timer2 = setInterval(step, 0);
        step();
        return cloud;
        function step() {
          var start2 = Date.now();
          while (Date.now() - start2 < timeInterval && ++i2 < n && timer2) {
            var d = data[i2];
            d.x = size[0] * (random() + 0.5) >> 1;
            d.y = size[1] * (random() + 0.5) >> 1;
            cloudSprite(contextAndRatio, d, data, i2);
            if (d.hasText && place2(board, d, bounds)) {
              tags.push(d);
              event.call("word", cloud, d);
              if (bounds)
                cloudBounds(bounds, d);
              else
                bounds = [{ x: d.x + d.x0, y: d.y + d.y0 }, { x: d.x + d.x1, y: d.y + d.y1 }];
              d.x -= size[0] >> 1;
              d.y -= size[1] >> 1;
            }
          }
          if (i2 >= n) {
            cloud.stop();
            event.call("end", cloud, tags, bounds);
          }
        }
      };
      cloud.stop = function() {
        if (timer2) {
          clearInterval(timer2);
          timer2 = null;
        }
        return cloud;
      };
      function getContext(canvas2) {
        canvas2.width = canvas2.height = 1;
        var ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
        canvas2.width = (cw << 5) / ratio;
        canvas2.height = ch / ratio;
        var context = canvas2.getContext("2d");
        context.fillStyle = context.strokeStyle = "red";
        context.textAlign = "center";
        return { context, ratio };
      }
      function place2(board, tag, bounds) {
        [{ x: 0, y: 0 }, { x: size[0], y: size[1] }];
        var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]), s3 = spiral(size), dt = random() < 0.5 ? 1 : -1, t2 = -dt, dxdy, dx, dy;
        while (dxdy = s3(t2 += dt)) {
          dx = ~~dxdy[0];
          dy = ~~dxdy[1];
          if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
            break;
          tag.x = startX + dx;
          tag.y = startY + dy;
          if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1])
            continue;
          if (!bounds || !cloudCollide(tag, board, size[0])) {
            if (!bounds || collideRects(tag, bounds)) {
              var sprite = tag.sprite, w = tag.width >> 5, sw = size[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h2 = tag.y1 - tag.y0, x22 = (tag.y + tag.y0) * sw + (lx >> 5), last2;
              for (var j = 0; j < h2; j++) {
                last2 = 0;
                for (var i2 = 0; i2 <= w; i2++) {
                  board[x22 + i2] |= last2 << msx | (i2 < w ? (last2 = sprite[j * w + i2]) >>> sx : 0);
                }
                x22 += sw;
              }
              delete tag.sprite;
              return true;
            }
          }
        }
        return false;
      }
      cloud.timeInterval = function(_) {
        return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;
      };
      cloud.words = function(_) {
        return arguments.length ? (words2 = _, cloud) : words2;
      };
      cloud.size = function(_) {
        return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;
      };
      cloud.font = function(_) {
        return arguments.length ? (font = functor(_), cloud) : font;
      };
      cloud.fontStyle = function(_) {
        return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;
      };
      cloud.fontWeight = function(_) {
        return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;
      };
      cloud.rotate = function(_) {
        return arguments.length ? (rotate = functor(_), cloud) : rotate;
      };
      cloud.text = function(_) {
        return arguments.length ? (text = functor(_), cloud) : text;
      };
      cloud.spiral = function(_) {
        return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;
      };
      cloud.fontSize = function(_) {
        return arguments.length ? (fontSize = functor(_), cloud) : fontSize;
      };
      cloud.padding = function(_) {
        return arguments.length ? (padding = functor(_), cloud) : padding;
      };
      cloud.random = function(_) {
        return arguments.length ? (random = _, cloud) : random;
      };
      cloud.on = function() {
        var value2 = event.on.apply(event, arguments);
        return value2 === event ? cloud : value2;
      };
      return cloud;
    };
    spirals = {
      archimedean: archimedeanSpiral,
      rectangular: rectangularSpiral
    };
    __extends$T = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    WordCloud = function(_super) {
      __extends$T(WordCloud2, _super);
      function WordCloud2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "wordcloud";
        _this.renderType = RenderTypes.SVG;
        _this.handleLegendOnHover = function(event) {
          var hoveredElement = event.detail.hoveredElement;
          var groupMapsTo = _this.getOptions().data.groupMapsTo;
          _this.parent.selectAll("text.word").transition("legend-hover-wordcloud").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-hover-wordcloud"
            });
          }).attr("opacity", function(d) {
            return d[groupMapsTo] !== hoveredElement.datum()["name"] ? 0.3 : 1;
          });
        };
        _this.handleLegendMouseOut = function(event) {
          _this.parent.selectAll("text.word").transition("legend-mouseout-wordcloud").call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "legend-mouseout-wordcloud"
            });
          }).attr("opacity", 1);
        };
        return _this;
      }
      WordCloud2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Legend.ITEM_HOVER, this.handleLegendOnHover);
        eventsFragment.addEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleLegendMouseOut);
      };
      WordCloud2.prototype.render = function(animate) {
        if (animate === void 0) {
          animate = true;
        }
        var self2 = this;
        var svg = this.getComponentContainer().attr("width", "100%").attr("height", "100%");
        var displayData = this.model.getDisplayData();
        var fontSizeScale = this.getFontSizeScale(displayData);
        var options2 = this.getOptions();
        var _a22 = options2.wordCloud, fontSizeMapsTo = _a22.fontSizeMapsTo, wordMapsTo = _a22.wordMapsTo;
        var groupMapsTo = options2.data.groupMapsTo;
        var _b = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _b.width, height = _b.height;
        if (width === 0 || height === 0) {
          return;
        }
        var layout = d3Cloud().size([width, height]).words(displayData.map(function(d) {
          var _a32;
          return _a32 = {}, _a32[groupMapsTo] = d[groupMapsTo], _a32.text = d[wordMapsTo], _a32.size = d[fontSizeMapsTo], _a32.value = d[fontSizeMapsTo], _a32;
        })).padding(5).rotate(0).fontSize(function(d) {
          return fontSizeScale(d.size);
        }).on("end", draw);
        layout.start();
        function draw(words2) {
          var textGroup = DOMUtils.appendOrSelect(svg, "g.words");
          textGroup.attr("transform", "translate(" + layout.size()[0] / 2 + ", " + layout.size()[1] / 2 + ")");
          var allText = textGroup.selectAll("text").data(words2, function(d) {
            return d[groupMapsTo] + "-" + d.text;
          });
          allText.exit().attr("opacity", 0).remove();
          var enteringText = allText.enter().append("text").attr("opacity", 0);
          enteringText.merge(allText).style("font-size", function(d) {
            return d.size + "px";
          }).text(function(d) {
            return d.text;
          }).attr("class", function(d) {
            return self2.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.FILL],
              dataGroupName: d[groupMapsTo],
              originalClassName: "word " + (d.size > 32 ? "light" : "")
            });
          }).style("fill", function(d) {
            return self2.model.getFillColor(d[groupMapsTo], d.text, d);
          }).attr("text-anchor", "middle").transition().call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "wordcloud-text-update-enter",
              animate
            });
          }).attr("transform", function(d) {
            return "translate(" + d.x + ", " + d.y + ")";
          }).attr("opacity", 1);
        }
        this.addEventListeners();
      };
      WordCloud2.prototype.getFontSizeScale = function(data) {
        var options2 = this.getOptions();
        var fontSizeMapsTo = options2.wordCloud.fontSizeMapsTo;
        var allOccurences = data.map(function(d) {
          return d[fontSizeMapsTo];
        }).filter(function(size) {
          return size;
        });
        var chartSize = DOMUtils.getHTMLElementSize(this.services.domUtils.getMainContainer());
        var sizeDataIsValid = allOccurences.length > 0;
        var domain = sizeDataIsValid ? extent(allOccurences) : [1, 1];
        return linear().domain(domain).range(sizeDataIsValid ? options2.wordCloud.fontSizeRange(chartSize, data) : [4, 4]);
      };
      WordCloud2.prototype.addEventListeners = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var self2 = this;
        var debouncedHighlight = Tools.debounce(function(word) {
          var allWords = self2.parent.selectAll("text.word").transition("wordcloud-word-mouse-highlight").call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "wordcloud-word-mouse-highlight"
            });
          });
          if (word === null) {
            allWords.attr("opacity", 1);
          } else {
            allWords.attr("opacity", function() {
              if (word === this) {
                return 1;
              }
              return 0.3;
            });
          }
        }, 6);
        this.parent.selectAll("text.word").on("mouseover", function(event, datum2) {
          var hoveredElement = this;
          debouncedHighlight(hoveredElement);
          self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEOVER, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: options2.tooltip.wordLabel,
                value: datum2.text
              },
              {
                label: options2.tooltip.valueLabel,
                value: datum2.value
              },
              {
                label: options2.tooltip.groupLabel,
                value: datum2[groupMapsTo],
                class: self2.model.getColorClassName({
                  classNameTypes: [ColorClassNameTypes.TOOLTIP],
                  dataGroupName: datum2[groupMapsTo]
                })
              }
            ]
          });
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEMOVE, {
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          debouncedHighlight(null);
          self2.services.events.dispatchEvent(Events$1.WordCloud.WORD_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      return WordCloud2;
    }(Component);
    pi = Math.PI;
    tau = 2 * pi;
    epsilon = 1e-6;
    tauEpsilon = tau - epsilon;
    Path.prototype = path.prototype = {
      constructor: Path,
      moveTo: function(x22, y2) {
        this._ += "M" + (this._x0 = this._x1 = +x22) + "," + (this._y0 = this._y1 = +y2);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x22, y2) {
        this._ += "L" + (this._x1 = +x22) + "," + (this._y1 = +y2);
      },
      quadraticCurveTo: function(x1, y1, x22, y2) {
        this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x22) + "," + (this._y1 = +y2);
      },
      bezierCurveTo: function(x1, y1, x22, y2, x3, y3) {
        this._ += "C" + +x1 + "," + +y1 + "," + +x22 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
      },
      arcTo: function(x1, y1, x22, y2, r2) {
        x1 = +x1, y1 = +y1, x22 = +x22, y2 = +y2, r2 = +r2;
        var x0 = this._x1, y0 = this._y1, x21 = x22 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        } else if (!(l01_2 > epsilon))
          ;
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } else {
          var x20 = x22 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
          if (Math.abs(t01 - 1) > epsilon) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }
          this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x22, y2, r2, a0, a1, ccw) {
        x22 = +x22, y2 = +y2, r2 = +r2, ccw = !!ccw;
        var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x22 + dx, y0 = y2 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
        if (r2 < 0)
          throw new Error("negative radius: " + r2);
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
          this._ += "L" + x0 + "," + y0;
        }
        if (!r2)
          return;
        if (da < 0)
          da = da % tau + tau;
        if (da > tauEpsilon) {
          this._ += "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (x22 - dx) + "," + (y2 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw2 + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        } else if (da > epsilon) {
          this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi) + "," + cw2 + "," + (this._x1 = x22 + r2 * Math.cos(a1)) + "," + (this._y1 = y2 + r2 * Math.sin(a1));
        }
      },
      rect: function(x22, y2, w, h2) {
        this._ += "M" + (this._x0 = this._x1 = +x22) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h2 + "h" + -w + "Z";
      },
      toString: function() {
        return this._;
      }
    };
    slice = Array.prototype.slice;
    __extends$S = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Alluvial = function(_super) {
      __extends$S(Alluvial2, _super);
      function Alluvial2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "alluvial";
        _this.renderType = RenderTypes.SVG;
        _this.gradient_id = "gradient-id-" + Math.floor(Math.random() * 99999999999);
        return _this;
      }
      Alluvial2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        svg.html("");
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        if (width < 1 || height < 1) {
          return;
        }
        var options2 = this.model.getOptions();
        var data = this.model.getDisplayData();
        var isGradientAllowed = Tools.getProperty(this.getOptions(), "color", "gradient", "enabled");
        var nodePadding = alluvial.minNodePadding;
        if (options2.alluvial.nodePadding > alluvial.minNodePadding) {
          nodePadding = options2.alluvial.nodePadding;
        }
        var sankey = Sankey().nodeId(function(d) {
          return d.name;
        }).nodeWidth(alluvial.nodeWidth).nodePadding(nodePadding).extent([
          [2, 30],
          [width - 2, height]
        ]);
        this.graph = sankey({
          nodes: options2.alluvial.nodes.map(function(d) {
            return Object.assign({}, d);
          }),
          links: data.map(function(d) {
            return Object.assign({}, d);
          })
        });
        this.graph.nodes = this.graph.nodes.filter(function(node2) {
          return node2.value !== 0;
        });
        var nodeCoordinates = {};
        this.graph.nodes.forEach(function(element) {
          var _a32;
          var point2 = element.x0;
          if (element.category) {
            nodeCoordinates[point2] = (_a32 = element) === null || _a32 === void 0 ? void 0 : _a32.category;
          }
        });
        var alluvialCategory = svg.append("g").classed("header-arrows", true).selectAll("g").data(Object.keys(nodeCoordinates)).join("g").attr("transform", function(d) {
          return "translate(" + d + ", 0)";
        });
        alluvialCategory.append("text").attr("id", function(d, i2) {
          return _this.services.domUtils.generateElementIDString("alluvial-category-" + i2);
        }).style("font-size", "14px").text(function(d) {
          if (nodeCoordinates[d]) {
            return nodeCoordinates[d];
          }
          return "";
        }).attr("y", 20).attr("x", function(d, i2) {
          var elementID = _this.services.domUtils.generateElementIDString("alluvial-category-" + i2);
          var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
          var x22 = 0;
          if (d + x22 >= width2) {
            x22 = -width2 + 4;
          }
          return x22;
        });
        var links = svg.append("g").attr("fill", "none").selectAll("g").data(this.graph.links);
        links.exit().remove();
        if (isGradientAllowed) {
          var scale_1 = Tools.getProperty(this.getOptions(), "color", "scale");
          if (scale_1) {
            links.enter().append("linearGradient").attr("id", function(d) {
              return _this.gradient_id + "-link-" + d.index;
            }).attr("gradientUnits", "userSpaceOnUse").call(function(gradient) {
              return gradient.append("stop").attr("offset", "0%").attr("stop-color", function(d) {
                return scale_1[d.source.name];
              });
            }).call(function(gradient) {
              return gradient.append("stop").attr("offset", "100%").attr("stop-color", function(d) {
                return scale_1[d.target.name];
              });
            });
          }
          links.exit().remove();
        }
        links.enter().append("path").classed("link", true).attr("d", sankeyLinkHorizontal()).attr("id", function(d) {
          return _this.services.domUtils.generateElementIDString("alluvial-line-" + d.index);
        }).attr("class", function(d) {
          if (options2.alluvial.monochrome) {
            return _this.model.getColorClassName({
              classNameTypes: [ColorClassNameTypes.STROKE],
              dataGroupName: 0,
              originalClassName: "link"
            });
          }
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.STROKE],
            dataGroupName: d.source.index,
            originalClassName: "link"
          });
        }).style("stroke", function(d) {
          if (isGradientAllowed) {
            return "url(#" + _this.gradient_id + "-link-" + d.index + ")";
          }
          return _this.model.getFillColor(d.source.name);
        }).attr("stroke-width", function(d) {
          return Math.max(1, d.width);
        }).style("stroke-opacity", alluvial.opacity.default).attr("aria-label", function(d) {
          return d.source.name + " \u2192 " + d.target.name + " (" + d.value + (options2.alluvial.units ? " " + options2.alluvial.units : "") + ")";
        });
        var node = svg.append("g").selectAll("g").data(this.graph.nodes).enter().append("g").attr("id", function(d) {
          return _this.services.domUtils.generateElementIDString("alluvial-node-" + d.index);
        }).classed("node-group", true).attr("transform", function(d) {
          return "translate(" + d.x0 + ", " + d.y0 + ")";
        });
        node.append("rect").classed("node", true).attr("height", function(d) {
          return d.y1 - d.y0;
        }).attr("width", function(d) {
          return d.x1 - d.x0;
        }).attr("fill", "black");
        var textNode = node.append("g").attr("id", function(d) {
          return _this.services.domUtils.generateElementIDString("alluvial-node-title-" + d.index);
        });
        textNode.append("text").attr("id", function(d) {
          return _this.services.domUtils.generateElementIDString("alluvial-node-text-" + d.index);
        }).attr("class", "node-text").style("font-size", "12px").attr("text-anchor", "start").attr("fill", "white").attr("x", 4).attr("dy", 13).text(function(d) {
          return d.name + " (" + d.value + ")";
        }).attr("aria-label", function(d) {
          return d.name + " (" + d.value + ")";
        });
        textNode.append("rect").classed("node-text-bg", true).attr("width", function(d, i2) {
          var elementID = _this.services.domUtils.generateElementIDString("alluvial-node-text-" + i2);
          var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
          return width2 + 8;
        }).attr("height", 18).attr("stroke-width", 2).lower();
        textNode.attr("transform", function(d, i2) {
          var elementID = _this.services.domUtils.generateElementIDString("alluvial-node-text-" + i2);
          var width2 = DOMUtils.getSVGElementSize(select("text#" + elementID), { useBBox: true }).width;
          var y2 = (d.y1 - d.y0) / 2 - 9;
          var x22 = d.x1 - d.x0;
          if (d.x1 >= width2) {
            x22 = x22 - (width2 + 16);
          } else {
            x22 += 4;
          }
          return "translate(" + x22 + ", " + y2 + ")";
        });
        this.addLineEventListener();
        this.addNodeEventListener();
      };
      Alluvial2.prototype.addLineEventListener = function() {
        var options2 = this.getOptions();
        var self2 = this;
        var debouncedLineHighlight = Tools.debounce(function(link2, event) {
          if (event === void 0) {
            event = "mouseover";
          }
          var allLinks = self2.parent.selectAll("path.link").transition().call(function(t2) {
            return self2.services.transitions.setupTransition({
              transition: t2,
              name: "alluvial-links-mouse-highlight"
            });
          });
          if (event === "mouseout") {
            select(link2).lower();
            allLinks.style("stroke-opacity", alluvial.opacity.default);
          } else {
            allLinks.style("stroke-opacity", function() {
              if (link2 === this) {
                select(this).raise();
                return alluvial.opacity.selected;
              }
              return alluvial.opacity.unfocus;
            });
          }
        }, 33);
        this.parent.selectAll("path.link").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          debouncedLineHighlight(this, "mouseover");
          hoveredElement.classed("link-hovered", true);
          var strokeColor = getComputedStyle(this).getPropertyValue("stroke");
          self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event,
            hoveredElement,
            items: [
              {
                label: datum2.target.name,
                value: datum2.value + (options2.alluvial.units ? " " + options2.alluvial.units : ""),
                color: strokeColor,
                labelIcon: self2.getRightArrowIcon()
              }
            ]
          });
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          debouncedLineHighlight(this, "mouseout");
          hoveredElement.classed("link-hovered", false);
          self2.services.events.dispatchEvent(Events$1.Alluvial.LINE_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            event,
            hoveredElement
          });
        });
      };
      Alluvial2.prototype.addNodeEventListener = function() {
        var _this = this;
        var self2 = this;
        var debouncedLineHighlight = Tools.debounce(function(links, event) {
          if (links === void 0) {
            links = [];
          }
          if (event === void 0) {
            event = "mouseover";
          }
          if (event === "mouseout" || links.length === 0) {
            self2.parent.selectAll("path.link").classed("link-hovered", false).data(_this.graph.links, function(d) {
              return d.index;
            }).order().style("stroke-opacity", alluvial.opacity.default);
            return;
          }
          var allLinks = self2.parent.selectAll("path.link").transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "alluvial-link-mouse-highlight"
            });
          });
          allLinks.style("stroke-opacity", function(d) {
            if (links.some(function(element) {
              return element === d.index;
            })) {
              select(this).classed("link-hovered", true).raise();
              return alluvial.opacity.selected;
            }
            return alluvial.opacity.unfocus;
          });
        }, 66);
        self2.parent.selectAll(".node-group").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          var paths = [];
          self2.traverse({ link: "sourceLinks", node: "target" }, datum2, paths);
          self2.traverse({ link: "targetLinks", node: "source" }, datum2, paths);
          if (paths.length) {
            var nodeMatrix = Tools.getTranformOffsets(hoveredElement.attr("transform"));
            hoveredElement.attr("transform", "translate(" + (nodeMatrix.x - 2) + ", " + nodeMatrix.y + ")");
            hoveredElement.classed("node-hovered", true).selectAll("rect.node").attr("width", 8);
            if (datum2.x0 - 2 === 0) {
              var elementID_1 = self2.services.domUtils.generateElementIDString("alluvial-node-title-" + datum2.index);
              var titleContainer = self2.parent.select("g#" + elementID_1);
              var titleMatrix = Tools.getTranformOffsets(titleContainer.attr("transform"));
              titleContainer.attr("transform", "translate(" + (titleMatrix.x + 4) + "," + titleMatrix.y + ")");
            }
            var elementID = self2.services.domUtils.generateElementIDString("alluvial-node-text-" + datum2.index);
            self2.parent.select("text#" + elementID).style("font-weight", "bold");
            debouncedLineHighlight(paths, "mouseover");
            self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEOVER, {
              event,
              element: hoveredElement,
              datum: datum2
            });
          }
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          var nodeMatrix = Tools.getTranformOffsets(hoveredElement.attr("transform"));
          hoveredElement.classed("node-hovered", false).attr("transform", "translate(" + (nodeMatrix.x + 2) + ", " + nodeMatrix.y + ")").select("rect.node").attr("width", alluvial.nodeWidth);
          if (datum2.x0 - 2 === 0) {
            var elementID_2 = self2.services.domUtils.generateElementIDString("alluvial-node-title-" + datum2.index);
            var titleContainer = self2.parent.select("g#" + elementID_2);
            var titleMatrix = Tools.getTranformOffsets(titleContainer.attr("transform"));
            titleContainer.attr("transform", "translate(" + (titleMatrix.x - 4) + "," + titleMatrix.y + ")");
          }
          var elementID = self2.services.domUtils.generateElementIDString("alluvial-node-text-" + datum2.index);
          self2.parent.select("text#" + elementID).style("font-weight", "normal");
          debouncedLineHighlight([], "mouseout");
          self2.services.events.dispatchEvent(Events$1.Alluvial.NODE_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            hoveredElement
          });
        });
      };
      Alluvial2.prototype.traverse = function(direction, node, visited) {
        var _this = this;
        if (visited === void 0) {
          visited = [];
        }
        var links = node[direction.link].map(function(element) {
          visited.push(element.index);
          return element[direction.node];
        });
        links.forEach(function(element) {
          return _this.traverse(direction, element, visited);
        });
      };
      Alluvial2.prototype.getRightArrowIcon = function() {
        return '\n		<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">\n			<polygon points="18 6 16.57 7.393 24.15 15 4 15 4 17 24.15 17 16.57 24.573 18 26 28 16 18 6"/>\n			<rect  data-name="&lt;Transparent Rectangle&gt;" style="fill: none;" width="32" height="32"/>\n		</svg>';
      };
      Alluvial2.prototype.destroy = function() {
        this.parent.selectAll("path.line,.node-group").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
      };
      return Alluvial2;
    }(Component);
    __extends$R = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Heatmap = function(_super) {
      __extends$R(Heatmap2, _super);
      function Heatmap2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "heatmap";
        _this.renderType = RenderTypes.SVG;
        _this.matrix = {};
        _this.xBandwidth = 0;
        _this.yBandwidth = 0;
        _this.translationUnits = {
          x: 0,
          y: 0
        };
        _this.handleAxisOnHover = function(event) {
          var detail = event.detail;
          var datum2 = detail.datum;
          var ranges = _this.model.getUniqueRanges();
          var domains = _this.model.getUniqueDomain();
          var domainLabel = _this.services.cartesianScales.getDomainLabel();
          var rangeLabel = _this.services.cartesianScales.getRangeLabel();
          var mainXScale = _this.services.cartesianScales.getMainXScale();
          var mainYScale = _this.services.cartesianScales.getMainYScale();
          var label = "", sum2 = 0, minimum = 0, maximum = 0;
          if (_this.matrix[datum2] !== void 0) {
            label = domainLabel;
            ranges.forEach(function(element) {
              var value2 = _this.matrix[datum2][element].value || 0;
              sum2 += value2;
              minimum = value2 < minimum ? value2 : minimum;
              maximum = value2 > maximum ? value2 : maximum;
            });
          } else {
            label = rangeLabel;
            domains.forEach(function(element) {
              var value2 = _this.matrix[element][datum2].value || 0;
              sum2 += value2;
              minimum = value2 < minimum ? value2 : minimum;
              maximum = value2 > maximum ? value2 : maximum;
            });
          }
          if (mainXScale(datum2) !== void 0) {
            _this.parent.select("g.multi-cell.column-highlight").classed("highlighter-hidden", false).attr("transform", "translate(" + mainXScale(datum2) + ", " + min$3(mainYScale.range()) + ")");
          } else if (mainYScale(datum2) !== void 0) {
            _this.parent.select("g.multi-cell.row-highlight").classed("highlighter-hidden", false).attr("transform", "translate(" + min$3(mainXScale.range()) + "," + mainYScale(datum2) + ")");
          }
          _this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            event: detail.event,
            hoveredElement: select(event.detail.element),
            items: [
              {
                label,
                value: datum2,
                bold: true
              },
              {
                label: "Min",
                value: minimum
              },
              {
                label: "Max",
                value: maximum
              },
              {
                label: "Average",
                value: sum2 / domains.length
              }
            ]
          });
        };
        _this.handleAxisMouseOut = function(event) {
          _this.parent.selectAll("g.multi-cell").classed("highlighter-hidden", true);
          _this.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
            event
          });
        };
        return _this;
      }
      Heatmap2.prototype.init = function() {
        var eventsFragment = this.services.events;
        eventsFragment.addEventListener(Events$1.Axis.LABEL_MOUSEOVER, this.handleAxisOnHover);
        eventsFragment.addEventListener(Events$1.Axis.LABEL_MOUSEOUT, this.handleAxisMouseOut);
        eventsFragment.addEventListener(Events$1.Axis.LABEL_FOCUS, this.handleAxisOnHover);
        eventsFragment.addEventListener(Events$1.Axis.LABEL_BLUR, this.handleAxisMouseOut);
      };
      Heatmap2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer({ withinChartClip: true });
        svg.lower();
        var cartesianScales = this.services.cartesianScales;
        this.matrix = this.model.getMatrix();
        svg.html("");
        if (Tools.getProperty(this.getOptions(), "data", "loading")) {
          return;
        }
        var mainXScale = cartesianScales.getMainXScale();
        var mainYScale = cartesianScales.getMainYScale();
        var domainIdentifier = cartesianScales.getDomainIdentifier();
        var rangeIdentifier = cartesianScales.getRangeIdentifier();
        var uniqueDomain = this.model.getUniqueDomain();
        var uniqueRange = this.model.getUniqueRanges();
        var matrixArray = this.model.getMatrixAsArray();
        var xRange = mainXScale.range();
        var yRange = mainYScale.range();
        this.xBandwidth = Math.abs((xRange[1] - xRange[0]) / uniqueDomain.length);
        this.yBandwidth = Math.abs((yRange[1] - yRange[0]) / uniqueRange.length);
        var patternID = this.services.domUtils.generateElementIDString("heatmap-pattern-stripes");
        svg.append("defs").append("pattern").attr("id", patternID).attr("width", 3).attr("height", 3).attr("patternUnits", "userSpaceOnUse").attr("patternTransform", "rotate(45)").append("rect").classed("pattern-fill", true).attr("width", 0.5).attr("height", 8);
        var rectangles = svg.selectAll().data(matrixArray).enter().append("g").attr("class", function(d) {
          return "heat-" + d.index;
        }).classed("cell", true).attr("transform", function(d) {
          return "translate(" + mainXScale(d[domainIdentifier]) + ", " + mainYScale(d[rangeIdentifier]) + ")";
        }).append("rect").attr("class", function(d) {
          return _this.model.getColorClassName({
            value: d.value,
            originalClassName: "heat-" + d.index
          });
        }).classed("heat", true).classed("null-state", function(d) {
          return d.index === -1 || d.value === null ? true : false;
        }).attr("width", this.xBandwidth).attr("height", this.yBandwidth).style("fill", function(d) {
          if (d.index === -1 || d.value === null) {
            return "url(#" + patternID + ")";
          }
          return _this.model.getFillColor(Number(d.value));
        }).attr("aria-label", function(d) {
          return d.value;
        });
        this.createOuterBox("g.cell-highlight", this.xBandwidth, this.yBandwidth);
        this.createOuterBox("g.multi-cell.column-highlight", this.xBandwidth, Math.abs(yRange[1] - yRange[0]));
        this.createOuterBox("g.multi-cell.row-highlight", Math.abs(xRange[1] - xRange[0]), this.yBandwidth);
        if (this.determineDividerStatus()) {
          rectangles.style("stroke-width", "1px");
          this.parent.select("g.cell-highlight").classed("cell-2", true);
        }
        this.addEventListener();
      };
      Heatmap2.prototype.createOuterBox = function(parentTag, xBandwidth, yBandwidth) {
        var highlight = DOMUtils.appendOrSelect(this.parent, parentTag).classed("shadows", true).classed("highlighter-hidden", true);
        DOMUtils.appendOrSelect(highlight, "line.top").attr("x1", -1).attr("x2", xBandwidth + 1);
        DOMUtils.appendOrSelect(highlight, "line.left").attr("x1", 0).attr("y1", -1).attr("x2", 0).attr("y2", yBandwidth + 1);
        DOMUtils.appendOrSelect(highlight, "line.down").attr("x1", -1).attr("x2", xBandwidth + 1).attr("y1", yBandwidth).attr("y2", yBandwidth);
        DOMUtils.appendOrSelect(highlight, "line.right").attr("x1", xBandwidth).attr("x2", xBandwidth).attr("y1", -1).attr("y2", yBandwidth + 1);
      };
      Heatmap2.prototype.determineDividerStatus = function() {
        var dividerStatus = Tools.getProperty(this.getOptions(), "heatmap", "divider", "state");
        if (dividerStatus !== DividerStatus.OFF) {
          if (dividerStatus === DividerStatus.AUTO && heatmap.minCellDividerDimension <= this.xBandwidth && heatmap.minCellDividerDimension <= this.yBandwidth || dividerStatus === DividerStatus.ON) {
            return true;
          }
        }
        return false;
      };
      Heatmap2.prototype.addEventListener = function() {
        var self2 = this;
        var cartesianScales = this.services.cartesianScales;
        var options2 = this.getOptions();
        var totalLabel = get$3(options2, "tooltip.totalLabel");
        var domainIdentifier = cartesianScales.getDomainIdentifier();
        var rangeIdentifier = cartesianScales.getRangeIdentifier();
        var domainLabel = cartesianScales.getDomainLabel();
        var rangeLabel = cartesianScales.getRangeLabel();
        this.parent.selectAll("g.cell").on("mouseover", function(event, datum2) {
          var cell = select(this);
          var hoveredElement = cell.select("rect.heat");
          var nullState = hoveredElement.classed("null-state");
          if (!nullState) {
            var transform = Tools.getTranformOffsets(cell.attr("transform"));
            select("g.cell-highlight").attr("transform", "translate(" + (transform.x + self2.translationUnits.x) + ", " + (transform.y + self2.translationUnits.y) + ")").classed("highlighter-hidden", false);
            self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEOVER, {
              event,
              element: hoveredElement,
              datum: datum2
            });
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              items: [
                {
                  label: domainLabel,
                  value: datum2[domainIdentifier]
                },
                {
                  label: rangeLabel,
                  value: datum2[rangeIdentifier]
                },
                {
                  label: totalLabel || "Total",
                  value: datum2["value"],
                  color: hoveredElement.style("fill")
                }
              ]
            });
          }
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var cell = select(this);
          var hoveredElement = cell.select("rect.heat");
          var nullState = hoveredElement.classed("null-state");
          select("g.cell-highlight").classed("highlighter-hidden", true);
          if (!nullState) {
            self2.services.events.dispatchEvent(Events$1.Heatmap.HEATMAP_MOUSEOUT, {
              event,
              element: hoveredElement,
              datum: datum2
            });
            self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
              event,
              hoveredElement
            });
          }
        });
      };
      Heatmap2.prototype.destroy = function() {
        this.parent.selectAll("rect.heat").on("mouseover", null).on("mousemove", null).on("click", null).on("mouseout", null);
        var eventsFragment = this.services.events;
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_HOVER, this.handleAxisOnHover);
        eventsFragment.removeEventListener(Events$1.Legend.ITEM_MOUSEOUT, this.handleAxisMouseOut);
      };
      return Heatmap2;
    }(Component);
    __extends$Q = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Spacer = function(_super) {
      __extends$Q(Spacer2, _super);
      function Spacer2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "spacer";
        return _this;
      }
      Spacer2.prototype.render = function() {
        this.getComponentContainer().style("width", (this.configs.size || spacers.default.size) + "px").style("height", (this.configs.size || spacers.default.size) + "px").attr("opacity", 0);
      };
      return Spacer2;
    }(Component);
    __extends$P = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    LayoutComponent = function(_super) {
      __extends$P(LayoutComponent2, _super);
      function LayoutComponent2(model, services, children2, configs) {
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "layout";
        _this.configs = configs;
        _this.children = children2;
        _this._instanceID = LayoutComponent2.instanceID++;
        _this.init();
        return _this;
      }
      LayoutComponent2.prototype.init = function() {
        this.children.forEach(function(child) {
          child.components.forEach(function(component) {
            component.init();
          });
        });
      };
      LayoutComponent2.prototype.getPreferedAndFixedSizeSum = function() {
        var svg = this.parent;
        var sum2 = 0;
        svg.selectAll("div.layout-child-" + this._instanceID).filter(function(d) {
          var growth = Tools.getProperty(d, "growth");
          return growth === LayoutGrowth.PREFERRED || growth === LayoutGrowth.FIXED;
        }).each(function(d) {
          sum2 += d.size;
        });
        return sum2;
      };
      LayoutComponent2.prototype.getNumOfStretchChildren = function() {
        var svg = this.parent;
        return svg.selectAll("div.layout-child-" + this._instanceID).filter(function(d) {
          return Tools.getProperty(d, "growth") === LayoutGrowth.STRETCH;
        }).size();
      };
      LayoutComponent2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var parent = this.parent;
        var _a22 = DOMUtils.getHTMLElementSize(parent.node()), width = _a22.width, height = _a22.height;
        var horizontal = this.configs.direction === LayoutDirection.ROW || this.configs.direction === LayoutDirection.ROW_REVERSE;
        var chartprefix = Tools.getProperty(this.model.getOptions(), "style", "prefix");
        var updatedBoxes = parent.classed(settings$1.prefix + "--" + chartprefix + "--layout-row", this.configs.direction === LayoutDirection.ROW).classed(settings$1.prefix + "--" + chartprefix + "--layout-row-reverse", this.configs.direction === LayoutDirection.ROW_REVERSE).classed(settings$1.prefix + "--" + chartprefix + "--layout-column", this.configs.direction === LayoutDirection.COLUMN).classed(settings$1.prefix + "--" + chartprefix + "--layout-column-reverse", this.configs.direction === LayoutDirection.COLUMN_REVERSE).classed(settings$1.prefix + "--" + chartprefix + "--layout-alignitems-center", this.configs.alignItems === LayoutAlignItems.CENTER).selectAll("div.layout-child-" + this._instanceID).data(this.children, function(d) {
          return d.id;
        });
        var enteringBoxes = updatedBoxes.enter().append("div");
        enteringBoxes.merge(parent.selectAll("div.layout-child-" + this._instanceID)).attr("class", function(d) {
          return "layout-child layout-child-" + _this._instanceID + " " + d.id;
        }).each(function(d) {
          var _this2 = this;
          d.components.forEach(function(itemComponent) {
            var selection2 = select(_this2);
            var renderType = Tools.getProperty(d, "renderType");
            var isRenderingSVG = renderType === RenderTypes.SVG;
            itemComponent.setParent(isRenderingSVG ? DOMUtils.appendOrSelect(selection2, "svg.layout-svg-wrapper").attr("width", "100%").attr("height", "100%") : selection2);
            var growth = Tools.getProperty(d, "growth");
            if (growth === LayoutGrowth.PREFERRED || growth === LayoutGrowth.FIXED) {
              itemComponent.render(animate);
            }
          });
        });
        parent.selectAll("div.layout-child-" + this._instanceID).style("height", null).style("width", null).each(function(d) {
          var growth = Tools.getProperty(d, "growth");
          var renderType = Tools.getProperty(d, "renderType");
          var matchingElementDimensions = renderType === RenderTypes.SVG ? DOMUtils.getSVGElementSize(select(this).select("svg.layout-svg-wrapper"), {
            useBBox: true
          }) : DOMUtils.getHTMLElementSize(this);
          if (growth === LayoutGrowth.PREFERRED) {
            var matchingElementWidth = horizontal ? matchingElementDimensions.width : matchingElementDimensions.height;
            var elementWidth = horizontal ? width : height;
            d.size = matchingElementWidth / elementWidth * 100;
          }
        });
        updatedBoxes.exit().remove();
        this.children.filter(function(child) {
          var growth = Tools.getProperty(child, "growth");
          return growth === LayoutGrowth.STRETCH;
        }).forEach(function(child, i2) {
          child.size = (100 - +_this.getPreferedAndFixedSizeSum()) / +_this.getNumOfStretchChildren();
        });
        var allUpdatedBoxes = parent.selectAll("div.layout-child-" + this._instanceID).data(this.children, function(d) {
          return d.id;
        });
        if (horizontal) {
          allUpdatedBoxes.style("width", function(d) {
            return d.size / 100 * width + "px";
          }).style("height", "100%");
        } else {
          allUpdatedBoxes.style("height", function(d) {
            return d.size / 100 * height + "px";
          }).style("width", "100%");
        }
        allUpdatedBoxes.each(function(d, i2) {
          d.components.forEach(function(itemComponent) {
            var growth = Tools.getProperty(d, "growth");
            if (growth === LayoutGrowth.STRETCH) {
              itemComponent.render(animate);
            }
          });
        });
      };
      LayoutComponent2.prototype.setModel = function(newObj) {
        _super.prototype.setModel.call(this, newObj);
        this.children.forEach(function(child) {
          child.components.forEach(function(component) {
            return component.setModel(newObj);
          });
        });
      };
      LayoutComponent2.prototype.setServices = function(newObj) {
        _super.prototype.setServices.call(this, newObj);
        this.children.forEach(function(child) {
          child.components.forEach(function(component) {
            return component.setServices(newObj);
          });
        });
      };
      LayoutComponent2.prototype.destroy = function() {
        this.children.forEach(function(child) {
          child.components.forEach(function(component) {
            return component.destroy();
          });
        });
      };
      LayoutComponent2.instanceID = Math.floor(Math.random() * 99999999999);
      return LayoutComponent2;
    }(Component);
    __extends$O = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Axis = function(_super) {
      __extends$O(Axis2, _super);
      function Axis2(model, services, configs) {
        var _a22;
        var _this = _super.call(this, model, services, configs) || this;
        _this.type = "axes";
        _this.renderType = RenderTypes.SVG;
        _this.truncation = (_a22 = {}, _a22[AxisPositions.LEFT] = false, _a22[AxisPositions.RIGHT] = false, _a22[AxisPositions.TOP] = false, _a22[AxisPositions.BOTTOM] = false, _a22);
        if (configs) {
          _this.configs = configs;
        }
        _this.margins = _this.configs.margins;
        return _this;
      }
      Axis2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var axisPosition = this.configs.position;
        var options2 = this.getOptions();
        var isAxisVisible = Tools.getProperty(options2, "axes", axisPosition, "visible");
        var svg = this.getComponentContainer();
        var _a22 = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        var startPosition, endPosition;
        if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
          startPosition = this.configs.axes[AxisPositions.LEFT] ? this.margins.left : 0;
          endPosition = this.configs.axes[AxisPositions.RIGHT] ? width - this.margins.right : width;
        } else {
          startPosition = height - this.margins.bottom;
          endPosition = this.margins.top;
        }
        var scale = this.services.cartesianScales.getScaleByPosition(axisPosition);
        if (this.scaleType === ScaleTypes.LABELS || this.scaleType === ScaleTypes.LABELS_RATIO) {
          scale.rangeRound([startPosition, endPosition]);
        } else {
          scale.range([startPosition, endPosition]);
        }
        var axisFunction;
        switch (axisPosition) {
          case AxisPositions.LEFT:
            axisFunction = axisLeft;
            break;
          case AxisPositions.BOTTOM:
            axisFunction = axisBottom;
            break;
          case AxisPositions.RIGHT:
            axisFunction = axisRight;
            break;
          case AxisPositions.TOP:
            axisFunction = axisTop;
            break;
        }
        container.attr("aria-label", axisPosition + " axis");
        var axisRefExists = !container.select("g.ticks").empty();
        var axisRef = DOMUtils.appendOrSelect(container, "g.ticks");
        if (!axisRefExists) {
          axisRef.attr("role", Roles.GRAPHICS_OBJECT + " " + Roles.GROUP);
          axisRef.attr("aria-label", axisPosition + " ticks");
        }
        var invisibleAxisRef = DOMUtils.appendOrSelect(container, "g.ticks.invisible").style("opacity", "0").style("pointer-events", "none").attr("aria-hidden", true).attr("aria-label", "invisible " + axisPosition + " ticks");
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        var isTimeScaleType = this.scaleType === ScaleTypes.TIME || axisOptions.scaleType === ScaleTypes.TIME;
        var isVerticalAxis = axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT;
        var zoomDomain = this.model.get("zoomDomain");
        if (zoomDomain && isTimeScaleType && !isVerticalAxis) {
          scale.domain(zoomDomain);
        }
        if (!isAxisVisible) {
          axisRef.attr("aria-hidden", true);
          return;
        }
        var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
        var isDataLoading = Tools.getProperty(options2, "data", "loading");
        var numberOfTicksProvided = Tools.getProperty(axisOptions, "ticks", "number");
        var userProvidedTickValues = Tools.getProperty(axisOptions, "ticks", "values");
        var truncationType = Tools.getProperty(axisOptions, "truncation", "type");
        var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
        var truncationNumCharacter = Tools.getProperty(axisOptions, "truncation", "numCharacter");
        var isNumberOfTicksProvided = numberOfTicksProvided !== null;
        var timeScaleOptions = Tools.getProperty(options2, "timeScale");
        var fakeTick = DOMUtils.appendOrSelect(invisibleAxisRef, "g.tick");
        var fakeTickText = DOMUtils.appendOrSelect(fakeTick, "text").text("0");
        var tickHeight = DOMUtils.getSVGElementSize(fakeTickText.node(), {
          useBBox: true
        }).height;
        fakeTick.remove();
        var scaleType = this.scaleType || axisOptions.scaleType || ScaleTypes.LINEAR;
        var axis2 = axisFunction(scale).tickSizeOuter(0);
        if (scale.ticks) {
          var numberOfTicks = void 0;
          if (isNumberOfTicksProvided) {
            numberOfTicks = numberOfTicksProvided;
          } else {
            numberOfTicks = axis$1.ticks.number;
            if (isVerticalAxis) {
              numberOfTicks = this.getNumberOfFittingTicks(height, tickHeight, axis$1.ticks.verticalSpaceRatio);
            }
          }
          if (scale.ticks().length === 1 && scale.ticks()[0] === 0) {
            numberOfTicks = 0;
          }
          axis2.ticks(numberOfTicks);
          if (isTimeScaleType) {
            if (!scale.ticks(numberOfTicks).length) {
              axis2.tickValues([]);
            } else {
              var addSpaceOnEdges = Tools.getProperty(options2, "timeScale", "addSpaceOnEdges");
              var customDomain = Tools.getProperty(options2, "axes", axisPosition, "domain");
              var tickValues = void 0;
              var tempScale = scale.copy();
              if (addSpaceOnEdges && !customDomain) {
                tempScale.nice(numberOfTicks);
              }
              tickValues = tempScale.ticks(numberOfTicks);
              if (addSpaceOnEdges && tickValues.length > 2 && !customDomain) {
                tickValues.splice(tickValues.length - 1, 1);
                tickValues.splice(0, 1);
              }
              axis2.tickValues(tickValues);
            }
          }
        }
        var formatter;
        var userProvidedFormatter = Tools.getProperty(axisOptions, "ticks", "formatter");
        if (isTimeScaleType) {
          var timeInterval_1 = computeTimeIntervalName(axis2.tickValues());
          if (userProvidedFormatter === null) {
            formatter = function(t2, i2) {
              return formatTick(t2, i2, axis2.tickValues(), timeInterval_1, timeScaleOptions);
            };
          } else {
            formatter = function(t2, i2) {
              var defaultFormattedValue = formatTick(t2, i2, axis2.tickValues(), timeInterval_1, timeScaleOptions);
              return userProvidedFormatter(t2, i2, defaultFormattedValue);
            };
          }
        } else {
          if (userProvidedFormatter === null) {
            if (scaleType === ScaleTypes.LINEAR) {
              formatter = function(t2) {
                return t2.toLocaleString();
              };
            }
          } else {
            formatter = userProvidedFormatter;
          }
        }
        axis2.tickFormat(formatter);
        var _b = this.services.cartesianScales.getScaleByPosition(axisPosition).domain(), lowerBound = _b[0], upperBound = _b[1];
        var validTicks;
        if (userProvidedTickValues) {
          if (isTimeScaleType) {
            userProvidedTickValues.forEach(function(userProvidedTickValue, i2) {
              if (userProvidedTickValue.getTime === void 0) {
                userProvidedTickValues[i2] = new Date(userProvidedTickValue);
              }
            });
            validTicks = userProvidedTickValues.filter(function(tick) {
              var tickTimestamp = tick.getTime();
              return tickTimestamp >= new Date(lowerBound).getTime() && tickTimestamp <= new Date(upperBound).getTime();
            });
          } else if (axisScaleType === ScaleTypes.LABELS) {
            var discreteDomain_1 = this.services.cartesianScales.getScaleByPosition(axisPosition).domain();
            validTicks = userProvidedTickValues.filter(function(tick) {
              return discreteDomain_1.includes(tick);
            });
          } else {
            validTicks = userProvidedTickValues.filter(function(tick) {
              return tick >= lowerBound && tick <= upperBound;
            });
          }
          axis2.tickValues(validTicks);
        }
        switch (axisPosition) {
          case AxisPositions.LEFT:
            axisRef.attr("transform", "translate(" + this.margins.left + ", 0)");
            break;
          case AxisPositions.BOTTOM:
            axisRef.attr("transform", "translate(0, " + (height - this.margins.bottom) + ")");
            break;
          case AxisPositions.RIGHT:
            axisRef.attr("transform", "translate(" + (width - this.margins.right) + ", 0)");
            break;
          case AxisPositions.TOP:
            axisRef.attr("transform", "translate(0, " + this.margins.top + ")");
            break;
        }
        var isDataEmpty = this.model.isDataEmpty();
        if (axisOptions.title) {
          var axisTitleRef = DOMUtils.appendOrSelect(container, "text.axis-title").html(isDataEmpty || isDataLoading ? "" : axisOptions.title);
          var titleOrientation = Tools.getProperty(axisOptions, "titleOrientation");
          switch (axisPosition) {
            case AxisPositions.LEFT:
              if (titleOrientation === AxisTitleOrientations.RIGHT) {
                axisTitleRef.attr("transform", "rotate(90)").attr("y", 0).attr("x", scale.range()[0] / 2).attr("dy", "-0.5em").style("text-anchor", "middle");
              } else {
                axisTitleRef.attr("transform", "rotate(-90)").attr("y", 0).attr("x", -(scale.range()[0] / 2)).attr("dy", "0.75em").style("text-anchor", "middle");
              }
              break;
            case AxisPositions.BOTTOM:
              axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + (height + 4) + ")").style("text-anchor", "middle");
              break;
            case AxisPositions.RIGHT:
              if (titleOrientation === AxisTitleOrientations.LEFT) {
                axisTitleRef.attr("transform", "rotate(-90)").attr("y", width).attr("x", -(scale.range()[0] / 2)).style("text-anchor", "middle");
              } else {
                axisTitleRef.attr("transform", "rotate(90)").attr("y", -width).attr("x", scale.range()[0] / 2).attr("dy", "0.75em").style("text-anchor", "middle");
              }
              break;
            case AxisPositions.TOP:
              var titleHeight = DOMUtils.getSVGElementSize(axisTitleRef, {
                useBBox: true
              }).height;
              axisTitleRef.attr("transform", "translate(" + (this.margins.left / 2 + scale.range()[1] / 2) + ", " + titleHeight / 2 + ")").style("text-anchor", "middle");
              break;
          }
        }
        if (isTimeScaleType) {
          var timeInterval_2 = computeTimeIntervalName(axis2.tickValues());
          var showDayName_1 = timeScaleOptions.showDayName;
          var axisRefSelection = axisRef;
          if (animate) {
            axisRef = axisRef.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "axis-update",
                animate
              });
            });
          }
          axisRef = axisRef.call(axis2);
          var ticks2 = axisRefSelection.selectAll(".tick").data(axis2.tickValues(), scale).order().select("text");
          ticks2.style("font-weight", function(tick, i2) {
            return isTickPrimary(tick, i2, axis2.tickValues(), timeInterval_2, showDayName_1) ? "bold" : "normal";
          });
        } else {
          if (!animate || !axisRefExists) {
            axisRef = axisRef.call(axis2);
          } else {
            axisRef = axisRef.transition().call(function(t2) {
              return _this.services.transitions.setupTransition({
                transition: t2,
                name: "axis-update",
                animate
              });
            }).call(axis2);
          }
        }
        invisibleAxisRef.call(axis2);
        if (axisPosition === AxisPositions.BOTTOM || axisPosition === AxisPositions.TOP) {
          var shouldRotateTicks_1 = false;
          var tickRotation = Tools.getProperty(axisOptions, "ticks", "rotation");
          if (tickRotation === TickRotations.ALWAYS) {
            shouldRotateTicks_1 = true;
          } else if (tickRotation === TickRotations.NEVER) {
            shouldRotateTicks_1 = false;
          } else if (!tickRotation || tickRotation === TickRotations.AUTO) {
            if (scale.step) {
              var textNodes = invisibleAxisRef.selectAll("g.tick text").nodes();
              shouldRotateTicks_1 = textNodes.some(function(textNode) {
                return DOMUtils.getSVGElementSize(textNode, {
                  useBBox: true
                }).width >= scale.step();
              });
            } else {
              shouldRotateTicks_1 = false;
              var mockTextPiece = invisibleAxisRef.append("text").text("A");
              var averageLetterWidth_1 = DOMUtils.getSVGElementSize(mockTextPiece.node(), {
                useBBox: true
              }).width;
              var lastStartPosition_1;
              invisibleAxisRef.selectAll("g.tick").each(function() {
                var selection2 = select(this);
                var xTransformation = parseFloat(Tools.getProperty(Tools.getTranslationValues(this), "tx"));
                if (xTransformation !== null && lastStartPosition_1 + selection2.text().length * averageLetterWidth_1 * 0.8 >= xTransformation) {
                  shouldRotateTicks_1 = true;
                }
                lastStartPosition_1 = xTransformation;
              });
            }
          }
          if (shouldRotateTicks_1) {
            if (!isNumberOfTicksProvided) {
              axis2.ticks(this.getNumberOfFittingTicks(width, tickHeight, axis$1.ticks.horizontalSpaceRatio));
              invisibleAxisRef.call(axis2);
              axisRef.call(axis2);
            }
            container.selectAll("g.ticks g.tick text").attr("transform", "rotate(-45)").style("text-anchor", axisPosition === AxisPositions.TOP ? "start" : "end");
          } else {
            container.selectAll("g.ticks g.tick text").attr("transform", null).style("text-anchor", null);
          }
        }
        if (isDataLoading) {
          container.attr("opacity", 0);
        } else {
          container.attr("opacity", 1);
        }
        axisRef.selectAll("g.tick").attr("aria-label", function(d) {
          return d;
        });
        invisibleAxisRef.selectAll("g.tick").attr("aria-label", function(d) {
          return d;
        });
        if (truncationType !== TruncationTypes.NONE && axisScaleType === ScaleTypes.LABELS && !userProvidedTickValues) {
          var axisTickLabels = this.services.cartesianScales.getScaleDomain(axisPosition);
          if (axisTickLabels.length > 0) {
            var tick_html = svg.select("g.axis." + axisPosition + " g.ticks g.tick").html();
            container.selectAll("g.ticks g.tick").html(tick_html);
            var self_1 = this;
            container.selectAll("g.tick text").data(axisTickLabels).text(function(d) {
              if (d.length > truncationThreshold) {
                self_1.truncation[axisPosition] = true;
                return Tools.truncateLabel(d, truncationType, truncationNumCharacter);
              } else {
                return d;
              }
            });
            this.getInvisibleAxisRef().selectAll("g.tick text").data(axisTickLabels).text(function(d) {
              if (d.length > truncationThreshold) {
                return Tools.truncateLabel(d, truncationType, truncationNumCharacter);
              } else {
                return d;
              }
            });
            container.selectAll("g.ticks").html(this.getInvisibleAxisRef().html());
            container.selectAll("g.tick text").data(axisTickLabels);
          }
        }
        this.addEventListeners();
      };
      Axis2.prototype.addEventListeners = function() {
        var svg = this.getComponentContainer();
        var axisPosition = this.configs.position;
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        var options2 = this.getOptions();
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
        var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
        var self2 = this;
        container.selectAll("g.tick text").on("mouseover", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOVER, {
            event,
            element: select(this),
            datum: datum2
          });
          if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement: select(this),
              content: datum2
            });
          }
        }).on("mousemove", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEMOVE, {
            event,
            element: select(this),
            datum: datum2
          });
          if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
              event
            });
          }
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOUT, {
            event,
            element: select(this),
            datum: datum2
          });
          if (axisScaleType === ScaleTypes.LABELS) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
          }
        });
      };
      Axis2.prototype.getInvisibleAxisRef = function() {
        var axisPosition = this.configs.position;
        return this.getComponentContainer().select("g.axis." + axisPosition + " g.ticks.invisible");
      };
      Axis2.prototype.getTitleRef = function() {
        var axisPosition = this.configs.position;
        return this.getComponentContainer().select("g.axis." + axisPosition + " text.axis-title");
      };
      Axis2.prototype.getNumberOfFittingTicks = function(size, tickSize, spaceRatio) {
        var numberOfTicksFit = Math.floor(size / (tickSize * spaceRatio));
        return Tools.clamp(numberOfTicksFit, 2, axis$1.ticks.number);
      };
      Axis2.prototype.destroy = function() {
        var svg = this.getComponentContainer();
        var axisPosition = this.configs.position;
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        container.selectAll("g.tick text").on("mouseover", null).on("mousemove", null).on("mouseout", null);
      };
      return Axis2;
    }(Component);
    __extends$N = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign$2 = globalThis && globalThis.__assign || function() {
      __assign$2 = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign$2.apply(this, arguments);
    };
    HoverAxis = function(_super) {
      __extends$N(HoverAxis2, _super);
      function HoverAxis2(model, services, configs) {
        return _super.call(this, model, services, configs) || this;
      }
      HoverAxis2.prototype.render = function(animate) {
        if (animate === void 0) {
          animate = true;
        }
        _super.prototype.render.call(this, animate);
        _super.prototype.destroy.call(this);
        var axisPosition = this.configs.position;
        var svg = this.getComponentContainer();
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        var self2 = this;
        container.selectAll("g.tick").each(function(_, index2) {
          var g = select(this);
          g.classed("tick-hover", true).attr("tabindex", index2 === 0 ? 0 : -1);
          var textNode = g.select("text");
          var _a22 = DOMUtils.getSVGElementSize(textNode, {
            useBBox: true
          }), width = _a22.width, height = _a22.height;
          var rectangle = DOMUtils.appendOrSelect(g, "rect.axis-holder");
          var x22 = 0, y2 = 0;
          switch (axisPosition) {
            case AxisPositions.LEFT:
              x22 = -width + Number(textNode.attr("x"));
              y2 = -(height / 2);
              break;
            case AxisPositions.RIGHT:
              x22 = Math.abs(Number(textNode.attr("x")));
              y2 = -(height / 2);
              break;
            case AxisPositions.TOP:
              x22 = -(width / 2);
              y2 = -height + Number(textNode.attr("y")) / 2;
              if (self2.truncation[axisPosition]) {
                x22 = 0;
                rectangle.attr("transform", "rotate(-45)");
              }
              break;
            case AxisPositions.BOTTOM:
              x22 = -(width / 2);
              y2 = height / 2 - 2;
              if (self2.truncation[axisPosition]) {
                x22 = -width;
                rectangle.attr("transform", "rotate(-45)");
              }
              break;
          }
          rectangle.attr("x", x22 - axis$1.hover.rectanglePadding).attr("y", y2).attr("width", width + axis$1.hover.rectanglePadding * 2).attr("height", height).lower();
          g.on("keydown", function(event) {
            if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
              if (event.key && event.key === "ArrowUp") {
                self2.goNext(this, event);
              } else if (event.key && event.key === "ArrowDown") {
                self2.goPrevious(this, event);
              }
            } else {
              if (event.key && event.key === "ArrowLeft") {
                self2.goPrevious(this, event);
              } else if (event.key && event.key === "ArrowRight") {
                self2.goNext(this, event);
              }
            }
          });
        });
        this.addEventListeners();
      };
      HoverAxis2.prototype.addEventListeners = function() {
        var svg = this.getComponentContainer();
        var axisPosition = this.configs.position;
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        var options2 = this.getOptions();
        var axisOptions = Tools.getProperty(options2, "axes", axisPosition);
        var axisScaleType = Tools.getProperty(axisOptions, "scaleType");
        var truncationThreshold = Tools.getProperty(axisOptions, "truncation", "threshold");
        var self2 = this;
        container.selectAll("g.tick.tick-hover").on("mouseover", function(event) {
          var hoveredElement = select(this).select("text");
          var datum2 = hoveredElement.datum();
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          if (axisScaleType === ScaleTypes.LABELS && datum2.length > truncationThreshold) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              element: hoveredElement,
              datum: datum2
            });
          }
        }).on("mousemove", function(event) {
          var hoveredElement = select(this).select("text");
          var datum2 = hoveredElement.datum();
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            event
          });
        }).on("click", function(event) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_CLICK, {
            event,
            element: select(this).select("text"),
            datum: select(this).select("text").datum()
          });
        }).on("mouseout", function(event) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_MOUSEOUT, {
            event,
            element: select(this).select("text"),
            datum: select(this).select("text").datum()
          });
          if (axisScaleType === ScaleTypes.LABELS) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
          }
        }).on("focus", function(event) {
          var coordinates = { clientX: 0, clientY: 0 };
          if (event.target) {
            event.target.focus();
            var boundingRect = event.target.getBoundingClientRect();
            coordinates.clientX = boundingRect.x;
            coordinates.clientY = boundingRect.y;
          }
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_FOCUS, {
            event: __assign$2(__assign$2({}, event), coordinates),
            element: select(this),
            datum: select(this).select("text").datum()
          });
        }).on("blur", function(event) {
          self2.services.events.dispatchEvent(Events$1.Axis.LABEL_BLUR, {
            event,
            element: select(this),
            datum: select(this).select("text").datum()
          });
        });
      };
      HoverAxis2.prototype.goNext = function(element, event) {
        if (element.nextElementSibling && element.nextElementSibling.tagName !== "path") {
          element.nextElementSibling.dispatchEvent(new Event("focus"));
        }
        event.preventDefault();
      };
      HoverAxis2.prototype.goPrevious = function(element, event) {
        if (element.previousElementSibling && element.previousElementSibling.tagName !== "path") {
          element.previousElementSibling.dispatchEvent(new Event("focus"));
        }
        event.preventDefault();
      };
      HoverAxis2.prototype.destroy = function() {
        var svg = this.getComponentContainer();
        var axisPosition = this.configs.position;
        var container = DOMUtils.appendOrSelect(svg, "g.axis." + axisPosition);
        container.selectAll("g.tick.tick-hover").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("focus", null).on("blur", null);
      };
      return HoverAxis2;
    }(Axis);
    __extends$M = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    TwoDimensionalAxes = function(_super) {
      __extends$M(TwoDimensionalAxes2, _super);
      function TwoDimensionalAxes2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "2D-axes";
        _this.renderType = RenderTypes.SVG;
        _this.children = {};
        _this.thresholds = [];
        _this.margins = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
        return _this;
      }
      TwoDimensionalAxes2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = false;
        }
        var axes2 = {};
        var axisPositions = Object.keys(AxisPositions);
        var axesOptions = Tools.getProperty(this.getOptions(), "axes");
        axisPositions.forEach(function(axisPosition) {
          var axisOptions = axesOptions[AxisPositions[axisPosition]];
          if (axisOptions) {
            axes2[AxisPositions[axisPosition]] = true;
          }
        });
        this.configs.axes = axes2;
        axisPositions.forEach(function(axisPositionKey) {
          var axisPosition = AxisPositions[axisPositionKey];
          if (_this.configs.axes[axisPosition] && !_this.children[axisPosition]) {
            var configs = {
              position: axisPosition,
              axes: _this.configs.axes,
              margins: _this.margins
            };
            var axisComponent = _this.model.axisFlavor === AxisFlavor.DEFAULT ? new Axis(_this.model, _this.services, configs) : new HoverAxis(_this.model, _this.services, configs);
            axisComponent.setModel(_this.model);
            axisComponent.setServices(_this.services);
            axisComponent.setParent(_this.parent);
            _this.children[axisPosition] = axisComponent;
          }
        });
        Object.keys(this.children).forEach(function(childKey) {
          var child = _this.children[childKey];
          child.render(animate);
        });
        var margins = {};
        Object.keys(this.children).forEach(function(childKey) {
          var child = _this.children[childKey];
          var axisPosition = child.configs.position;
          var invisibleAxisRef = child.getInvisibleAxisRef();
          var _a22 = DOMUtils.getSVGElementSize(invisibleAxisRef, { useBBox: true }), width = _a22.width, height = _a22.height;
          var offset;
          if (child.getTitleRef().empty()) {
            offset = 0;
          } else {
            offset = DOMUtils.getSVGElementSize(child.getTitleRef(), {
              useBBox: true
            }).height;
            if (axisPosition === AxisPositions.LEFT || axisPosition === AxisPositions.RIGHT) {
              offset += 5;
            }
          }
          switch (axisPosition) {
            case AxisPositions.TOP:
              margins.top = height + offset;
              break;
            case AxisPositions.BOTTOM:
              margins.bottom = height + offset;
              break;
            case AxisPositions.LEFT:
              margins.left = width + offset;
              break;
            case AxisPositions.RIGHT:
              margins.right = width + offset;
              break;
          }
        });
        this.services.events.dispatchEvent(Events$1.Axis.RENDER_COMPLETE);
        var isNotEqual = Object.keys(margins).some(function(marginKey) {
          return _this.margins[marginKey] !== margins[marginKey];
        });
        if (isNotEqual) {
          this.margins = Object.assign(this.margins, margins);
          this.model.set({ axesMargins: this.margins }, { skipUpdate: true });
          this.services.events.dispatchEvent(Events$1.ZoomBar.UPDATE);
          Object.keys(this.children).forEach(function(childKey) {
            var child = _this.children[childKey];
            child.margins = _this.margins;
          });
          this.render(true);
        }
      };
      return TwoDimensionalAxes2;
    }(Component);
    noop3 = { value: () => {
    } };
    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._, T = parseTypenames(typename + "", _), t2, i2 = -1, n = T.length;
        if (arguments.length < 2) {
          while (++i2 < n)
            if ((t2 = (typename = T[i2]).type) && (t2 = get$1(_[t2], typename.name)))
              return t2;
          return;
        }
        if (callback != null && typeof callback !== "function")
          throw new Error("invalid callback: " + callback);
        while (++i2 < n) {
          if (t2 = (typename = T[i2]).type)
            _[t2] = set$1(_[t2], typename.name, callback);
          else if (callback == null)
            for (t2 in _)
              _[t2] = set$1(_[t2], typename.name, null);
        }
        return this;
      },
      copy: function() {
        var copy2 = {}, _ = this._;
        for (var t2 in _)
          copy2[t2] = _[t2].slice();
        return new Dispatch(copy2);
      },
      call: function(type2, that) {
        if ((n = arguments.length - 2) > 0)
          for (var args = new Array(n), i2 = 0, n, t2; i2 < n; ++i2)
            args[i2] = arguments[i2 + 2];
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (t2 = this._[type2], i2 = 0, n = t2.length; i2 < n; ++i2)
          t2[i2].value.apply(that, args);
      },
      apply: function(type2, that, args) {
        if (!this._.hasOwnProperty(type2))
          throw new Error("unknown type: " + type2);
        for (var t2 = this._[type2], i2 = 0, n = t2.length; i2 < n; ++i2)
          t2[i2].value.apply(that, args);
      }
    };
    nonpassivecapture = { capture: true, passive: false };
    frame = 0;
    timeout$1 = 0;
    interval = 0;
    pokeDelay = 1e3;
    clockLast = 0;
    clockNow = 0;
    clockSkew = 0;
    clock = typeof performance === "object" && performance.now ? performance : Date;
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f3) {
      setTimeout(f3, 17);
    };
    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time2) {
        if (typeof callback !== "function")
          throw new TypeError("callback is not a function");
        time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail)
            taskTail._next = this;
          else
            taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time2;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };
    emptyOn = dispatch("start", "end", "cancel", "interrupt");
    emptyTween = [];
    CREATED = 0;
    SCHEDULED = 1;
    STARTING = 2;
    STARTED = 3;
    RUNNING = 4;
    ENDING = 5;
    ENDED = 6;
    Selection = selection.prototype.constructor;
    id = 0;
    selection_prototype = selection.prototype;
    Transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };
    defaultTiming = {
      time: null,
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };
    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;
    constant = (x22) => () => x22;
    MODE_DRAG = { name: "drag" };
    MODE_SPACE = { name: "space" };
    MODE_HANDLE = { name: "handle" };
    MODE_CENTER = { name: "center" };
    ({ abs, max, min } = Math);
    X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x22, e3) {
        return x22 == null ? null : [[+x22[0], e3[0][1]], [+x22[1], e3[1][1]]];
      },
      output: function(xy) {
        return xy && [xy[0][0], xy[1][0]];
      }
    };
    Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y2, e3) {
        return y2 == null ? null : [[e3[0][0], +y2[0]], [e3[1][0], +y2[1]]];
      },
      output: function(xy) {
        return xy && [xy[0][1], xy[1][1]];
      }
    };
    cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };
    flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };
    flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };
    signsX = {
      overlay: 1,
      selection: 1,
      n: null,
      e: 1,
      s: null,
      w: -1,
      nw: -1,
      ne: 1,
      se: 1,
      sw: -1
    };
    signsY = {
      overlay: 1,
      selection: 1,
      n: -1,
      e: null,
      s: 1,
      w: null,
      nw: -1,
      ne: -1,
      se: 1,
      sw: 1
    };
    __extends$L = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ChartBrush = function(_super) {
      __extends$L(ChartBrush2, _super);
      function ChartBrush2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "grid-brush";
        _this.renderType = RenderTypes.SVG;
        _this.selectionSelector = "rect.selection";
        _this.frontSelectionSelector = "rect.frontSelection";
        return _this;
      }
      ChartBrush2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.parent;
        var frontSelectionArea = this.getComponentContainer();
        var backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
        var brushArea = DOMUtils.appendOrSelect(backdrop, "g." + this.type);
        var d3Selection = DOMUtils.appendOrSelect(brushArea, this.selectionSelector);
        var _a22 = DOMUtils.getSVGElementSize(backdrop, {
          useAttrs: true
        }), width = _a22.width, height = _a22.height;
        var cartesianScales = this.services.cartesianScales;
        var mainXScaleType = cartesianScales.getMainXScaleType();
        var mainXScale = cartesianScales.getMainXScale();
        var _b = mainXScale.range(), xScaleStart = _b[0];
        _b[1];
        frontSelectionArea.attr("transform", "translate(" + xScaleStart + ",0)");
        var frontSelection = DOMUtils.appendOrSelect(frontSelectionArea, this.frontSelectionSelector);
        if (mainXScale && mainXScaleType === ScaleTypes.TIME) {
          var zoomDomain_1 = this.model.get("zoomDomain");
          if (zoomDomain_1 === void 0) {
            zoomDomain_1 = this.services.zoom.getDefaultZoomBarDomain();
            if (zoomDomain_1) {
              this.model.set({ zoomDomain: zoomDomain_1 }, { animate: false });
            }
          }
          var updateSelectionDash_1 = function(selection2) {
            var selectionWidth = selection2[1] - selection2[0];
            var dashArray = "0," + selectionWidth.toString();
            var dashCount = Math.floor(height / ChartBrush2.DASH_LENGTH);
            var totalRightDash = dashCount * ChartBrush2.DASH_LENGTH;
            for (var i2 = 0; i2 < dashCount; i2++) {
              dashArray += "," + ChartBrush2.DASH_LENGTH;
            }
            dashArray += "," + (height - totalRightDash);
            if (dashCount % 2 === 1) {
              dashArray += ",0";
            }
            dashArray += "," + selectionWidth.toString();
            dashArray += "," + height.toString();
            frontSelection.attr("stroke-dasharray", dashArray);
          };
          var brushEventHandler = function(event) {
            var selection2 = event.selection;
            if (selection2 === null || selection2[0] === selection2[1]) {
              return;
            }
            frontSelection.attr("x", parseFloat(d3Selection.attr("x")) + parseFloat(backdrop.attr("x"))).attr("y", d3Selection.attr("y")).attr("width", d3Selection.attr("width")).attr("height", d3Selection.attr("height")).style("cursor", "pointer").style("display", null);
            updateSelectionDash_1(selection2);
          };
          var updateZoomDomain_1 = function(startPoint, endPoint) {
            var xScale = time().range([0, width]).domain(zoomDomain_1);
            var newDomain = [
              xScale.invert(startPoint),
              xScale.invert(endPoint)
            ];
            if (newDomain[0].valueOf() === newDomain[1].valueOf()) {
              newDomain = _this.services.zoom.getDefaultZoomBarDomain();
            }
            if (zoomDomain_1[0].valueOf() !== newDomain[0].valueOf() || zoomDomain_1[1].valueOf() !== newDomain[1].valueOf()) {
              _this.services.zoom.handleDomainChange(newDomain);
            }
          };
          var brushed = function(event) {
            var selection2 = event.selection;
            if (selection2 !== null) {
              updateZoomDomain_1(selection2[0], selection2[1]);
              brushArea.call(brush_1.move, null);
              frontSelection.style("display", "none");
            }
          };
          var brush_1 = brushX().extent([
            [0, 0],
            [width - 1, height]
          ]).on("start brush end", brushEventHandler).on("end.brushed", brushed);
          brushArea.call(brush_1);
          var zoomRatio_1 = this.services.zoom.getZoomRatio();
          backdrop.on("click", function(event) {
            if (event.shiftKey) {
              var holder = this.services.domUtils.getHolder();
              var clickedX = pointer(brushArea.node(), holder)[0];
              var leftPoint = clickedX - width * zoomRatio_1 / 2;
              if (leftPoint < 0) {
                leftPoint = 0;
              }
              var rightPoint = clickedX + width * zoomRatio_1 / 2;
              if (rightPoint > width) {
                rightPoint = width;
              }
              updateZoomDomain_1(leftPoint, rightPoint);
            }
          });
        }
      };
      ChartBrush2.DASH_LENGTH = 4;
      return ChartBrush2;
    }(Component);
    __extends$K = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Grid = function(_super) {
      __extends$K(Grid2, _super);
      function Grid2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "grid";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Grid2.prototype.render = function(animate) {
        if (animate === void 0) {
          animate = true;
        }
        var isXGridEnabled = Tools.getProperty(this.getOptions(), "grid", "x", "enabled");
        var isYGridEnabled = Tools.getProperty(this.getOptions(), "grid", "y", "enabled");
        this.drawBackdrop(isXGridEnabled, isYGridEnabled);
        if (!isXGridEnabled && !isYGridEnabled) {
          return;
        }
        if (isXGridEnabled) {
          DOMUtils.appendOrSelect(this.backdrop, "g.x.grid");
          this.drawXGrid(animate);
        }
        if (isYGridEnabled) {
          DOMUtils.appendOrSelect(this.backdrop, "g.y.grid");
          this.drawYGrid(animate);
        }
      };
      Grid2.prototype.drawXGrid = function(animate) {
        var _this = this;
        var svg = this.parent;
        var height = this.backdrop.attr("height");
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var xGrid = axisBottom(mainXScale).tickSizeInner(-height).tickSizeOuter(0);
        var alignToTicks = Tools.getProperty(this.getOptions(), "grid", "x", "alignWithAxisTicks");
        if (alignToTicks) {
          var mainXPosition = this.services.cartesianScales.getDomainAxisPosition();
          var customDomain = Tools.getProperty(this.getOptions(), "axes", mainXPosition, "ticks", "values");
          if (customDomain) {
            xGrid.tickValues(customDomain);
          }
        } else {
          var numberOfTicks = Tools.getProperty(this.getOptions(), "grid", "x", "numberOfTicks");
          xGrid.ticks(numberOfTicks);
        }
        var g = svg.select(".x.grid").attr("transform", "translate(" + -this.backdrop.attr("x") + ", " + height + ")");
        if (animate) {
          g.transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "grid-update",
              animate
            });
          }).call(xGrid);
        } else {
          g.call(xGrid);
        }
        this.cleanGrid(g);
      };
      Grid2.prototype.drawYGrid = function(animate) {
        var _this = this;
        var svg = this.parent;
        var width = this.backdrop.attr("width");
        var mainYScale = this.services.cartesianScales.getMainYScale();
        var yGrid = axisLeft(mainYScale).tickSizeInner(-width).tickSizeOuter(0);
        var alignToTicks = Tools.getProperty(this.getOptions(), "grid", "y", "alignWithAxisTicks");
        if (alignToTicks) {
          var mainYPosition = this.services.cartesianScales.getRangeAxisPosition();
          var customDomain = Tools.getProperty(this.getOptions(), "axes", mainYPosition, "ticks", "values");
          if (customDomain) {
            yGrid.tickValues(customDomain);
          }
        } else {
          var numberOfTicks = Tools.getProperty(this.getOptions(), "grid", "y", "numberOfTicks");
          yGrid.ticks(numberOfTicks);
        }
        var g = svg.select(".y.grid").attr("transform", "translate(0, " + -this.backdrop.attr("y") + ")");
        if (animate) {
          g.transition().call(function(t2) {
            return _this.services.transitions.setupTransition({
              transition: t2,
              name: "grid-update",
              animate
            });
          }).call(yGrid);
        } else {
          g.call(yGrid);
        }
        this.cleanGrid(g);
      };
      Grid2.prototype.getGridlineThreshold = function(mousePos) {
        var svg = this.parent;
        var gridlinesX = svg.selectAll(".x.grid .tick").nodes().sort(function(a, b) {
          return Number(Tools.getTranslationValues(a).tx) - Number(Tools.getTranslationValues(b).tx);
        });
        var floor = -1;
        var ceiling;
        if (!gridlinesX.length) {
          return;
        }
        gridlinesX.forEach(function(line3, i2) {
          if (mousePos[0] >= +Tools.getTranslationValues(line3).tx) {
            floor++;
          }
        });
        ceiling = floor + 1 < gridlinesX.length ? floor + 1 : gridlinesX.length;
        var line1 = gridlinesX[floor];
        var line2 = gridlinesX[ceiling];
        var lineSpacing;
        if (!line1) {
          lineSpacing = +Tools.getTranslationValues(line2).tx;
        } else if (!line2) {
          var gridElement = svg.select("rect.chart-grid-backdrop").node();
          var width = DOMUtils.getSVGElementSize(gridElement).width;
          lineSpacing = width - +Tools.getTranslationValues(line1).tx;
        } else {
          lineSpacing = +Tools.getTranslationValues(line2).tx - +Tools.getTranslationValues(line1).tx;
        }
        var threshold = this.getOptions().tooltip.gridline.threshold;
        return lineSpacing * threshold;
      };
      Grid2.prototype.getActiveGridline = function(position) {
        var userSpecifiedThreshold = Tools.getProperty(this.getOptions, "tooltip", "gridline", "threshold");
        var threshold = userSpecifiedThreshold ? userSpecifiedThreshold : this.getGridlineThreshold(position);
        var svg = this.parent;
        var xGridlines = svg.selectAll(".x.grid .tick").filter(function() {
          var translations = Tools.getTranslationValues(this);
          var bounds = {
            min: Number(translations.tx) - threshold,
            max: Number(translations.tx) + threshold
          };
          return bounds.min <= position[0] && position[0] <= bounds.max;
        });
        return xGridlines;
      };
      Grid2.prototype.drawBackdrop = function(isXGridEnabled, isYGridEnabled) {
        var svg = this.parent;
        var mainXScale = this.services.cartesianScales.getMainXScale();
        var mainYScale = this.services.cartesianScales.getMainYScale();
        var _a22 = mainXScale.range(), xScaleStart = _a22[0], xScaleEnd = _a22[1];
        var _b = mainYScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
        var backdropRect = DOMUtils.appendOrSelect(this.backdrop, isXGridEnabled || isYGridEnabled ? "rect.chart-grid-backdrop.stroked" : "rect.chart-grid-backdrop");
        this.backdrop.merge(backdropRect).attr("x", xScaleStart).attr("y", yScaleStart).attr("width", Math.abs(xScaleEnd - xScaleStart)).attr("height", Math.abs(yScaleEnd - yScaleStart)).lower();
        backdropRect.attr("width", "100%").attr("height", "100%");
      };
      Grid2.prototype.cleanGrid = function(g) {
        g.selectAll("text").remove();
        g.select(".domain").remove();
      };
      return Grid2;
    }(Component);
    __extends$J = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    THRESHOLD = 5;
    Ruler = function(_super) {
      __extends$J(Ruler2, _super);
      function Ruler2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "ruler";
        _this.renderType = RenderTypes.SVG;
        _this.isXGridEnabled = Tools.getProperty(_this.getOptions(), "grid", "x", "enabled");
        _this.isYGridEnabled = Tools.getProperty(_this.getOptions(), "grid", "y", "enabled");
        _this.isEventListenerAdded = false;
        return _this;
      }
      Ruler2.prototype.render = function() {
        var isRulerEnabled = Tools.getProperty(this.getOptions(), "ruler", "enabled");
        this.drawBackdrop();
        if (isRulerEnabled && !this.isEventListenerAdded) {
          this.addBackdropEventListeners();
        } else if (!isRulerEnabled && this.isEventListenerAdded) {
          this.removeBackdropEventListeners();
        }
      };
      Ruler2.prototype.removeBackdropEventListeners = function() {
        this.isEventListenerAdded = false;
        this.backdrop.on("mousemove mouseover mouseout", null);
      };
      Ruler2.prototype.formatTooltipData = function(tooltipData) {
        return tooltipData;
      };
      Ruler2.prototype.showRuler = function(event, _a22) {
        var _this = this;
        var x22 = _a22[0], y2 = _a22[1];
        var svg = this.parent;
        var orientation = this.services.cartesianScales.getOrientation();
        var displayData = this.model.getDisplayData();
        var rangeScale = this.services.cartesianScales.getRangeScale();
        var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        var mouseCoordinate = orientation === CartesianOrientations.HORIZONTAL ? y2 : x22;
        var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler").attr("aria-label", "ruler");
        var rulerLine = DOMUtils.appendOrSelect(ruler2, "line.ruler-line");
        var dataPointElements = svg.selectAll("[role=graphics-symbol]");
        var pointsWithinLine = displayData.map(function(d) {
          return {
            domainValue: _this.services.cartesianScales.getDomainValue(d),
            originalData: d
          };
        }).filter(function(d) {
          return pointIsWithinThreshold(d.domainValue, mouseCoordinate);
        });
        if (this.pointsWithinLine && pointsWithinLine.length === this.pointsWithinLine.length && pointsWithinLine.map(function(point2) {
          return point2.domainValue;
        }).join() === this.pointsWithinLine.map(function(point2) {
          return point2.domainValue;
        }).join()) {
          this.pointsWithinLine = pointsWithinLine;
          return this.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
            mousePosition: [x22, y2]
          });
        }
        this.pointsWithinLine = pointsWithinLine;
        var dataPointsMatchingRulerLine = this.pointsWithinLine.reduce(function(accum, currentValue) {
          if (accum.length === 0) {
            accum.push(currentValue);
            return accum;
          }
          var sampleAccumValue = accum[0].domainValue;
          var distanceToCurrentValue = Math.abs(mouseCoordinate - currentValue.domainValue);
          var distanceToAccumValue = Math.abs(mouseCoordinate - sampleAccumValue);
          if (distanceToCurrentValue > distanceToAccumValue) {
            return accum;
          } else if (distanceToCurrentValue < distanceToAccumValue) {
            accum = [currentValue];
          } else {
            accum.push(currentValue);
          }
          return accum;
        }, []);
        if (dataPointsMatchingRulerLine.length > 0) {
          var tooltipData = dataPointsMatchingRulerLine.map(function(d) {
            return d.originalData;
          }).filter(function(d) {
            var rangeIdentifier = _this.services.cartesianScales.getRangeIdentifier(d);
            var value2 = d[rangeIdentifier];
            return value2 !== null && value2 !== void 0;
          });
          var domainValuesMatchingRulerLine_1 = dataPointsMatchingRulerLine.map(function(d) {
            return d.domainValue;
          });
          var elementsToHighlight = dataPointElements.filter(function(d) {
            var domainValue = _this.services.cartesianScales.getDomainValue(d);
            return domainValuesMatchingRulerLine_1.includes(domainValue);
          });
          if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {
            this.hideRuler();
          }
          elementsToHighlight.dispatch("mouseover");
          this.elementsToHighlight = elementsToHighlight;
          this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
            mousePosition: [x22, y2],
            hoveredElement: rulerLine,
            data: this.formatTooltipData(tooltipData)
          });
          ruler2.attr("opacity", 1);
          var sampleMatch = dataPointsMatchingRulerLine[0];
          if (orientation === "horizontal") {
            rulerLine.attr("x1", yScaleStart).attr("x2", yScaleEnd).attr("y1", sampleMatch.domainValue).attr("y2", sampleMatch.domainValue);
          } else {
            rulerLine.attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", sampleMatch.domainValue).attr("x2", sampleMatch.domainValue);
          }
        } else {
          this.hideRuler();
        }
      };
      Ruler2.prototype.hideRuler = function() {
        var svg = this.parent;
        var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler");
        var dataPointElements = svg.selectAll("[role=graphics-symbol]");
        dataPointElements.dispatch("mouseout");
        this.services.events.dispatchEvent(Events$1.Tooltip.HIDE);
        ruler2.attr("opacity", 0);
      };
      Ruler2.prototype.addBackdropEventListeners = function() {
        this.isEventListenerAdded = true;
        var self2 = this;
        var holder = this.services.domUtils.getHolder();
        var displayData = this.model.getDisplayData();
        var mouseMoveCallback = function(event) {
          var pos = pointer(event, self2.parent.node());
          self2.showRuler(event, pos);
        };
        if (displayData.length > 100) {
          var debounceThreshold = displayData.length % 50 * 12.5;
          mouseMoveCallback = Tools.debounceWithD3MousePosition(function(event) {
            var mousePosition = this.mousePosition;
            self2.showRuler(event, mousePosition);
          }, debounceThreshold, holder);
        }
        this.backdrop.on("mousemove mouseover", mouseMoveCallback).on("mouseout", this.hideRuler.bind(this));
      };
      Ruler2.prototype.drawBackdrop = function() {
        var svg = this.parent;
        this.backdrop = DOMUtils.appendOrSelect(svg, "svg.chart-grid-backdrop");
      };
      return Ruler2;
    }(Component);
    __extends$I = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$g = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    BinnedRuler = function(_super) {
      __extends$I(BinnedRuler2, _super);
      function BinnedRuler2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "ruler-binned";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      BinnedRuler2.prototype.showRuler = function(event, _a22) {
        var _this = this;
        var x22 = _a22[0], y2 = _a22[1];
        var svg = this.parent;
        var options2 = this.model.getOptions();
        var orientation = this.services.cartesianScales.getOrientation();
        var rangeScale = this.services.cartesianScales.getRangeScale();
        var _b = rangeScale.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        var domainScale = this.services.cartesianScales.getDomainScale();
        var correspondingDomainValue = domainScale.invert(orientation === CartesianOrientations.VERTICAL ? x22 : y2);
        var ruler2 = DOMUtils.appendOrSelect(svg, "g.ruler").attr("aria-label", "ruler");
        var rulerLine = DOMUtils.appendOrSelect(ruler2, "line.ruler-line");
        var dataPointElements = svg.selectAll("[role=graphics-symbol]");
        var elementsToHighlight = dataPointElements.filter(function(d) {
          if (parseFloat(get$3(d, "data.x0")) <= correspondingDomainValue && parseFloat(get$3(d, "data.x1")) >= correspondingDomainValue) {
            return true;
          }
        });
        if (elementsToHighlight.size() > 0) {
          if (this.elementsToHighlight && this.elementsToHighlight.size() > 0 && !Tools.isEqual(this.elementsToHighlight, elementsToHighlight)) {
            this.hideRuler();
          }
          elementsToHighlight.dispatch("mouseover");
          this.elementsToHighlight = elementsToHighlight;
          var sampleMatchData_1 = select(elementsToHighlight.nodes()[0]).datum();
          var x0 = parseFloat(get$3(sampleMatchData_1, "data.x0"));
          var x1 = parseFloat(get$3(sampleMatchData_1, "data.x1"));
          var activeDataGroupNames = this.model.getActiveDataGroupNames();
          var tooltipDataGroups = activeDataGroupNames.reverse().map(function(dataGroupName) {
            return {
              label: dataGroupName,
              value: get$3(sampleMatchData_1, "data." + dataGroupName),
              class: _this.model.getColorClassName({
                classNameTypes: [ColorClassNameTypes.TOOLTIP],
                dataGroupName
              })
            };
          }).filter(function(d) {
            return d.value !== 0;
          });
          var thereIsMatchingData = tooltipDataGroups.length > 0;
          if (thereIsMatchingData) {
            this.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              mousePosition: [x22, y2],
              hoveredElement: rulerLine,
              items: __spreadArrays$g([
                {
                  label: get$3(options2, "bins.rangeLabel") || "Range",
                  value: x0 + " \u2013 " + x1
                }
              ], tooltipDataGroups, Tools.getProperty(options2, "tooltip", "showTotal") === true ? [
                {
                  label: get$3(options2, "tooltip.totalLabel") || "Total",
                  value: activeDataGroupNames.reduce(function(accum, currentValue) {
                    return accum + parseFloat(get$3(sampleMatchData_1, "data." + currentValue));
                  }, 0)
                }
              ] : [])
            });
            ruler2.attr("opacity", 1);
            var rulerPosition = domainScale((x0 + x1) / 2);
            if (orientation === "horizontal") {
              rulerLine.attr("x1", yScaleStart).attr("x2", yScaleEnd).attr("y1", rulerPosition).attr("y2", rulerPosition);
            } else {
              rulerLine.attr("y1", yScaleStart).attr("y2", yScaleEnd).attr("x1", rulerPosition).attr("x2", rulerPosition);
            }
          } else {
            this.hideRuler();
          }
        } else {
          this.hideRuler();
        }
      };
      return BinnedRuler2;
    }(Ruler);
    __extends$H = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    StackedRuler = function(_super) {
      __extends$H(StackedRuler2, _super);
      function StackedRuler2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      StackedRuler2.prototype.formatTooltipData = function(tooltipData) {
        return tooltipData.reverse();
      };
      return StackedRuler2;
    }(Ruler);
    __extends$G = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Toolbar = function(_super) {
      __extends$G(Toolbar2, _super);
      function Toolbar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "toolbar";
        _this.renderType = RenderTypes.HTML;
        return _this;
      }
      Toolbar2.prototype.init = function() {
        var _this = this;
        var bodyOnClickHandler = function() {
          return _this.updateOverflowMenu(false);
        };
        this.services.events.addEventListener(Events$1.Toolbar.SHOW_OVERFLOW_MENU, function() {
          _this.renderOverflowMenu();
          document.body.addEventListener("click", bodyOnClickHandler);
        });
        this.services.events.addEventListener(Events$1.Toolbar.HIDE_OVERFLOW_MENU, function() {
          document.body.removeEventListener("click", bodyOnClickHandler);
        });
      };
      Toolbar2.prototype.render = function(animate) {
        var _this = this;
        var container = this.getComponentContainer().attr("role", "toolbar");
        var isDataLoading = Tools.getProperty(this.getOptions(), "data", "loading");
        if (isDataLoading) {
          container.html("");
          this.overflowMenu = null;
        } else {
          if (!this.overflowMenu) {
            this.overflowMenu = container.append("div").attr("class", "bx--overflow-menu-options bx--overflow-menu--flip cds--overflow-menu-options cds--overflow-menu--flip").attr("tabindex", -1).attr("role", "menu").html("<ul></ul>");
          }
          var _a22 = this.getControlConfigs(), buttonList = _a22.buttonList, overflowMenuItemList = _a22.overflowMenuItemList;
          if (!!overflowMenuItemList) {
            buttonList.push(this.getOverflowButtonConfig());
          }
          var toolbarControls = container.selectAll("div.toolbar-control").data(buttonList, function(button) {
            return button.id;
          });
          toolbarControls.exit().remove();
          var enteringToolbarControls = toolbarControls.enter().append("div").attr("class", "toolbar-control bx--overflow-menu cds--overflow-menu").attr("role", "button");
          var self_1 = this;
          enteringToolbarControls.merge(toolbarControls).classed("disabled", function(d) {
            return d.shouldBeDisabled();
          }).attr("aria-disabled", function(d) {
            return d.shouldBeDisabled();
          }).attr("aria-label", function(d) {
            return d.title;
          }).html(function(d) {
            return '\n			<button\n				class="bx--overflow-menu__trigger cds--overflow-menu__trigger"\n				aria-haspopup="true" aria-expanded="false" id="' + _this.services.domUtils.generateElementIDString("control-" + d.id) + '" aria-label="' + d.title + '">\n				<svg focusable="false" preserveAspectRatio="xMidYMid meet" style="will-change: transform; width: ' + (d.iconSVG.width !== void 0 ? d.iconSVG.width : "20px") + "; height: " + (d.iconSVG.height !== void 0 ? d.iconSVG.height : "20px") + '" xmlns="http://www.w3.org/2000/svg" class="bx--overflow-menu__icon cds--overflow-menu__icon" viewBox="0 0 32 32" aria-hidden="true">\n					' + d.iconSVG.content + "\n				</svg>\n			</button>";
          }).each(function(d, index2) {
            var _this2 = this;
            select(this).select("button").on("click", function(event) {
              if (!d.shouldBeDisabled()) {
                self_1.triggerFunctionAndEvent(d, event, _this2);
              }
            }).on("keydown", function(event) {
              if (event.key && event.key === "Enter" || event.key === " ") {
                event.preventDefault();
                self_1.triggerFunctionAndEvent(d, event, _this2);
              } else if (event.key && event.key === "ArrowLeft") {
                self_1.focusOnPreviousEnabledToolbarItem(index2);
              } else if (event.key && event.key === "ArrowRight") {
                self_1.focusOnNextEnabledToolbarItem(index2);
              }
            });
          });
          this.overflowButton = this.getComponentContainer().select("button.bx--overflow-menu__trigger#" + this.services.domUtils.generateElementIDString("control-toolbar-overflow-menu"));
        }
      };
      Toolbar2.prototype.renderOverflowMenu = function() {
        var _this = this;
        var overflowMenuItemList = this.getControlConfigs().overflowMenuItemList;
        var overflowMenuControls = this.overflowMenu.select("ul").selectAll("li.bx--overflow-menu-options__option").data(overflowMenuItemList, function(button) {
          return Tools.getProperty(button, "id");
        });
        overflowMenuControls.exit().remove();
        var enteringOverflowMenuControls = overflowMenuControls.enter().append("li").attr("id", function(d) {
          return _this.services.domUtils.generateElementIDString("control-" + d.id);
        }).attr("class", "bx--overflow-menu-options__option cds--overflow-menu-options__option").attr("role", "menuitem");
        enteringOverflowMenuControls.append("button").attr("class", "bx--overflow-menu-options__btn cds--overflow-menu-options__btn");
        enteringOverflowMenuControls.merge(overflowMenuControls).classed("bx--overflow-menu-options__option--disabled", function(d) {
          return d.shouldBeDisabled();
        }).classed("cds--overflow-menu-options__option--disabled", function(d) {
          return d.shouldBeDisabled();
        }).attr("aria-disabled", function(d) {
          return d.shouldBeDisabled();
        }).selectAll("button").text(function(d) {
          return d.text;
        });
      };
      Toolbar2.prototype.isOverflowMenuOpen = function() {
        return this.overflowMenu.classed("is-open");
      };
      Toolbar2.prototype.updateOverflowMenu = function(show) {
        if (!this.overflowMenu) {
          return;
        }
        this.overflowMenu.classed("is-open", show);
        if (this.overflowButton) {
          this.overflowButton.attr("aria-expanded", show);
          select(this.overflowButton.node().parentNode).classed("bx--overflow-menu--open", show).classed("cds--overflow-menu--open", show);
        }
        if (show) {
          this.services.events.dispatchEvent(Events$1.Toolbar.SHOW_OVERFLOW_MENU);
        } else {
          this.services.events.dispatchEvent(Events$1.Toolbar.HIDE_OVERFLOW_MENU);
        }
      };
      Toolbar2.prototype.focusOnPreviousEnabledToolbarItem = function(currentItemIndex) {
        var buttonList = this.getToolbarButtonItems();
        var previousItemIndex = buttonList.length;
        for (var i2 = currentItemIndex - 1; i2 >= 0; i2--) {
          var previousButtonItem = buttonList[i2];
          if (!previousButtonItem.shouldBeDisabled()) {
            previousItemIndex = i2;
            break;
          }
        }
        if (previousItemIndex < buttonList.length) {
          var previousItemNode = select("button#" + this.services.domUtils.generateElementIDString("control-" + buttonList[previousItemIndex].id)).node();
          if ("focus" in previousItemNode) {
            previousItemNode.focus();
          }
        }
      };
      Toolbar2.prototype.focusOnNextEnabledToolbarItem = function(currentItemIndex) {
        var buttonList = this.getToolbarButtonItems();
        var nextItemIndex = -1;
        for (var i2 = currentItemIndex + 1; i2 < buttonList.length; i2++) {
          var nextOverflowMenuItem = buttonList[i2];
          if (!nextOverflowMenuItem.shouldBeDisabled()) {
            nextItemIndex = i2;
            break;
          }
        }
        if (nextItemIndex > -1) {
          var nextItemNode = select("button#" + this.services.domUtils.generateElementIDString("control-" + buttonList[nextItemIndex].id)).node();
          if ("focus" in nextItemNode) {
            nextItemNode.focus();
          }
        }
      };
      Toolbar2.prototype.focusOnPreviousEnabledMenuItem = function(currentItemIndex) {
        var overflowMenuItems = this.getOverflowMenuItems();
        var previousItemIndex = overflowMenuItems.length;
        for (var i2 = currentItemIndex - 1; i2 >= 0; i2--) {
          var previousOverflowMenuItem = overflowMenuItems[i2];
          if (!previousOverflowMenuItem.shouldBeDisabled()) {
            previousItemIndex = i2;
            break;
          }
        }
        if (previousItemIndex < overflowMenuItems.length) {
          var previousItemNode = select("#" + this.services.domUtils.generateElementIDString("control-" + overflowMenuItems[previousItemIndex].id) + " button").node();
          if ("focus" in previousItemNode) {
            previousItemNode.focus();
          }
        }
      };
      Toolbar2.prototype.focusOnNextEnabledMenuItem = function(currentItemIndex) {
        var overflowMenuItems = this.getOverflowMenuItems();
        var nextItemIndex = -1;
        for (var i2 = currentItemIndex + 1; i2 < overflowMenuItems.length; i2++) {
          var nextOverflowMenuItem = overflowMenuItems[i2];
          if (!nextOverflowMenuItem.shouldBeDisabled()) {
            nextItemIndex = i2;
            break;
          }
        }
        if (nextItemIndex > -1) {
          var nextItemNode = select("#" + this.services.domUtils.generateElementIDString("control-" + overflowMenuItems[nextItemIndex].id) + " button").node();
          if ("focus" in nextItemNode) {
            nextItemNode.focus();
          }
        }
      };
      Toolbar2.prototype.toggleOverflowMenu = function(event) {
        var _this = this;
        if (this.isOverflowMenuOpen()) {
          this.updateOverflowMenu(false);
        } else {
          this.updateOverflowMenu(true);
          var self_2 = this;
          var overflowMenuItems = this.getOverflowMenuItems();
          overflowMenuItems.forEach(function(menuItem, index2) {
            var element = select("#" + _this.services.domUtils.generateElementIDString("control-" + menuItem.id));
            if (element !== null) {
              element.on("click", function() {
                self_2.triggerFunctionAndEvent(menuItem, event, element.node());
                self_2.updateOverflowMenu(false);
              });
              element.on("keydown", function(keyEvent) {
                if (keyEvent && keyEvent.key === "Enter") {
                  self_2.triggerFunctionAndEvent(menuItem, event, element.node());
                } else if (keyEvent && keyEvent.key === "ArrowUp") {
                  self_2.focusOnPreviousEnabledMenuItem(index2);
                } else if (keyEvent && keyEvent.key === "ArrowDown") {
                  self_2.focusOnNextEnabledMenuItem(index2);
                } else if (keyEvent && keyEvent.key === "Escape") {
                  self_2.updateOverflowMenu(false);
                }
                keyEvent.preventDefault();
              });
            }
          });
          self_2.focusOnNextEnabledMenuItem(-1);
        }
        if (!!event) {
          event.stopImmediatePropagation();
        }
      };
      Toolbar2.prototype.triggerFunctionAndEvent = function(control, event, element) {
        if (typeof control.clickFunction === "function") {
          control.clickFunction(event);
        }
        this.services.events.dispatchEvent(Events$1.Toolbar.BUTTON_CLICK, {
          control,
          event,
          element
        });
      };
      Toolbar2.prototype.getControlConfigs = function() {
        var _this = this;
        var numberOfIcons = Tools.getProperty(this.getOptions(), "toolbar", "numberOfIcons") - 1;
        var controls = Tools.getProperty(this.getOptions(), "toolbar", "controls");
        var overflowSpecificControls = [];
        var buttonList = [];
        var overflowList = [];
        controls.forEach(function(control) {
          var controlConfig = null;
          if (control.type === ToolbarControlTypes.CUSTOM) {
            if (Tools.getProperty(control, "id") === null) {
              control.id = "toolbar-button-" + Toolbar2.buttonID++;
            }
            if (Tools.getProperty(control, "shouldBeDisabled") === null) {
              control.shouldBeDisabled = function() {
                return false;
              };
            }
            controlConfig = control;
          } else {
            controlConfig = _this.getControlConfigByType(control.type);
          }
          if (controlConfig) {
            controlConfig.text = control.text ? control.text : control.type;
            if (controlConfig.id.indexOf("toolbar-export") !== -1) {
              overflowSpecificControls.push(controlConfig);
            } else if (buttonList.length < numberOfIcons) {
              if (Tools.getProperty(controlConfig, "iconSVG", "content") === null) {
                overflowList.push(controlConfig);
              } else {
                buttonList.push(controlConfig);
              }
            } else {
              overflowList.push(controlConfig);
            }
          }
        });
        overflowList.push.apply(overflowList, overflowSpecificControls);
        if (!overflowList.length) {
          return {
            buttonList
          };
        }
        return {
          buttonList,
          overflowMenuItemList: overflowList
        };
      };
      Toolbar2.prototype.getToolbarButtonItems = function() {
        var _a22 = this.getControlConfigs(), buttonList = _a22.buttonList, overflowMenuItemList = _a22.overflowMenuItemList;
        if (!!overflowMenuItemList) {
          buttonList.push(this.getOverflowButtonConfig());
        }
        if (!!buttonList) {
          return buttonList;
        }
        return [];
      };
      Toolbar2.prototype.getOverflowMenuItems = function() {
        var overflowMenuItemList = this.getControlConfigs().overflowMenuItemList;
        if (!!overflowMenuItemList) {
          return overflowMenuItemList;
        } else {
          return [];
        }
      };
      Toolbar2.prototype.getOverflowButtonConfig = function() {
        var _this = this;
        return {
          id: "toolbar-overflow-menu",
          title: "More options",
          shouldBeDisabled: function() {
            return false;
          },
          iconSVG: {
            content: '<circle cx="16" cy="8" r="2"></circle>\n				<circle cx="16" cy="16" r="2"></circle>\n				<circle cx="16" cy="24" r="2"></circle>'
          },
          clickFunction: function(event) {
            return _this.toggleOverflowMenu(event);
          }
        };
      };
      Toolbar2.prototype.getControlConfigByType = function(controlType) {
        var _this = this;
        var isZoomBarEnabled = this.services.zoom && this.services.zoom.isZoomBarEnabled() && !this.services.zoom.isEmptyState();
        var displayData = this.model.getDisplayData();
        var controlConfig;
        switch (controlType) {
          case ToolbarControlTypes.ZOOM_IN:
            if (isZoomBarEnabled) {
              controlConfig = {
                id: "toolbar-zoomIn",
                title: "Zoom in",
                shouldBeDisabled: function() {
                  return _this.services.zoom.isMinZoomDomain();
                },
                iconSVG: {
                  content: this.getControlIconByType(controlType)
                },
                clickFunction: function() {
                  return _this.services.zoom.zoomIn();
                }
              };
            }
            break;
          case ToolbarControlTypes.ZOOM_OUT:
            if (isZoomBarEnabled) {
              controlConfig = {
                id: "toolbar-zoomOut",
                title: "Zoom out",
                shouldBeDisabled: function() {
                  return _this.services.zoom.isMaxZoomDomain();
                },
                iconSVG: {
                  content: this.getControlIconByType(controlType)
                },
                clickFunction: function() {
                  return _this.services.zoom.zoomOut();
                }
              };
            }
            break;
          case ToolbarControlTypes.RESET_ZOOM:
            if (isZoomBarEnabled) {
              controlConfig = {
                id: "toolbar-resetZoom",
                title: "Reset zoom",
                shouldBeDisabled: function() {
                  return _this.services.zoom.isMaxZoomDomain();
                },
                iconSVG: {
                  content: this.getControlIconByType(controlType)
                },
                clickFunction: function() {
                  return _this.services.zoom.resetZoomDomain();
                }
              };
            }
            break;
          case ToolbarControlTypes.MAKE_FULLSCREEN:
            controlConfig = {
              id: "toolbar-makefullscreen",
              iconSVG: {
                content: this.getControlIconByType(controlType),
                width: "15px",
                height: "15px"
              },
              title: "Make fullscreen",
              shouldBeDisabled: function() {
                return false;
              },
              clickFunction: function() {
                _this.services.domUtils.toggleFullscreen();
              }
            };
            break;
          case ToolbarControlTypes.SHOW_AS_DATATABLE:
            controlConfig = {
              id: "toolbar-showasdatatable",
              iconSVG: {
                content: this.getControlIconByType(controlType)
              },
              title: "Show as table",
              shouldBeDisabled: function() {
                return displayData.length === 0;
              },
              clickFunction: function() {
                return _this.services.events.dispatchEvent(Events$1.Modal.SHOW);
              }
            };
            break;
          case ToolbarControlTypes.EXPORT_CSV:
            controlConfig = {
              id: "toolbar-export-CSV",
              title: "Export as CSV",
              shouldBeDisabled: function() {
                return false;
              },
              iconSVG: {
                content: this.getControlIconByType(controlType)
              },
              clickFunction: function() {
                return _this.model.exportToCSV();
              }
            };
            break;
          case ToolbarControlTypes.EXPORT_PNG:
            controlConfig = {
              id: "toolbar-export-PNG",
              title: "Export as PNG",
              shouldBeDisabled: function() {
                return false;
              },
              iconSVG: {
                content: this.getControlIconByType(controlType)
              },
              clickFunction: function() {
                return _this.services.domUtils.exportToPNG();
              }
            };
            break;
          case ToolbarControlTypes.EXPORT_JPG:
            controlConfig = {
              id: "toolbar-export-JPG",
              title: "Export as JPG",
              shouldBeDisabled: function() {
                return false;
              },
              iconSVG: {
                content: this.getControlIconByType(controlType)
              },
              clickFunction: function() {
                return _this.services.domUtils.exportToJPG();
              }
            };
            break;
          default:
            throw Error("Not supported toolbar control type: " + controlType);
        }
        return controlConfig;
      };
      Toolbar2.prototype.getControlIconByType = function(controlType) {
        switch (controlType) {
          case ToolbarControlTypes.ZOOM_IN:
            return '<polygon points="19 13 15 13 15 9 13 9 13 13 9 13 9 15 13 15 13 19 15 19 15 15 19 15 19 13"/>\n						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>';
          case ToolbarControlTypes.ZOOM_OUT:
            return '<rect x="9" y="13" width="10" height="2"/>\n						<path d="M22.45,21A10.87,10.87,0,0,0,25,14,11,11,0,1,0,14,25a10.87,10.87,0,0,0,7-2.55L28.59,30,30,28.59ZM14,23a9,9,0,1,1,9-9A9,9,0,0,1,14,23Z"/>';
          case ToolbarControlTypes.RESET_ZOOM:
            return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
          case ToolbarControlTypes.MAKE_FULLSCREEN:
            return '<polygon points="21 2 21 4 26.59 4 17 13.58 18.41 15 28 5.41 28 11 30 11 30 2 21 2"/><polygon points="15 18.42 13.59 17 4 26.59 4 21 2 21 2 30 11 30 11 28 5.41 28 15 18.42"/>';
          case ToolbarControlTypes.SHOW_AS_DATATABLE:
            return '<rect x="4" y="6" width="18" height="2"/><rect x="4" y="12" width="18" height="2"/><rect x="4" y="18" width="18" height="2"/><rect x="4" y="24" width="18" height="2"/><rect x="26" y="6" width="2" height="2"/><rect x="26" y="12" width="2" height="2"/><rect x="26" y="18" width="2" height="2"/><rect x="26" y="24" width="2" height="2"/>';
          case ToolbarControlTypes.EXPORT_CSV:
            return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
          case ToolbarControlTypes.EXPORT_JPG:
            return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
          case ToolbarControlTypes.EXPORT_PNG:
            return '<path d="M22.4478,21A10.855,10.855,0,0,0,25,14,10.99,10.99,0,0,0,6,6.4658V2H4v8h8V8H7.332a8.9768,8.9768,0,1,1-2.1,8H3.1912A11.0118,11.0118,0,0,0,14,25a10.855,10.855,0,0,0,7-2.5522L28.5859,30,30,28.5859Z"/>';
          default:
            throw Error("Not supported toolbar control type: " + controlType);
        }
      };
      Toolbar2.buttonID = 0;
      return Toolbar2;
    }(Component);
    __extends$F = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ZeroLine = function(_super) {
      __extends$F(ZeroLine2, _super);
      function ZeroLine2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "zero-line";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      ZeroLine2.prototype.render = function(animate) {
        var _this = this;
        var axisPosition = this.services.cartesianScales.getRangeAxisPosition({ groups: this.configs.groups });
        var rangeScale = this.services.cartesianScales.getScaleByPosition(axisPosition);
        var _a22 = rangeScale.domain(), minDomainValue = _a22[0], maxDomainValue = _a22[1];
        var drawZeroLine = minDomainValue > 0 && maxDomainValue < 0 || minDomainValue < 0 && maxDomainValue > 0;
        var svg = this.getComponentContainer();
        if (!drawZeroLine) {
          svg.selectAll("line.domain").remove();
          return;
        }
        var _b = this.services.cartesianScales.getDomainScale().range(), x0 = _b[0], x1 = _b[1];
        var yPosition = +rangeScale(0) + 0.5;
        if (!yPosition) {
          yPosition = rangeScale.range()[0];
        }
        var lineCoordinates = Tools.flipSVGCoordinatesBasedOnOrientation({
          x0,
          x1,
          y0: yPosition,
          y1: yPosition
        }, this.services.cartesianScales.getOrientation());
        var line2 = DOMUtils.appendOrSelect(svg, "line.domain");
        line2.transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "zero-line-update",
            animate
          });
        }).attr("y1", lineCoordinates.y0).attr("y2", lineCoordinates.y1).attr("x1", lineCoordinates.x0).attr("x2", lineCoordinates.x1);
      };
      return ZeroLine2;
    }(Component);
    __extends$E = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ZoomBar = function(_super) {
      __extends$E(ZoomBar2, _super);
      function ZoomBar2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "zoom-bar";
        _this.renderType = RenderTypes.SVG;
        _this.MIN_SELECTION_DIFF = 9e-10;
        _this.brushSelector = "g.zoom-bar-brush";
        _this.clipId = "zoomBarClip-" + Math.floor(Math.random() * 99999999999);
        _this.brush = brushX();
        _this.highlightStrokeWidth = 1;
        return _this;
      }
      ZoomBar2.prototype.init = function() {
        this.services.events.addEventListener(Events$1.ZoomBar.UPDATE, this.render.bind(this));
        var definedZoomBarData = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "data");
        this.model.setZoomBarData(definedZoomBarData);
      };
      ZoomBar2.prototype.render = function(animate) {
        var _this = this;
        var svg = this.getComponentContainer();
        var isTopZoomBarLoading = this.services.zoom.isZoomBarLoading(AxisPositions.TOP);
        var isTopZoomBarLocked = this.services.zoom.isZoomBarLocked(AxisPositions.TOP);
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var highlight = Tools.getProperty(this.getOptions(), "axes", AxisPositions.BOTTOM, "highlights");
        var zoombarHeight = zoomBar.height[zoombarType];
        var width = DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }).width;
        if (width === 0) {
          return;
        }
        var axesLeftMargin = 0;
        var axesMargins = this.model.get("axesMargins");
        if (axesMargins && axesMargins.left) {
          axesLeftMargin = axesMargins.left;
        }
        var container = DOMUtils.appendOrSelect(svg, "svg.zoom-container").attr("width", "100%").attr("height", zoombarHeight).attr("opacity", 1);
        DOMUtils.appendOrSelect(svg, "rect.zoom-spacer").attr("x", 0).attr("y", zoombarHeight).attr("width", "100%").attr("height", zoomBar.spacerHeight).attr("opacity", 1).attr("fill", "none");
        if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
          DOMUtils.appendOrSelect(container, "rect.zoom-bg").attr("x", axesLeftMargin).attr("y", 0).attr("width", width - axesLeftMargin).attr("height", "100%").classed("zoom-bg-skeleton", isTopZoomBarLoading).style("stroke", isTopZoomBarLoading ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
        } else if (zoombarType === ZoomBarTypes.SLIDER_VIEW) {
          DOMUtils.appendOrSelect(container, "rect.zoom-slider-bg").attr("x", axesLeftMargin).attr("y", zoombarHeight / 2 - 1).attr("width", width - axesLeftMargin).attr("height", 2).classed("zoom-slider-bg-skeleton", isTopZoomBarLoading).style("stroke", isTopZoomBarLoading ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
        }
        if (isTopZoomBarLoading) {
          this.renderSkeleton(container, axesLeftMargin, width);
          return;
        }
        var cartesianScales = this.services.cartesianScales;
        var mainXScale = cartesianScales.getMainXScale();
        var mainYScale = cartesianScales.getMainYScale();
        var mainXScaleType = cartesianScales.getMainXScaleType();
        if (mainXScale && mainXScaleType === ScaleTypes.TIME) {
          var zoomBarData = this.services.zoom.getZoomBarData();
          if (Tools.isEmpty(zoomBarData) || zoomBarData.length === 1) {
            return;
          }
          this.xScale = mainXScale.copy();
          this.yScale = mainYScale.copy();
          var defaultDomain = this.services.zoom.getDefaultZoomBarDomain(zoomBarData);
          zoomBarData = this.compensateDataForDefaultDomain(zoomBarData, defaultDomain);
          var oldInitialZoomDomain = this.model.get("initialZoomDomain");
          var newInitialZoomDomain = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "initialZoomDomain");
          if (newInitialZoomDomain && newInitialZoomDomain[0] && newInitialZoomDomain[1]) {
            newInitialZoomDomain[0] = new Date(newInitialZoomDomain[0]);
            newInitialZoomDomain[1] = new Date(newInitialZoomDomain[1]);
          }
          if (newInitialZoomDomain && !(oldInitialZoomDomain && oldInitialZoomDomain[0].valueOf() === newInitialZoomDomain[0].valueOf() && oldInitialZoomDomain[1].valueOf() === newInitialZoomDomain[1].valueOf())) {
            this.model.set({
              initialZoomDomain: Tools.merge([], newInitialZoomDomain),
              zoomDomain: newInitialZoomDomain ? Tools.merge([], newInitialZoomDomain) : defaultDomain
            }, { skipUpdate: true });
          } else if (newInitialZoomDomain === null && oldInitialZoomDomain !== null) {
            this.model.set({
              initialZoomDomain: null,
              zoomDomain: Tools.merge([], defaultDomain)
            }, { skipUpdate: true });
          }
          this.xScale.range([axesLeftMargin, width]).domain(defaultDomain);
          this.maxSelectionRange = this.xScale.range();
          this.yScale.range([0, zoombarHeight - 6]).domain(extent(zoomBarData, function(d) {
            return d.value;
          }));
          var zoomDomain = this.model.get("zoomDomain");
          if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
            this.renderZoomBarArea(container, "path.zoom-graph-area-unselected", zoomBarData, null);
            this.updateClipPath(svg, this.clipId, 0, 0, 0, 0);
            this.renderZoomBarArea(container, "path.zoom-graph-area", zoomBarData, this.clipId);
            this.renderZoomBarBaseline(container, axesLeftMargin, width);
            if (highlight) {
              var startHighlight_1 = highlight.highlightStartMapsTo;
              var endHighlight_1 = highlight.highlightEndMapsTo;
              var color_1 = highlight.color;
              var labelMapTo_1 = highlight.labelMapsTo;
              highlight.data.forEach(function(element, index2) {
                DOMUtils.appendOrSelect(container, "rect.highlight-" + index2).attr("height", zoombarHeight - 2 * _this.highlightStrokeWidth).attr("y", _this.highlightStrokeWidth).attr("x", _this.xScale(element[startHighlight_1])).attr("width", _this.xScale(element[endHighlight_1]) - _this.xScale(element[startHighlight_1])).style("fill", color_1 && color_1.scale[element[labelMapTo_1]] ? color_1.scale[element[labelMapTo_1]] : null).style("fill-opacity", 0.1).style("stroke", color_1 && color_1.scale[element[labelMapTo_1]] ? color_1.scale[element[labelMapTo_1]] : null).style("stroke-dasharray", "2, 2").attr("stroke-width", 1 + "px");
              });
            }
          }
          this.addBrushEventListener(zoomDomain, axesLeftMargin, width);
          var brushArea = DOMUtils.appendOrSelect(svg, this.brushSelector).call(this.brush);
          if (zoomDomain === void 0)
            ;
          else if (zoomDomain[0].valueOf() === zoomDomain[1].valueOf()) {
            brushArea.call(this.brush.move, this.xScale.range());
            this.updateBrushHandle(this.getComponentContainer(), this.xScale.range(), this.xScale.domain());
          } else {
            var selected = zoomDomain.map(function(domain) {
              return _this.xScale(domain);
            });
            if (selected[1] - selected[0] < this.MIN_SELECTION_DIFF)
              ;
            else {
              brushArea.call(this.brush.move, selected);
              this.updateBrushHandle(this.getComponentContainer(), selected, zoomDomain);
            }
          }
          if (isTopZoomBarLocked) {
            this.brush.filter(function() {
              return false;
            });
            brushArea.selectAll("rect").attr("cursor", "auto");
          }
        }
      };
      ZoomBar2.prototype.addBrushEventListener = function(zoomDomain, axesLeftMargin, width) {
        var _this = this;
        var brushEventListener = function(event) {
          var selection2 = event.selection;
          if (selection2 === null) {
            _this.handleBrushedEvent(event, zoomDomain, _this.xScale, _this.xScale.range());
          } else if (selection2[0] === selection2[1])
            ;
          else {
            _this.handleBrushedEvent(event, zoomDomain, _this.xScale, selection2);
          }
        };
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var zoombarHeight = zoomBar.height[zoombarType];
        this.brush.extent([
          [axesLeftMargin, 0],
          [width, zoombarHeight]
        ]).on("start brush end", null).on("start brush end", brushEventListener);
      };
      ZoomBar2.prototype.handleBrushedEvent = function(event, zoomDomain, scale, selection2) {
        var newDomain = [
          scale.invert(selection2[0]),
          scale.invert(selection2[1])
        ];
        this.updateBrushHandle(this.getComponentContainer(), selection2, newDomain);
        if (event.sourceEvent != null && (event.sourceEvent.type === "mousemove" || event.sourceEvent.type === "mouseup" || event.sourceEvent.type === "mousedown" || event.sourceEvent.type === "touchstart" || event.sourceEvent.type === "touchmove" || event.sourceEvent.type === "touchend")) {
          if (zoomDomain === void 0 || zoomDomain[0] !== newDomain[0] || zoomDomain[1] !== newDomain[1]) {
            this.services.zoom.handleDomainChange(newDomain, {
              dispatchEvent: false
            });
          }
          var zoomBarEventType = void 0;
          if (event.type === "start") {
            zoomBarEventType = Events$1.ZoomBar.SELECTION_START;
          } else if (event.type === "brush") {
            zoomBarEventType = Events$1.ZoomBar.SELECTION_IN_PROGRESS;
          } else if (event.type === "end") {
            zoomBarEventType = Events$1.ZoomBar.SELECTION_END;
            this.services.events.dispatchEvent(Events$1.ZoomDomain.CHANGE, {
              newDomain
            });
          }
          this.services.events.dispatchEvent(zoomBarEventType, {
            selection: selection2,
            newDomain
          });
        }
      };
      ZoomBar2.prototype.updateBrushHandle = function(svg, selection2, domain) {
        var self2 = this;
        var handleWidth = zoomBar.handleWidth;
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var handleHeight = zoomBar.height[zoombarType];
        var handleXDiff = -handleWidth / 2;
        var handleBarWidth = zoomBar.handleBarWidth;
        var handleBarHeight = zoombarType === ZoomBarTypes.GRAPH_VIEW ? zoomBar.handleBarHeight : 6;
        var handleBarXDiff = -handleBarWidth / 2;
        var handleYBarDiff = (handleHeight - handleBarHeight) / 2;
        svg.select(this.brushSelector).selectAll("rect.handle").data([{ type: "w" }, { type: "e" }]).attr("x", function(d) {
          if (d.type === "w") {
            return Math.max(selection2[0] + handleXDiff, self2.maxSelectionRange[0]);
          } else if (d.type === "e") {
            return Math.min(selection2[1] + handleXDiff, self2.maxSelectionRange[1] - handleWidth);
          }
        }).attr("y", 0).attr("width", handleWidth).attr("height", handleHeight).attr("cursor", "ew-resize").style("display", null);
        var handleBars = svg.select(this.brushSelector).selectAll("rect.handle-bar").data([{ type: "w" }, { type: "e" }]);
        handleBars.enter().append("rect").attr("class", function(d) {
          return "handle-bar handle-bar--" + d.type;
        });
        handleBars.attr("x", function(d) {
          if (d.type === "w") {
            return Math.max(selection2[0] + handleBarXDiff, self2.maxSelectionRange[0] - handleXDiff + handleBarXDiff);
          } else if (d.type === "e") {
            return Math.min(selection2[1] + handleBarXDiff, self2.maxSelectionRange[1] + handleXDiff + handleBarXDiff);
          }
        }).attr("y", handleYBarDiff).attr("width", handleBarWidth).attr("height", handleBarHeight).attr("cursor", "ew-resize");
        if (zoombarType === ZoomBarTypes.SLIDER_VIEW) {
          this.updateSliderSelectedArea(selection2);
        }
        this.updateClipPath(svg, this.clipId, selection2[0], 0, selection2[1] - selection2[0], handleHeight);
      };
      ZoomBar2.prototype.updateSliderSelectedArea = function(selection2) {
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var zoombarHeight = zoomBar.height[zoombarType];
        DOMUtils.getSVGElementSize(this.parent, {
          useAttrs: true
        }).width;
        var axesMargins = this.model.get("axesMargins");
        if (axesMargins && axesMargins.left)
          ;
        var svg = this.getComponentContainer();
        var container = svg.select("svg.zoom-container");
        DOMUtils.appendOrSelect(container, "rect.zoom-slider-selected-area").attr("x", selection2[0]).attr("y", zoombarHeight / 2 - 1).attr("width", selection2[1] - selection2[0]).attr("height", 2);
      };
      ZoomBar2.prototype.renderZoomBarArea = function(container, querySelector, data, clipId) {
        var cartesianScales = this.services.cartesianScales;
        var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
        var mainYAxisPosition = cartesianScales.getMainYAxisPosition();
        var mainXScaleType = cartesianScales.getMainXScaleType();
        var mainYScaleType = cartesianScales.getMainYScaleType();
        var accessorFunction = function(scale, scaleType, axisPosition) {
          return function(d, i2) {
            return cartesianScales.getValueFromScale(scale, scaleType, axisPosition, d, i2);
          };
        };
        var xAccessor = accessorFunction(this.xScale, mainXScaleType, mainXAxisPosition);
        var yAccessor = accessorFunction(this.yScale, mainYScaleType, mainYAxisPosition);
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var zoombarHeight = zoomBar.height[zoombarType];
        var areaGenerator = area().x(function(d, i2) {
          return xAccessor(d, i2);
        }).y0(zoombarHeight).y1(function(d, i2) {
          return zoombarHeight - yAccessor(d, i2);
        });
        var areaGraph = DOMUtils.appendOrSelect(container, querySelector).datum(data).attr("d", areaGenerator);
        if (clipId) {
          areaGraph.attr("clip-path", "url(#" + clipId + ")");
        }
      };
      ZoomBar2.prototype.updateClipPath = function(svg, clipId, x22, y2, width, height) {
        var zoomBarClipPath = DOMUtils.appendOrSelect(svg, "clipPath").attr("id", clipId);
        DOMUtils.appendOrSelect(zoomBarClipPath, "rect").attr("x", x22).attr("y", y2).attr("width", width).attr("height", height);
      };
      ZoomBar2.prototype.compensateDataForDefaultDomain = function(data, defaultDomain) {
        if (!data || data.length < 2) {
          return;
        }
        var zoomBarData = Tools.clone(data);
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        if (Number(defaultDomain[0]) < Number(zoomBarData[0][domainIdentifier])) {
          var newDatum = {};
          newDatum[domainIdentifier] = defaultDomain[0];
          newDatum[rangeIdentifier] = 0;
          zoomBarData.unshift(newDatum);
        }
        if (Number(defaultDomain[1]) > Number(zoomBarData[zoomBarData.length - 1][domainIdentifier])) {
          var newDatum = {};
          newDatum[domainIdentifier] = defaultDomain[1];
          newDatum[rangeIdentifier] = 0;
          zoomBarData.push(newDatum);
        }
        return zoomBarData;
      };
      ZoomBar2.prototype.renderZoomBarBaseline = function(container, startX, endX, skeletonClass) {
        if (skeletonClass === void 0) {
          skeletonClass = false;
        }
        var zoombarType = Tools.getProperty(this.model.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        var zoombarHeight = zoomBar.height[zoombarType];
        var baselineGenerator = line()([
          [startX, zoombarHeight],
          [endX, zoombarHeight]
        ]);
        DOMUtils.appendOrSelect(container, "path.zoom-bg-baseline").attr("d", baselineGenerator).classed("zoom-bg-baseline-skeleton", skeletonClass).style("stroke", skeletonClass ? "url(#" + this.services.domUtils.generateElementIDString("shimmer-lines") + ")" : null);
      };
      ZoomBar2.prototype.renderSkeleton = function(container, startX, endX) {
        this.renderZoomBarArea(container, "path.zoom-graph-area-unselected", [], null);
        this.renderZoomBarArea(container, "path.zoom-graph-area", [], this.clipId);
        this.brush.on("start brush end", null);
        DOMUtils.appendOrSelect(this.getComponentContainer(), this.brushSelector).html(null);
        var zoombarType = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "type");
        if (zoombarType === ZoomBarTypes.GRAPH_VIEW) {
          this.renderZoomBarBaseline(container, startX, endX, true);
        }
      };
      ZoomBar2.prototype.destroy = function() {
        this.brush.on("start brush end", null);
        this.services.events.removeEventListener(Events$1.ZoomBar.UPDATE, this.render.bind(this));
      };
      return ZoomBar2;
    }(Component);
    __spreadArrays$f = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    Chart = function() {
      function Chart2(holder, chartConfigs) {
        this.services = {
          domUtils: DOMUtils,
          files: Files,
          events: Events,
          gradientUtils: GradientUtils,
          transitions: Transitions,
          canvasZoom: CanvasZoom
        };
        this.model = new ChartModel(this.services);
      }
      Chart2.prototype.init = function(holder, chartConfigs) {
        var _this = this;
        this.model.set({ holder }, { skipUpdate: true });
        Object.keys(this.services).forEach(function(serviceName) {
          var serviceObj = _this.services[serviceName];
          _this.services[serviceName] = new serviceObj(_this.model, _this.services);
        });
        this.services.events.addEventListener(Events$1.Model.UPDATE, function(e3) {
          var animate = !!Tools.getProperty(e3, "detail", "animate");
          _this.update(animate);
        });
        this.model.setData(chartConfigs.data);
        this.services.events.addEventListener(Events$1.Chart.RESIZE, function() {
          _this.update(false);
        });
        this.components = this.getComponents();
        this.update();
      };
      Chart2.prototype.getComponents = function() {
        console.error("getComponents() method is not implemented");
        return null;
      };
      Chart2.prototype.update = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        if (!this.components) {
          return;
        }
        Object.keys(this.services).forEach(function(serviceName) {
          var serviceObj = _this.services[serviceName];
          serviceObj.update();
        });
        this.components.forEach(function(component) {
          return component.render(animate);
        });
        var pendingTransitions = this.services.transitions.getPendingTransitions();
        var promises = Object.keys(pendingTransitions).map(function(transitionID) {
          var transition = pendingTransitions[transitionID];
          return transition.end().catch(function(e3) {
            return e3;
          });
        });
        Promise.all(promises).then(function() {
          return _this.services.events.dispatchEvent(Events$1.Chart.RENDER_FINISHED);
        });
      };
      Chart2.prototype.destroy = function() {
        this.components.forEach(function(component) {
          return component.destroy();
        });
        this.services.domUtils.getHolder().remove();
        this.model.set({ destroyed: true }, { skipUpdate: true });
      };
      Chart2.prototype.getChartComponents = function(graphFrameComponents, configs) {
        var options2 = this.model.getOptions();
        var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
        var legendComponent = {
          id: "legend",
          components: [new Legend(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var isZoomEnabled = Tools.getProperty(options2, "canvasZoom", "enabled");
        if (isZoomEnabled && isZoomEnabled === true) {
          graphFrameComponents.push(new CanvasChartClip(this.model, this.services));
        }
        var titleAvailable = !!this.model.getOptions().title;
        var titleComponent = {
          id: "title",
          components: [new Title(this.model, this.services)],
          growth: LayoutGrowth.STRETCH
        };
        var toolbarComponent = {
          id: "toolbar",
          components: [new Toolbar(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var headerComponent = {
          id: "header",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays$f([
              titleComponent
            ], toolbarEnabled ? [toolbarComponent] : []), {
              direction: LayoutDirection.ROW,
              alignItems: LayoutAlignItems.CENTER
            })
          ],
          growth: LayoutGrowth.PREFERRED
        };
        var graphFrameComponent = {
          id: "graph-frame",
          components: graphFrameComponents,
          growth: LayoutGrowth.STRETCH,
          renderType: Tools.getProperty(configs, "graphFrameRenderType") || RenderTypes.SVG
        };
        var isLegendEnabled = Tools.getProperty(configs, "excludeLegend") !== true && options2.legend.enabled !== false;
        var fullFrameComponentDirection = LayoutDirection.COLUMN;
        if (isLegendEnabled) {
          var legendPosition = Tools.getProperty(options2, "legend", "position");
          if (legendPosition === "left") {
            fullFrameComponentDirection = LayoutDirection.ROW;
            if (!options2.legend.orientation) {
              options2.legend.orientation = LegendOrientations.VERTICAL;
            }
          } else if (legendPosition === "right") {
            fullFrameComponentDirection = LayoutDirection.ROW_REVERSE;
            if (!options2.legend.orientation) {
              options2.legend.orientation = LegendOrientations.VERTICAL;
            }
          } else if (legendPosition === "bottom") {
            fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
          }
        }
        var legendSpacerComponent = {
          id: "spacer",
          components: [new Spacer(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var fullFrameComponent = {
          id: "full-frame",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays$f(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
              graphFrameComponent
            ]), {
              direction: fullFrameComponentDirection
            })
          ],
          growth: LayoutGrowth.STRETCH
        };
        var topLevelLayoutComponents = [];
        if (titleAvailable || toolbarEnabled) {
          topLevelLayoutComponents.push(headerComponent);
          var titleSpacerComponent = {
            id: "spacer",
            components: [
              new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
            ],
            growth: LayoutGrowth.PREFERRED
          };
          topLevelLayoutComponents.push(titleSpacerComponent);
        }
        topLevelLayoutComponents.push(fullFrameComponent);
        return [
          new Tooltip(this.model, this.services),
          new Modal(this.model, this.services),
          new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
            direction: LayoutDirection.COLUMN
          })
        ];
      };
      return Chart2;
    }();
    __extends$D = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$e = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    ChartModelCartesian = function(_super) {
      __extends$D(ChartModelCartesian2, _super);
      function ChartModelCartesian2(services) {
        var _this = _super.call(this, services) || this;
        _this.axisFlavor = AxisFlavor.DEFAULT;
        return _this;
      }
      ChartModelCartesian2.prototype.assignRangeAndDomains = function() {
        var cartesianScales = this.services.cartesianScales;
        var options2 = this.getOptions();
        var isDualAxes = cartesianScales.isDualAxes();
        var scales = {
          primaryDomain: cartesianScales.domainAxisPosition,
          primaryRange: cartesianScales.rangeAxisPosition,
          secondaryDomain: null,
          secondaryRange: null
        };
        if (isDualAxes) {
          scales.secondaryDomain = cartesianScales.secondaryDomainAxisPosition;
          scales.secondaryRange = cartesianScales.secondaryRangeAxisPosition;
        }
        Object.keys(scales).forEach(function(scale) {
          var position = scales[scale];
          if (cartesianScales.scales[position]) {
            scales[scale] = {
              position,
              label: cartesianScales.getScaleLabel(position),
              identifier: Tools.getProperty(options2, "axes", position, "mapsTo")
            };
          } else {
            scales[scale] = null;
          }
        });
        return scales;
      };
      ChartModelCartesian2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var cartesianScales = this.services.cartesianScales;
        var _a22 = this.assignRangeAndDomains(), primaryDomain = _a22.primaryDomain, primaryRange = _a22.primaryRange, secondaryDomain = _a22.secondaryDomain, secondaryRange = _a22.secondaryRange;
        var domainScaleType = cartesianScales.getDomainAxisScaleType();
        var domainValueFormatter;
        if (domainScaleType === ScaleTypes.TIME) {
          domainValueFormatter = function(d) {
            return format2(d, "MMM d, yyyy");
          };
        }
        var result = __spreadArrays$e([
          __spreadArrays$e([
            "Group",
            primaryDomain.label,
            primaryRange.label
          ], secondaryDomain ? [secondaryDomain.label] : [], secondaryRange ? [secondaryRange.label] : [])
        ], displayData.map(function(datum2) {
          return __spreadArrays$e([
            datum2[groupMapsTo],
            datum2[primaryDomain.identifier] === null ? "&ndash;" : domainValueFormatter ? domainValueFormatter(datum2[primaryDomain.identifier]) : datum2[primaryDomain.identifier],
            datum2[primaryRange.identifier] === null || isNaN(datum2[primaryRange.identifier]) ? "&ndash;" : datum2[primaryRange.identifier].toLocaleString()
          ], secondaryDomain ? [
            datum2[secondaryDomain.identifier] === null ? "&ndash;" : datum2[secondaryDomain.identifier]
          ] : [], secondaryRange ? [
            datum2[secondaryRange.identifier] === null || isNaN(datum2[secondaryRange.identifier]) ? "&ndash;" : datum2[secondaryRange.identifier]
          ] : []);
        }));
        return result;
      };
      ChartModelCartesian2.prototype.setData = function(newData) {
        var data;
        if (newData) {
          data = _super.prototype.setData.call(this, newData);
          if (Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "enabled")) {
            var definedZoomBarData = Tools.getProperty(this.getOptions(), "zoomBar", AxisPositions.TOP, "data");
            this.setZoomBarData(definedZoomBarData);
          }
        }
        return data;
      };
      ChartModelCartesian2.prototype.setZoomBarData = function(newZoomBarData) {
        var sanitizedData = newZoomBarData ? this.sanitize(Tools.clone(newZoomBarData)) : this.getDisplayData();
        var zoomBarNormalizedValues = sanitizedData;
        var cartesianScales = this.services.cartesianScales;
        if (sanitizedData && cartesianScales.domainAxisPosition && cartesianScales.rangeAxisPosition) {
          var domainIdentifier_1 = cartesianScales.getDomainIdentifier();
          var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
          var allDates = sanitizedData.map(function(datum2) {
            return datum2[domainIdentifier_1].getTime();
          });
          allDates = Tools.removeArrayDuplicates(allDates).sort();
          zoomBarNormalizedValues = allDates.map(function(date2) {
            var sum2 = 0;
            var datum2 = {};
            sanitizedData.forEach(function(data) {
              if (data[domainIdentifier_1].getTime() === date2) {
                sum2 += data[rangeIdentifier_1];
              }
            });
            datum2[domainIdentifier_1] = new Date(date2);
            datum2[rangeIdentifier_1] = sum2;
            return datum2;
          });
        }
        this.set({ zoomBarData: zoomBarNormalizedValues });
      };
      ChartModelCartesian2.prototype.getZoomBarData = function() {
        return this.get("zoomBarData");
      };
      ChartModelCartesian2.prototype.sanitizeDateValues = function(data) {
        var options2 = this.getOptions();
        if (!options2.axes) {
          return data;
        }
        var keysToCheck = [];
        Object.keys(AxisPositions).forEach(function(axisPositionKey) {
          var axisPosition = AxisPositions[axisPositionKey];
          var axisOptions = options2.axes[axisPosition];
          if (axisOptions && axisOptions.scaleType === ScaleTypes.TIME) {
            var axisMapsTo = axisOptions.mapsTo;
            if (axisMapsTo !== null || axisMapsTo !== void 0) {
              keysToCheck.push(axisMapsTo);
            }
          }
        });
        if (keysToCheck.length > 0) {
          data.forEach(function(datum2) {
            keysToCheck.forEach(function(key2) {
              if (Tools.getProperty(datum2, key2, "getTime") === null) {
                datum2[key2] = new Date(datum2[key2]);
              }
            });
          });
        }
        return data;
      };
      ChartModelCartesian2.prototype.sanitize = function(data) {
        data = _super.prototype.sanitize.call(this, data);
        data = this.sanitizeDateValues(data);
        return data;
      };
      return ChartModelCartesian2;
    }(ChartModel);
    __extends$C = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$d = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    AxisChart = function(_super) {
      __extends$C(AxisChart2, _super);
      function AxisChart2(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.services = Object.assign(_this.services, {
          cartesianScales: CartesianScales,
          curves: Curves,
          zoom: Zoom
        });
        _this.model = new ChartModelCartesian(_this.services);
        return _this;
      }
      AxisChart2.prototype.getAxisChartComponents = function(graphFrameComponents, configs) {
        var options2 = this.model.getOptions();
        var isZoomBarEnabled = Tools.getProperty(options2, "zoomBar", AxisPositions.TOP, "enabled");
        var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
        this.services.cartesianScales.determineAxisDuality();
        this.services.cartesianScales.findDomainAndRangeAxes();
        this.services.cartesianScales.determineOrientation();
        var mainXAxisPosition = this.services.cartesianScales.getMainXAxisPosition();
        var mainXScaleType = Tools.getProperty(options2, "axes", mainXAxisPosition, "scaleType");
        var zoomBarEnabled = isZoomBarEnabled && mainXAxisPosition === AxisPositions.BOTTOM && mainXScaleType === ScaleTypes.TIME;
        var isZoomBarLocked = this.services.zoom.isZoomBarLocked(AxisPositions.TOP);
        var titleAvailable = !!this.model.getOptions().title;
        var titleComponent = {
          id: "title",
          components: [new Title(this.model, this.services)],
          growth: LayoutGrowth.STRETCH
        };
        var toolbarComponent = {
          id: "toolbar",
          components: [new Toolbar(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var headerComponent = {
          id: "header",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays$d([
              titleComponent
            ], toolbarEnabled ? [toolbarComponent] : []), {
              direction: LayoutDirection.ROW,
              alignItems: LayoutAlignItems.CENTER
            })
          ],
          growth: LayoutGrowth.PREFERRED
        };
        var legendComponent = {
          id: "legend",
          components: [new Legend(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        if (zoomBarEnabled && !isZoomBarLocked) {
          graphFrameComponents.push(new ChartClip(this.model, this.services), new ChartBrush(this.model, this.services));
        }
        graphFrameComponents.push(new Threshold(this.model, this.services));
        graphFrameComponents.push(new Highlight(this.model, this.services));
        var graphFrameComponent = {
          id: "graph-frame",
          components: graphFrameComponents,
          growth: LayoutGrowth.STRETCH,
          renderType: RenderTypes.SVG
        };
        var isLegendEnabled = Tools.getProperty(configs, "legend", "enabled") !== false && this.model.getOptions().legend.enabled !== false;
        var fullFrameComponentDirection = LayoutDirection.COLUMN;
        if (isLegendEnabled) {
          var legendPosition = Tools.getProperty(this.model.getOptions(), "legend", "position");
          if (legendPosition === LegendPositions.LEFT) {
            fullFrameComponentDirection = LayoutDirection.ROW;
            if (!this.model.getOptions().legend.orientation) {
              this.model.getOptions().legend.orientation = LegendOrientations.VERTICAL;
            }
          } else if (legendPosition === LegendPositions.RIGHT) {
            fullFrameComponentDirection = LayoutDirection.ROW_REVERSE;
            if (!this.model.getOptions().legend.orientation) {
              this.model.getOptions().legend.orientation = LegendOrientations.VERTICAL;
            }
          } else if (legendPosition === LegendPositions.BOTTOM) {
            fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
          }
        }
        var legendSpacerComponent = {
          id: "spacer",
          components: [new Spacer(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var fullFrameComponent = {
          id: "full-frame",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays$d(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
              graphFrameComponent
            ]), {
              direction: fullFrameComponentDirection
            })
          ],
          growth: LayoutGrowth.STRETCH
        };
        var zoomBarComponent = {
          id: "zoom-bar",
          components: [new ZoomBar(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED,
          renderType: RenderTypes.SVG
        };
        var topLevelLayoutComponents = [];
        if (titleAvailable || toolbarEnabled) {
          topLevelLayoutComponents.push(headerComponent);
          var titleSpacerComponent = {
            id: "spacer",
            components: [
              new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
            ],
            growth: LayoutGrowth.PREFERRED
          };
          topLevelLayoutComponents.push(titleSpacerComponent);
        }
        if (zoomBarEnabled) {
          topLevelLayoutComponents.push(zoomBarComponent);
        }
        topLevelLayoutComponents.push(fullFrameComponent);
        return [
          new AxisChartsTooltip(this.model, this.services),
          new Modal(this.model, this.services),
          new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
            direction: LayoutDirection.COLUMN
          })
        ];
      };
      return AxisChart2;
    }(Chart);
    __extends$B = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$B(AreaChart, _super);
      function AreaChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(Tools.clone(options.areaChart), chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      AreaChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Ruler(this.model, this.services),
          new Line(this.model, this.services),
          new Area(this.model, this.services),
          new Scatter(this.model, this.services, {
            fadeInOnChartHolderMouseover: true,
            handleThresholds: true
          }),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return AreaChart;
    })(AxisChart);
    __extends$A = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$A(StackedAreaChart, _super);
      function StackedAreaChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.stackedAreaChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      StackedAreaChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new StackedRuler(this.model, this.services),
          new StackedArea(this.model, this.services),
          new Line(this.model, this.services, { stacked: true }),
          new StackedScatter(this.model, this.services, {
            fadeInOnChartHolderMouseover: true,
            handleThresholds: true,
            stacked: true
          }),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return StackedAreaChart;
    })(AxisChart);
    __extends$z = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$z(SimpleBarChart, _super);
      function SimpleBarChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.simpleBarChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      SimpleBarChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new SimpleBar(this.model, this.services),
          new ZeroLine(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.VERT_OR_HORIZ
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return SimpleBarChart;
    })(AxisChart);
    __extends$y = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$y(GroupedBarChart, _super);
      function GroupedBarChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.groupedBarChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      GroupedBarChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new GroupedBar(this.model, this.services),
          new ZeroLine(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.VERT_OR_HORIZ
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return GroupedBarChart;
    })(AxisChart);
    __extends$x = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$x(StackedBarChart, _super);
      function StackedBarChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.stackedBarChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      StackedBarChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new StackedRuler(this.model, this.services),
          new StackedBar(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.VERT_OR_HORIZ
          }),
          new ZeroLine(this.model, this.services)
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return StackedBarChart;
    })(AxisChart);
    __extends$w = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$c = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    BoxplotChartModel = function(_super) {
      __extends$w(BoxplotChartModel2, _super);
      function BoxplotChartModel2(services) {
        return _super.call(this, services) || this;
      }
      BoxplotChartModel2.prototype.getBoxQuartiles = function(d) {
        return {
          q_25: quantile(d, 0.25),
          q_50: quantile(d, 0.5),
          q_75: quantile(d, 0.75)
        };
      };
      BoxplotChartModel2.prototype.getBoxplotData = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var groupedData = this.getGroupedData();
        var boxplotData = [];
        var _loop_1 = function(group2, data2) {
          var _a32;
          var rangeIdentifier = this_1.services.cartesianScales.getRangeIdentifier();
          var values = data2.map(function(d) {
            return d[rangeIdentifier];
          }).sort(ascending);
          var record = (_a32 = {}, _a32[groupMapsTo] = group2, _a32.counts = values, _a32.quartiles = this_1.getBoxQuartiles(values), _a32.outliers = null, _a32.whiskers = null, _a32);
          var q1 = record.quartiles.q_25;
          var q3 = record.quartiles.q_75;
          var iqr = (q3 - q1) * 1.5;
          var irq1 = q1 - iqr;
          var irq3 = q3 + iqr;
          var outliers = [];
          var normalValues = [];
          for (var _i2 = 0, values_1 = values; _i2 < values_1.length; _i2++) {
            var value2 = values_1[_i2];
            if (value2 < irq1) {
              outliers.push(value2);
            } else if (value2 > irq3) {
              outliers.push(value2);
            } else {
              normalValues.push(value2);
            }
          }
          record.outliers = outliers;
          var minNormalValue = min$3(normalValues);
          var maxNormalValue = max$3(normalValues);
          record.whiskers = {
            min: minNormalValue ? minNormalValue : min$3([
              record.quartiles.q_25,
              record.quartiles.q_50,
              record.quartiles.q_75
            ]),
            max: maxNormalValue ? maxNormalValue : max$3([
              record.quartiles.q_25,
              record.quartiles.q_50,
              record.quartiles.q_75
            ])
          };
          boxplotData.push(record);
        };
        var this_1 = this;
        for (var _i = 0, groupedData_1 = groupedData; _i < groupedData_1.length; _i++) {
          var _a22 = groupedData_1[_i], group = _a22.name, data = _a22.data;
          _loop_1(group, data);
        }
        return boxplotData;
      };
      BoxplotChartModel2.prototype.getTabularDataArray = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var boxplotData = this.getBoxplotData();
        var result = __spreadArrays$c([
          [
            "Group",
            "Minimum",
            "Q1",
            "Median",
            "Q3",
            "Maximum",
            "IQR",
            "Outlier(s)"
          ]
        ], boxplotData.map(function(datum2) {
          var outliers = Tools.getProperty(datum2, "outliers");
          if (outliers === null || outliers.length === 0) {
            outliers = ["&ndash;"];
          }
          return [
            datum2[groupMapsTo],
            Tools.getProperty(datum2, "whiskers", "min") !== null ? Tools.getProperty(datum2, "whiskers", "min").toLocaleString() : "&ndash;",
            Tools.getProperty(datum2, "quartiles", "q_25") !== null ? Tools.getProperty(datum2, "quartiles", "q_25").toLocaleString() : "&ndash;",
            Tools.getProperty(datum2, "quartiles", "q_50") !== null ? Tools.getProperty(datum2, "quartiles", "q_50").toLocaleString() : "&ndash;",
            Tools.getProperty(datum2, "quartiles", "q_75") !== null ? Tools.getProperty(datum2, "quartiles", "q_75").toLocaleString() : "&ndash;",
            Tools.getProperty(datum2, "whiskers", "max") !== null ? Tools.getProperty(datum2, "whiskers", "max").toLocaleString() : "&ndash;",
            Tools.getProperty(datum2, "quartiles", "q_75") !== null && Tools.getProperty(datum2, "quartiles", "q_25") !== null ? (Tools.getProperty(datum2, "quartiles", "q_75") - Tools.getProperty(datum2, "quartiles", "q_25")).toLocaleString() : "&ndash;",
            outliers.map(function(d) {
              return d.toLocaleString();
            }).join(",")
          ];
        }));
        return result;
      };
      BoxplotChartModel2.prototype.setColorClassNames = function() {
        var numberOfColors = 1;
        var colorPairingOptions = Tools.getProperty(this.getOptions(), "color", "pairing");
        var pairingOption = Tools.getProperty(colorPairingOptions, "option");
        var colorPairingCounts = color$1.pairingOptions;
        pairingOption = pairingOption <= colorPairingCounts[numberOfColors + "-color"] ? pairingOption : 1;
        var colorPairing = this.allDataGroups.map(function(dataGroup, index2) {
          return numberOfColors + "-" + pairingOption + "-1";
        });
        this.colorClassNames = ordinal().range(colorPairing).domain(this.allDataGroups);
      };
      return BoxplotChartModel2;
    }(ChartModelCartesian);
    __extends$v = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$v(BoxplotChart, _super);
      function BoxplotChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new BoxplotChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.boxplotChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      BoxplotChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Boxplot(this.model, this.services),
          new ZeroLine(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.VERT_OR_HORIZ
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents, {
          legend: {
            enabled: false
          }
        });
        return components;
      };
      return BoxplotChart;
    })(AxisChart);
    __extends$u = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$u(BubbleChart, _super);
      function BubbleChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.bubbleChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      BubbleChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Ruler(this.model, this.services),
          new Bubble(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return BubbleChart;
    })(AxisChart);
    __extends$t = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$b = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    BulletChartModel = function(_super) {
      __extends$t(BulletChartModel2, _super);
      function BulletChartModel2(services) {
        return _super.call(this, services) || this;
      }
      BulletChartModel2.prototype.getMatchingRangeIndexForDatapoint = function(datum2) {
        var matchingRangeIndex;
        for (var i2 = datum2.ranges.length - 1; i2 > 0; i2--) {
          var range2 = datum2.ranges[i2];
          if (datum2.value >= range2) {
            matchingRangeIndex = i2;
            return matchingRangeIndex;
          }
        }
        return 0;
      };
      BulletChartModel2.prototype.getTabularDataArray = function() {
        var _this = this;
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        var performanceAreaTitles = Tools.getProperty(options2, "bullet", "performanceAreaTitles");
        var result = __spreadArrays$b([
          ["Title", "Group", "Value", "Target", "Percentage", "Performance"]
        ], displayData.map(function(datum2) {
          return [
            datum2["title"],
            datum2[groupMapsTo],
            datum2["value"] === null ? "&ndash;" : datum2["value"],
            Tools.getProperty(datum2, "marker") === null ? "&ndash;" : datum2["marker"],
            Tools.getProperty(datum2, "marker") === null ? "&ndash;" : Math.floor(datum2[rangeIdentifier] / datum2.marker * 100) + "%",
            performanceAreaTitles[_this.getMatchingRangeIndexForDatapoint(datum2)]
          ];
        }));
        return result;
      };
      return BulletChartModel2;
    }(ChartModelCartesian);
    __extends$s = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$s(BulletChart, _super);
      function BulletChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new BulletChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.bulletChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      BulletChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Bullet(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return BulletChart;
    })(AxisChart);
    __extends$r = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$a = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    ChartModelBinned = function(_super) {
      __extends$r(ChartModelBinned2, _super);
      function ChartModelBinned2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ChartModelBinned2.prototype.getTabularDataArray = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var binnedStackedData = this.getBinnedStackedData();
        var result = __spreadArrays$a([
          __spreadArrays$a([
            get$3(options2, "bins.rangeLabel") || "Range"
          ], binnedStackedData.map(function(datum2) {
            return get$3(datum2, "0." + groupMapsTo);
          }))
        ], get$3(binnedStackedData, 0).map(function(d, i2) {
          return __spreadArrays$a([
            get$3(d, "data.x0") + " \u2013 " + get$3(d, "data.x1")
          ], binnedStackedData.map(function(datum2) {
            return get$3(datum2[i2], "data." + get$3(datum2[i2], groupMapsTo));
          }));
        }));
        return result;
      };
      return ChartModelBinned2;
    }(ChartModelCartesian);
    __extends$q = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$q(HistogramChart, _super);
      function HistogramChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new ChartModelBinned(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.histogramChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        _this.update();
        return _this;
      }
      HistogramChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new BinnedRuler(this.model, this.services),
          new Histogram(this.model, this.services)
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return HistogramChart;
    })(AxisChart);
    __extends$p = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    LineChart = function(_super) {
      __extends$p(LineChart2, _super);
      function LineChart2(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.lineChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      LineChart2.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Ruler(this.model, this.services),
          new Line(this.model, this.services),
          new Scatter(this.model, this.services, { handleThresholds: true }),
          new SkeletonLines(this.model, this.services),
          new ZeroLine(this.model, this.services)
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return LineChart2;
    }(AxisChart);
    __extends$o = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$o(LollipopChart, _super);
      function LollipopChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.lollipopChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      LollipopChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Ruler(this.model, this.services),
          new Lollipop(this.model, this.services),
          new Scatter(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return LollipopChart;
    })(AxisChart);
    __extends$n = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$n(ScatterChart, _super);
      function ScatterChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.scatterChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      ScatterChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Ruler(this.model, this.services),
          new Scatter(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return ScatterChart;
    })(AxisChart);
    __extends$m = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$9 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    PieChartModel = function(_super) {
      __extends$m(PieChartModel2, _super);
      function PieChartModel2(services) {
        return _super.call(this, services) || this;
      }
      PieChartModel2.prototype.getTabularData = function(data) {
        var tabularData = _super.prototype.getTabularData.call(this, data);
        if (data !== tabularData) {
          tabularData.forEach(function(d) {
            if (d.key && d.key !== d.group) {
              d.group = d.key;
            }
          });
        }
        return tabularData;
      };
      PieChartModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var result = __spreadArrays$9([
          ["Group", "Value"]
        ], displayData.map(function(datum2) {
          return [
            datum2[groupMapsTo],
            datum2["value"] === null ? "&ndash;" : datum2["value"].toLocaleString()
          ];
        }));
        return result;
      };
      PieChartModel2.prototype.sanitize = function(data) {
        var tabularData = this.getTabularData(data);
        return tabularData.sort(function(a, b) {
          return b.value - a.value;
        });
      };
      return PieChartModel2;
    }(ChartModel);
    __extends$l = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    PieChart = function(_super) {
      __extends$l(PieChart2, _super);
      function PieChart2(holder, chartConfigs, extending) {
        if (extending === void 0) {
          extending = false;
        }
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new PieChartModel(_this.services);
        if (extending) {
          return _this;
        }
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.pieChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      PieChart2.prototype.getComponents = function() {
        var graphFrameComponents = [
          new Pie(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.PIE
          })
        ];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return PieChart2;
    }(Chart);
    __extends$k = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$k(DonutChart, _super);
      function DonutChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs, true) || this;
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.donutChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      DonutChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new Donut(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.DONUT
          })
        ];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return DonutChart;
    })(PieChart);
    __extends$j = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$8 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    MeterChartModel = function(_super) {
      __extends$j(MeterChartModel2, _super);
      function MeterChartModel2(services) {
        return _super.call(this, services) || this;
      }
      MeterChartModel2.prototype.getMaximumDomain = function(data) {
        var max2 = data.reduce(function(accumulator, datum2) {
          return accumulator + datum2.value;
        }, 0);
        return max2;
      };
      MeterChartModel2.prototype.getFillColor = function(group) {
        var options2 = this.getOptions();
        var userProvidedScale = Tools.getProperty(options2, "color", "scale");
        var status = this.getStatus();
        if (userProvidedScale || !status) {
          return _super.prototype.getFillColor.call(this, group);
        } else {
          return null;
        }
      };
      MeterChartModel2.prototype.getStatus = function() {
        var options2 = this.getOptions();
        var dataValues = Tools.getProperty(this.getDisplayData());
        var totalValue = (dataValues ? dataValues.reduce(function(previous, current) {
          return { value: previous.value + current.value };
        }) : 0).value;
        var boundedValue = Tools.getProperty(options2, "meter", "proportional") ? totalValue : totalValue > 100 ? 100 : totalValue;
        var allRanges = Tools.getProperty(options2, "meter", "status", "ranges");
        if (allRanges) {
          var result = allRanges.filter(function(step) {
            return step.range[0] <= boundedValue && boundedValue <= step.range[1];
          });
          if (result.length > 0) {
            return result[0].status;
          }
        }
        return null;
      };
      MeterChartModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var status = this.getStatus();
        var proportional = Tools.getProperty(options2, "meter", "proportional");
        var result = [];
        var domainMax;
        if (proportional === null) {
          domainMax = 100;
          var datum2 = displayData[0];
          result = [
            __spreadArrays$8(["Group", "Value"], status ? ["Status"] : []),
            __spreadArrays$8([
              datum2[groupMapsTo],
              datum2["value"]
            ], status ? [status] : [])
          ];
        } else {
          var total = Tools.getProperty(proportional, "total");
          domainMax = total ? total : this.getMaximumDomain(displayData);
          result = __spreadArrays$8([
            ["Group", "Value", "Percentage of total"]
          ], displayData.map(function(datum3) {
            return [
              datum3[groupMapsTo],
              datum3["value"],
              (datum3["value"] / domainMax * 100).toFixed(2) + " %"
            ];
          }));
        }
        return result;
      };
      return MeterChartModel2;
    }(ChartModel);
    __extends$i = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign$1 = globalThis && globalThis.__assign || function() {
      __assign$1 = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign$1.apply(this, arguments);
    };
    Meter = function(_super) {
      __extends$i(Meter2, _super);
      function Meter2() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = "meter";
        _this.renderType = RenderTypes.SVG;
        return _this;
      }
      Meter2.prototype.getStackedBounds = function(data, scale) {
        var prevX = 0;
        var stackedData = data.map(function(d, i2) {
          if (i2 !== 0) {
            prevX += scale(d.value);
            return __assign$1(__assign$1({}, d), { width: Math.abs(scale(d.value) - meter.dividerWidth), x: prevX - scale(d.value) });
          } else {
            prevX = scale(d.value);
            return __assign$1(__assign$1({}, d), { width: Math.abs(scale(d.value) - meter.dividerWidth), x: 0 });
          }
        });
        return stackedData;
      };
      Meter2.prototype.render = function(animate) {
        var _this = this;
        if (animate === void 0) {
          animate = true;
        }
        var self2 = this;
        var svg = this.getComponentContainer();
        var options2 = this.getOptions();
        var proportional = Tools.getProperty(options2, "meter", "proportional");
        var data = this.model.getDisplayData();
        var status = this.model.getStatus();
        var width = DOMUtils.getSVGElementSize(svg, {
          useAttrs: true
        }).width;
        var groupMapsTo = options2.data.groupMapsTo;
        var domainMax;
        if (Tools.getProperty(options2, "meter", "proportional") === null) {
          domainMax = 100;
        } else {
          var total = Tools.getProperty(options2, "meter", "proportional", "total");
          domainMax = total ? total : this.model.getMaximumDomain(this.model.getDisplayData());
        }
        var xScale = linear().domain([0, domainMax]).range([0, width]);
        var stackedData = this.getStackedBounds(data, xScale);
        var userProvidedHeight = Tools.getProperty(options2, "meter", "height");
        DOMUtils.appendOrSelect(svg, "rect.container").attr("x", 0).attr("y", 0).attr("width", width).attr("height", userProvidedHeight ? userProvidedHeight : proportional ? meter.height.proportional : meter.height.default);
        DOMUtils.appendOrSelect(svg, "line.rangeIndicator").attr("x1", width).attr("x2", width).attr("y1", 0).attr("y2", userProvidedHeight ? userProvidedHeight : proportional ? meter.height.proportional : meter.height.default);
        var valued = svg.selectAll("rect.value").data(stackedData);
        var className = status != null && !self2.model.isUserProvidedColorScaleValid() && !proportional ? "value status--" + status : "value";
        valued.enter().append("rect").classed("value", true).merge(valued).attr("x", function(d) {
          return d.x;
        }).attr("y", 0).attr("height", function() {
          var userProvidedHeight2 = Tools.getProperty(options2, "meter", "height");
          return userProvidedHeight2 ? userProvidedHeight2 : proportional ? meter.height.proportional : meter.height.default;
        }).attr("class", function(d) {
          return _this.model.getColorClassName({
            classNameTypes: [ColorClassNameTypes.FILL],
            dataGroupName: d[groupMapsTo],
            originalClassName: className
          });
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "meter-bar-update",
            animate
          });
        }).attr("width", function(d, i2) {
          return d.value > domainMax ? xScale(domainMax) : d.width;
        }).style("fill", function(d) {
          return self2.model.getFillColor(d[groupMapsTo]);
        }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "value").attr("aria-label", function(d) {
          return d.value;
        });
        valued.exit().remove();
        var peakValue = Tools.getProperty(options2, "meter", "peak");
        var peakData = peakValue;
        if (peakValue !== null) {
          if (peakValue > domainMax) {
            peakData = domainMax;
          } else if (peakValue < data[0].value) {
            peakData = data[0].value > domainMax ? domainMax : data[0].value;
          }
        }
        var peak = svg.selectAll("line.peak").data(peakData == null ? [] : [peakData]);
        peak.enter().append("line").classed("peak", true).merge(peak).attr("y1", 0).attr("y2", function() {
          var userProvidedHeight2 = Tools.getProperty(options2, "meter", "height");
          return userProvidedHeight2 ? userProvidedHeight2 : proportional ? meter.height.proportional : meter.height.default;
        }).transition().call(function(t2) {
          return _this.services.transitions.setupTransition({
            transition: t2,
            name: "peak-line-update",
            animate
          });
        }).attr("x1", function(d) {
          return xScale(d);
        }).attr("x2", function(d) {
          return xScale(d);
        }).attr("role", Roles.GRAPHICS_SYMBOL).attr("aria-roledescription", "peak").attr("aria-label", function(d) {
          return d;
        });
        peak.exit().remove();
        this.services.domUtils.setSVGMaxHeight();
        this.addEventListeners();
      };
      Meter2.prototype.addEventListeners = function() {
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var self2 = this;
        var proportional = Tools.getProperty(options2, "meter", "proportional");
        this.parent.selectAll("rect.value").on("mouseover", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEOVER, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          if (proportional) {
            hoveredElement.classed("hovered", true);
            self2.services.events.dispatchEvent(Events$1.Tooltip.SHOW, {
              event,
              hoveredElement,
              items: [
                {
                  label: datum2[groupMapsTo],
                  value: datum2.value
                }
              ]
            });
          }
        }).on("mousemove", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEMOVE, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          if (proportional) {
            self2.services.events.dispatchEvent(Events$1.Tooltip.MOVE, {
              event
            });
          }
        }).on("click", function(event, datum2) {
          self2.services.events.dispatchEvent(Events$1.Meter.METER_CLICK, {
            event,
            element: select(this),
            datum: datum2
          });
        }).on("mouseout", function(event, datum2) {
          var hoveredElement = select(this);
          self2.services.events.dispatchEvent(Events$1.Meter.METER_MOUSEOUT, {
            event,
            element: hoveredElement,
            datum: datum2
          });
          if (proportional) {
            hoveredElement.classed("hovered", false);
            self2.services.events.dispatchEvent(Events$1.Tooltip.HIDE, {
              hoveredElement
            });
          }
        });
      };
      Meter2.prototype.destroy = function() {
        this.parent.selectAll("rect.value").on("mouseover", null).on("mousemove", null).on("mouseout", null).on("click", null);
      };
      return Meter2;
    }(Component);
    __extends$h = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$7 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    (function(_super) {
      __extends$h(MeterChart, _super);
      function MeterChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new MeterChartModel(_this.services);
        var options$1 = chartConfigs.options.meter.proportional ? Tools.merge(Tools.clone(options.proportionalMeterChart), chartConfigs.options) : Tools.merge(Tools.clone(options.meterChart), chartConfigs.options);
        _this.model.setOptions(options$1);
        _this.init(holder, chartConfigs);
        return _this;
      }
      MeterChart.prototype.getComponents = function() {
        var showLabels = Tools.getProperty(this.model.getOptions(), "meter", "showLabels");
        var meterComponents = __spreadArrays$7(showLabels ? [
          {
            id: "meter-title",
            components: [
              new MeterTitle(this.model, this.services)
            ],
            growth: LayoutGrowth.STRETCH,
            renderType: RenderTypes.SVG
          },
          {
            id: "spacer",
            components: [
              new Spacer(this.model, this.services, {
                size: 8
              })
            ],
            growth: LayoutGrowth.STRETCH
          }
        ] : [], [
          {
            id: "meter-graph",
            components: [new Meter(this.model, this.services)],
            growth: LayoutGrowth.STRETCH,
            renderType: RenderTypes.SVG
          }
        ]);
        var graphFrame = [
          new LayoutComponent(this.model, this.services, meterComponents, {
            direction: LayoutDirection.COLUMN
          })
        ];
        var components = this.getChartComponents(graphFrame, {
          graphFrameRenderType: RenderTypes.HTML
        });
        return components;
      };
      return MeterChart;
    })(Chart);
    __extends$g = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$6 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    RadarChartModel = function(_super) {
      __extends$g(RadarChartModel2, _super);
      function RadarChartModel2(services) {
        return _super.call(this, services) || this;
      }
      RadarChartModel2.prototype.getTabularDataArray = function() {
        var options2 = this.getOptions();
        var groupedData = this.getGroupedData();
        var _a22 = Tools.getProperty(options2, "radar", "axes"), angle = _a22.angle, value2 = _a22.value;
        var additionalHeaders = Tools.getProperty(groupedData, "0", "data").map(function(d) {
          return d[angle];
        });
        var result = __spreadArrays$6([
          __spreadArrays$6(["Group"], additionalHeaders)
        ], groupedData.map(function(datum2) {
          return __spreadArrays$6([
            datum2["name"]
          ], additionalHeaders.map(function(additionalHeader, i2) {
            return Tools.getProperty(datum2, "data", i2, value2) !== null ? Tools.getProperty(datum2, "data", i2, value2).toLocaleString() : "&ndash;";
          }));
        }));
        return result;
      };
      return RadarChartModel2;
    }(ChartModelCartesian);
    __extends$f = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$f(RadarChart, _super);
      function RadarChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new RadarChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.radarChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      RadarChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new Radar(this.model, this.services)
        ];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return RadarChart;
    })(Chart);
    __extends$e = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$5 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    GaugeChartModel = function(_super) {
      __extends$e(GaugeChartModel2, _super);
      function GaugeChartModel2(services) {
        return _super.call(this, services) || this;
      }
      GaugeChartModel2.prototype.getDataGroups = function() {
        return _super.prototype.getDataGroups.call(this).filter(function(item) {
          return item.name !== "delta";
        });
      };
      GaugeChartModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var result = __spreadArrays$5([
          ["Group", "Value"]
        ], displayData.map(function(datum2) {
          return [
            datum2[groupMapsTo],
            datum2["value"] === null ? "&ndash;" : datum2["value"].toLocaleString()
          ];
        }));
        return result;
      };
      return GaugeChartModel2;
    }(ChartModel);
    __extends$d = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    GaugeChart = function(_super) {
      __extends$d(GaugeChart2, _super);
      function GaugeChart2(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new GaugeChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.gaugeChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      GaugeChart2.prototype.getComponents = function() {
        var graphFrameComponents = [new Gauge(this.model, this.services)];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return GaugeChart2;
    }(Chart);
    __extends$c = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$4 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    graphComponentsMap = (_a4 = {}, _a4[ChartTypes.LINE] = [Line, Scatter], _a4[ChartTypes.SCATTER] = [Scatter], _a4[ChartTypes.AREA] = [Area, Line, Scatter], _a4[ChartTypes.STACKED_AREA] = [
      StackedArea,
      Line,
      StackedScatter,
      StackedRuler
    ], _a4[ChartTypes.SIMPLE_BAR] = [SimpleBar], _a4[ChartTypes.GROUPED_BAR] = [GroupedBar, ZeroLine], _a4[ChartTypes.STACKED_BAR] = [StackedBar, StackedRuler], _a4);
    (function(_super) {
      __extends$c(ComboChart, _super);
      function ComboChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        var chartOptions = Tools.mergeDefaultChartOptions(options.comboChart, chartConfigs.options);
        if (!chartConfigs.options.comboChartTypes) {
          console.error("No comboChartTypes defined for the Combo Chart!");
          chartOptions.comboChartTypes = [
            { type: ChartTypes.LINE, correspondingDatasets: [] }
          ];
        }
        _this.model.setOptions(chartOptions);
        _this.init(holder, chartConfigs);
        return _this;
      }
      ComboChart.prototype.getGraphComponents = function() {
        var _this = this;
        var comboChartTypes = this.model.getOptions().comboChartTypes;
        var counter = 0;
        var graphComponents = comboChartTypes.map(function(graph) {
          var type2 = graph.type;
          var options$1;
          if (typeof graph.type === "string") {
            if (!Object.keys(graphComponentsMap).includes(graph.type)) {
              console.error('Invalid chart type "' + graph.type + '" specified for combo chart. Please refer to the ComboChart tutorial for more guidance.');
              return null;
            }
            var stacked_1;
            options$1 = Tools.merge({}, options[Tools.camelCase(graph.type) + "Chart"], _this.model.getOptions(), graph.options);
            if (graph.type === ChartTypes.STACKED_AREA) {
              stacked_1 = true;
            }
            return graphComponentsMap[graph.type].map(function(Component2, i2) {
              return new Component2(_this.model, _this.services, {
                groups: graph.correspondingDatasets,
                id: counter++,
                options: options$1,
                stacked: stacked_1
              });
            });
          } else {
            options$1 = Tools.merge({}, _this.model.getOptions(), graph.options);
            return new type2(_this.model, _this.services, {
              groups: graph.correspondingDatasets,
              id: counter++,
              options: options$1
            });
          }
        }).filter(function(item) {
          return item !== null;
        });
        return Tools.flatten(graphComponents);
      };
      ComboChart.prototype.getComponents = function() {
        var comboChartTypes = this.model.getOptions().comboChartTypes;
        var stackedRulerEnabled = comboChartTypes.some(function(chartObject) {
          return chartObject.type === ChartTypes.STACKED_BAR || chartObject.type === ChartTypes.STACKED_AREA;
        });
        var graphFrameComponents = __spreadArrays$4([
          new TwoDimensionalAxes(this.model, this.services),
          new Grid(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.GRID
          })
        ], stackedRulerEnabled ? [] : [new Ruler(this.model, this.services)], this.getGraphComponents());
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return ComboChart;
    })(AxisChart);
    __extends$b = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    TreeChartModel = function(_super) {
      __extends$b(TreeChartModel2, _super);
      function TreeChartModel2(services) {
        return _super.call(this, services) || this;
      }
      TreeChartModel2.prototype.getTabularDataArray = function() {
        var _this = this;
        var displayData = this.getDisplayData();
        var result = [["Child", "Parent"]];
        displayData.forEach(function(datum2) {
          _this.getChildrenDatums(datum2, result);
          result.push([datum2.name, "&ndash;"]);
        });
        return result;
      };
      TreeChartModel2.prototype.getChildrenDatums = function(datum2, result) {
        var _this = this;
        if (result === void 0) {
          result = [];
        }
        if (datum2.children) {
          if (datum2.children.length > 0) {
            datum2.children.forEach(function(child) {
              _this.getChildrenDatums(child, result);
              result.push([child.name, datum2.name]);
            });
          }
        }
      };
      return TreeChartModel2;
    }(ChartModel);
    __extends$a = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$a(TreeChart, _super);
      function TreeChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new TreeChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.treeChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      TreeChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new Tree(this.model, this.services)
        ];
        var components = this.getChartComponents(graphFrameComponents, {
          excludeLegend: true
        });
        return components;
      };
      return TreeChart;
    })(Chart);
    __extends$9 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    TreemapChartModel = function(_super) {
      __extends$9(TreemapChartModel2, _super);
      function TreemapChartModel2(services) {
        return _super.call(this, services) || this;
      }
      TreemapChartModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var result = [["Child", "Group", "Value"]];
        displayData.forEach(function(datum2) {
          if (Array.isArray(datum2.children)) {
            datum2.children.forEach(function(child) {
              result.push([child.name, datum2.name, child.value]);
            });
          } else if (Tools.getProperty(datum2.name) !== null && Tools.getProperty(datum2.value)) {
            result.push(["\u2013", datum2.name, datum2.value]);
          }
        });
        return result;
      };
      return TreemapChartModel2;
    }(ChartModel);
    __extends$8 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$8(TreemapChart, _super);
      function TreemapChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new TreemapChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.treemapChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      TreemapChart.prototype.getComponents = function() {
        var graphFrameComponents = [new Treemap(this.model, this.services)];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return TreemapChart;
    })(Chart);
    __extends$7 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __assign = globalThis && globalThis.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s3, i2 = 1, n = arguments.length; i2 < n; i2++) {
          s3 = arguments[i2];
          for (var p in s3)
            if (Object.prototype.hasOwnProperty.call(s3, p))
              t2[p] = s3[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    CirclePackChartModel = function(_super) {
      __extends$7(CirclePackChartModel2, _super);
      function CirclePackChartModel2(services) {
        var _this = _super.call(this, services) || this;
        _this.parentNode = false;
        _this.set({ depth: 2 }, { skipUpdate: true });
        return _this;
      }
      CirclePackChartModel2.prototype.setData = function(newData) {
        _super.prototype.setData.call(this, newData);
        this.setDataGroups();
        if (newData.length === 1) {
          this.parentNode = true;
        }
        this.setZoom();
      };
      CirclePackChartModel2.prototype.setOptions = function(newOptions) {
        var options2 = this.getOptions();
        var zoomOptions = Tools.merge({}, newOptions, this.getZoomOptions(newOptions));
        Tools.updateLegendAdditionalItems(options2, zoomOptions);
        var depth = this.getHierarchyLevel();
        var userProvidedDepth = Tools.getProperty(options2, "circlePack", "hierarchyLevel");
        this.set({
          options: Tools.merge(options2, zoomOptions),
          depth: userProvidedDepth && userProvidedDepth < 4 ? userProvidedDepth : depth
        });
      };
      CirclePackChartModel2.prototype.getZoomOptions = function(options2) {
        if (!this.getDisplayData()) {
          return {};
        }
        var displayData = this.getDisplayData();
        var zoomOptions = options2 ? options2 : this.getOptions();
        var data = displayData.length === 1 && Tools.getProperty(displayData, 0, "children") ? Tools.getProperty(displayData, 0, "children") : displayData;
        var depth = this.getHierarchyLevel();
        data.some(function(datum2) {
          if (datum2.children) {
            if (datum2.children.some(function(item) {
              return item.children;
            })) {
              depth = 3;
              return false;
            }
          }
        });
        if (Tools.getProperty(zoomOptions, "canvasZoom", "enabled") === true && depth > 2) {
          return {
            legend: {
              additionalItems: [
                {
                  type: LegendItemType.ZOOM,
                  name: "Click to zoom"
                }
              ]
            }
          };
        }
        return null;
      };
      CirclePackChartModel2.prototype.setZoom = function(options2) {
        this.setOptions(this.getZoomOptions(options2));
      };
      CirclePackChartModel2.prototype.updateHierarchyLevel = function(depth) {
        this.set({ depth });
      };
      CirclePackChartModel2.prototype.getHierarchyLevel = function() {
        return this.get("depth");
      };
      CirclePackChartModel2.prototype.hasParentNode = function() {
        return this.parentNode;
      };
      CirclePackChartModel2.prototype.setDataGroups = function() {
        var _this = this;
        var data = this.getData();
        var options2 = this.getOptions();
        var groupMapsTo = options2.data.groupMapsTo;
        var newData = data.map(function(depthOne) {
          var groupName = depthOne[groupMapsTo];
          return _this.setChildrenDataGroup(depthOne, groupName);
        });
        this.set({
          data: newData
        }, { skipUpdate: true });
      };
      CirclePackChartModel2.prototype.setChildrenDataGroup = function(node, name) {
        var _this = this;
        if (node.children) {
          return __assign(__assign({}, node), { dataGroupName: name, children: node.children.map(function(child, i2) {
            return _this.setChildrenDataGroup(child, name);
          }) });
        } else {
          return __assign(__assign({}, node), { dataGroupName: name });
        }
      };
      CirclePackChartModel2.prototype.getTabularDataArray = function() {
        var _this = this;
        var displayData = this.getDisplayData();
        var result = [["Child", "Parent", "Value"]];
        displayData.forEach(function(datum2) {
          var value2 = datum2.value ? datum2.value : 0;
          if (datum2.children) {
            value2 += _this.getChildrenDatums(datum2.children, datum2.name, result, 0);
          }
          result.push(["&ndash;", datum2.name, value2]);
        });
        return result;
      };
      CirclePackChartModel2.prototype.getChildrenDatums = function(children2, parent, result, totalSum) {
        var _this = this;
        if (result === void 0) {
          result = [];
        }
        if (totalSum === void 0) {
          totalSum = 0;
        }
        var grandParent = parent;
        children2.forEach(function(child) {
          var parent2 = child.name;
          var sum2 = 0;
          if (child.children) {
            if (child.children.length > 0) {
              if (typeof child.value === "number") {
                totalSum += child.value;
              }
              sum2 += _this.getChildrenDatums(child.children, parent2, result, sum2);
              result.push([parent2, grandParent, sum2]);
              totalSum += sum2;
            }
          } else {
            var value2 = 0;
            if (typeof child.value === "number") {
              value2 = child.value;
              totalSum += child.value;
            }
            result.push([child.name, grandParent, value2]);
          }
        });
        return totalSum;
      };
      return CirclePackChartModel2;
    }(ChartModel);
    __extends$6 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$6(CirclePackChart, _super);
      function CirclePackChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new CirclePackChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.circlePackChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      CirclePackChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new CirclePack(this.model, this.services)
        ];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return CirclePackChart;
    })(Chart);
    __extends$5 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$3 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    WordCloudModel = function(_super) {
      __extends$5(WordCloudModel2, _super);
      function WordCloudModel2(services) {
        return _super.call(this, services) || this;
      }
      WordCloudModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var options2 = this.getOptions();
        var _a22 = options2.wordCloud, fontSizeMapsTo = _a22.fontSizeMapsTo, wordMapsTo = _a22.wordMapsTo;
        var groupMapsTo = options2.data.groupMapsTo;
        var result = __spreadArrays$3([
          [options2.tooltip.wordLabel, "Group", options2.tooltip.valueLabel]
        ], displayData.map(function(datum2) {
          return [
            datum2[wordMapsTo],
            datum2[groupMapsTo],
            datum2[fontSizeMapsTo]
          ];
        }));
        return result;
      };
      return WordCloudModel2;
    }(ChartModel);
    __extends$4 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$4(WordCloudChart, _super);
      function WordCloudChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new WordCloudModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.wordCloudChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      WordCloudChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new WordCloud(this.model, this.services),
          new Skeleton(this.model, this.services, {
            skeleton: Skeletons.PIE
          })
        ];
        var components = this.getChartComponents(graphFrameComponents);
        return components;
      };
      return WordCloudChart;
    })(Chart);
    __extends$3 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$2 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    AlluvialChartModel = function(_super) {
      __extends$3(AlluvialChartModel2, _super);
      function AlluvialChartModel2(services) {
        return _super.call(this, services) || this;
      }
      AlluvialChartModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        displayData.sort(function(a, b) {
          return a["source"].localeCompare(b["source"]);
        });
        var result = __spreadArrays$2([
          ["Source", "Target", "Value"]
        ], displayData.map(function(datum2) {
          return [
            datum2["source"],
            datum2["target"],
            datum2["value"]
          ];
        }));
        return result;
      };
      return AlluvialChartModel2;
    }(ChartModelCartesian);
    __extends$2 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    (function(_super) {
      __extends$2(AlluvialChart, _super);
      function AlluvialChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new AlluvialChartModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.alluvialChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      AlluvialChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new Alluvial(this.model, this.services)
        ];
        var components = this.getChartComponents(graphFrameComponents, {
          excludeLegend: true
        });
        return components;
      };
      return AlluvialChart;
    })(Chart);
    __extends$1 = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays$1 = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    HeatmapModel = function(_super) {
      __extends$1(HeatmapModel2, _super);
      function HeatmapModel2(services) {
        var _this = _super.call(this, services) || this;
        _this.axisFlavor = AxisFlavor.HOVERABLE;
        _this._colorScale = void 0;
        _this._domains = [];
        _this._ranges = [];
        _this._matrix = {};
        var axis2 = Tools.getProperty(_this.getOptions(), "axes");
        if (!!Tools.getProperty(axis2, "left", "scaleType") && Tools.getProperty(axis2, "left", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "right", "scaleType") && Tools.getProperty(axis2, "right", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "top", "scaleType") && Tools.getProperty(axis2, "top", "scaleType") !== ScaleTypes.LABELS || !!Tools.getProperty(axis2, "bottom", "scaleType") && Tools.getProperty(axis2, "bottom", "scaleType") !== ScaleTypes.LABELS) {
          throw Error("Heatmap only supports label scaletypes.");
        }
        return _this;
      }
      HeatmapModel2.prototype.getValueDomain = function() {
        var limits = extent(this.getDisplayData(), function(d) {
          return d.value;
        });
        var domain = linear().domain(limits).nice().domain();
        if (domain[0] > 0) {
          domain[0] = 0;
        }
        if (domain[0] < 0 && domain[1] > 0) {
          if (Math.abs(domain[0]) > domain[1]) {
            domain[1] = Math.abs(domain[0]);
          } else {
            domain[0] = -domain[1];
          }
        }
        return domain;
      };
      HeatmapModel2.prototype.getFillColor = function(value2) {
        return this._colorScale(value2);
      };
      HeatmapModel2.prototype.getUniqueDomain = function() {
        if (Tools.isEmpty(this._domains)) {
          var displayData = this.getDisplayData();
          var cartesianScales = this.services.cartesianScales;
          var domainIdentifier_1 = cartesianScales.getDomainIdentifier();
          var mainXAxisPosition = cartesianScales.getMainXAxisPosition();
          var customDomain = cartesianScales.getCustomDomainValuesByposition(mainXAxisPosition);
          if (!!customDomain) {
            return customDomain;
          }
          this._domains = Array.from(new Set(displayData.map(function(d) {
            return d[domainIdentifier_1];
          })));
        }
        return this._domains;
      };
      HeatmapModel2.prototype.getUniqueRanges = function() {
        if (Tools.isEmpty(this._ranges)) {
          var displayData = this.getDisplayData();
          var cartesianScales = this.services.cartesianScales;
          var rangeIdentifier_1 = cartesianScales.getRangeIdentifier();
          var mainYAxisPosition = cartesianScales.getMainYAxisPosition();
          var customDomain = cartesianScales.getCustomDomainValuesByposition(mainYAxisPosition);
          if (!!customDomain) {
            return customDomain;
          }
          this._ranges = Array.from(new Set(displayData.map(function(d) {
            return d[rangeIdentifier_1];
          })));
        }
        return this._ranges;
      };
      HeatmapModel2.prototype.getMatrix = function() {
        var _this = this;
        if (Tools.isEmpty(this._matrix)) {
          var uniqueDomain = this.getUniqueDomain();
          var uniqueRange = this.getUniqueRanges();
          var domainIdentifier_2 = this.services.cartesianScales.getDomainIdentifier();
          var rangeIdentifier_2 = this.services.cartesianScales.getRangeIdentifier();
          var range_1 = {};
          uniqueRange.forEach(function(ran) {
            range_1[ran] = {
              value: null,
              index: -1
            };
          });
          uniqueDomain.forEach(function(dom) {
            _this._matrix[dom] = Tools.clone(range_1);
          });
          this.getDisplayData().forEach(function(d, i2) {
            _this._matrix[d[domainIdentifier_2]][d[rangeIdentifier_2]] = {
              value: d["value"],
              index: i2
            };
          });
        }
        return this._matrix;
      };
      HeatmapModel2.prototype.setData = function(newData) {
        var sanitizedData = this.sanitize(Tools.clone(newData));
        var dataGroups = this.generateDataGroups(sanitizedData);
        this.set({
          data: sanitizedData,
          dataGroups
        });
        this._domains = [];
        this._ranges = [];
        this._matrix = {};
        return sanitizedData;
      };
      HeatmapModel2.prototype.getMatrixAsArray = function() {
        var _this = this;
        if (Tools.isEmpty(this._matrix)) {
          this.getMatrix();
        }
        var uniqueDomain = this.getUniqueDomain();
        var uniqueRange = this.getUniqueRanges();
        var domainIdentifier = this.services.cartesianScales.getDomainIdentifier();
        var rangeIdentifier = this.services.cartesianScales.getRangeIdentifier();
        var arr = [];
        uniqueDomain.forEach(function(domain) {
          uniqueRange.forEach(function(range2) {
            var element = {
              value: _this._matrix[domain][range2].value,
              index: _this._matrix[domain][range2].index
            };
            element[domainIdentifier] = domain;
            element[rangeIdentifier] = range2;
            arr.push(element);
          });
        });
        return arr;
      };
      HeatmapModel2.prototype.getTabularDataArray = function() {
        var displayData = this.getDisplayData();
        var _a22 = this.assignRangeAndDomains(), primaryDomain = _a22.primaryDomain, primaryRange = _a22.primaryRange;
        _a22.secondaryDomain;
        _a22.secondaryRange;
        var result = __spreadArrays$1([
          [primaryDomain.label, primaryRange.label, "Value"]
        ], displayData.map(function(datum2) {
          return [
            datum2[primaryDomain.identifier] === null ? "&ndash;" : datum2[primaryDomain.identifier],
            datum2[primaryRange.identifier] === null ? "&ndash;" : datum2[primaryRange.identifier].toLocaleString(),
            datum2["value"]
          ];
        }));
        return result;
      };
      HeatmapModel2.prototype.getColorClassName = function(configs) {
        return configs.originalClassName + " " + this._colorScale(configs.value);
      };
      HeatmapModel2.prototype.setColorClassNames = function() {
        var options2 = this.getOptions();
        var customColors = Tools.getProperty(options2, "color", "gradient", "colors");
        var customColorsEnabled = !Tools.isEmpty(customColors);
        var colorPairingOption = Tools.getProperty(options2, "color", "pairing", "option");
        var domain = this.getValueDomain();
        var colorScheme = domain[0] < 0 && domain[1] > 0 ? "diverge" : "mono";
        if (colorPairingOption < 1 && colorPairingOption > 4 && colorScheme === "mono") {
          colorPairingOption = 1;
        } else if (colorPairingOption < 1 && colorPairingOption > 2 && colorScheme === "diverge") {
          colorPairingOption = 1;
        }
        var colorPairing = customColorsEnabled ? customColors : [];
        if (!customColorsEnabled) {
          var colorGroupingLength = colorScheme === "diverge" ? 17 : 11;
          for (var i2 = 1; i2 < colorGroupingLength + 1; i2++) {
            colorPairing.push("fill-" + colorScheme + "-" + colorPairingOption + "-" + i2);
          }
        }
        this._colorScale = quantize().domain(this.getValueDomain()).range(colorPairing);
      };
      return HeatmapModel2;
    }(ChartModelCartesian);
    __extends = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (b2.hasOwnProperty(p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
      for (var s3 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k = 0, i2 = 0; i2 < il; i2++)
        for (var a = arguments[i2], j = 0, jl = a.length; j < jl; j++, k++)
          r2[k] = a[j];
      return r2;
    };
    (function(_super) {
      __extends(HeatmapChart, _super);
      function HeatmapChart(holder, chartConfigs) {
        var _this = _super.call(this, holder, chartConfigs) || this;
        _this.model = new HeatmapModel(_this.services);
        _this.model.setOptions(Tools.mergeDefaultChartOptions(options.heatmapChart, chartConfigs.options));
        _this.init(holder, chartConfigs);
        return _this;
      }
      HeatmapChart.prototype.getAxisChartComponents = function(graphFrameComponents, configs) {
        var options2 = this.model.getOptions();
        var toolbarEnabled = Tools.getProperty(options2, "toolbar", "enabled");
        this.services.cartesianScales.determineAxisDuality();
        this.services.cartesianScales.findDomainAndRangeAxes();
        this.services.cartesianScales.determineOrientation();
        var titleAvailable = !!this.model.getOptions().title;
        var titleComponent = {
          id: "title",
          components: [new Title(this.model, this.services)],
          growth: LayoutGrowth.STRETCH
        };
        var toolbarComponent = {
          id: "toolbar",
          components: [new Toolbar(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED
        };
        var headerComponent = {
          id: "header",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays([
              titleComponent
            ], toolbarEnabled ? [toolbarComponent] : []), {
              direction: LayoutDirection.ROW,
              alignItems: LayoutAlignItems.CENTER
            })
          ],
          growth: LayoutGrowth.PREFERRED
        };
        var legendComponent = {
          id: "legend",
          components: [new ColorScaleLegend(this.model, this.services)],
          growth: LayoutGrowth.PREFERRED,
          renderType: RenderTypes.SVG
        };
        var graphFrameComponent = {
          id: "graph-frame",
          components: graphFrameComponents,
          growth: LayoutGrowth.STRETCH,
          renderType: RenderTypes.SVG
        };
        var isLegendEnabled = Tools.getProperty(configs, "legend", "enabled") !== false && this.model.getOptions().legend.enabled !== false;
        var fullFrameComponentDirection = LayoutDirection.COLUMN_REVERSE;
        var legendSpacerComponent = {
          id: "spacer",
          components: [new Spacer(this.model, this.services, { size: 15 })],
          growth: LayoutGrowth.PREFERRED
        };
        var fullFrameComponent = {
          id: "full-frame",
          components: [
            new LayoutComponent(this.model, this.services, __spreadArrays(isLegendEnabled ? [legendComponent] : [], isLegendEnabled ? [legendSpacerComponent] : [], [
              graphFrameComponent
            ]), {
              direction: fullFrameComponentDirection
            })
          ],
          growth: LayoutGrowth.STRETCH
        };
        var topLevelLayoutComponents = [];
        if (titleAvailable || toolbarEnabled) {
          topLevelLayoutComponents.push(headerComponent);
          var titleSpacerComponent = {
            id: "spacer",
            components: [
              new Spacer(this.model, this.services, toolbarEnabled ? { size: 15 } : void 0)
            ],
            growth: LayoutGrowth.PREFERRED
          };
          topLevelLayoutComponents.push(titleSpacerComponent);
        }
        topLevelLayoutComponents.push(fullFrameComponent);
        return [
          new AxisChartsTooltip(this.model, this.services),
          new Modal(this.model, this.services),
          new LayoutComponent(this.model, this.services, topLevelLayoutComponents, {
            direction: LayoutDirection.COLUMN
          })
        ];
      };
      HeatmapChart.prototype.getComponents = function() {
        var graphFrameComponents = [
          new TwoDimensionalAxes(this.model, this.services),
          new Heatmap(this.model, this.services)
        ];
        var components = this.getAxisChartComponents(graphFrameComponents);
        return components;
      };
      return HeatmapChart;
    })(AxisChart);
    BaseChart = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["Chart", "chart", "data", "options", "id", "ref"]);
      let { Chart: Chart2 = void 0 } = $$props;
      let { chart: chart2 = null } = $$props;
      let { data = [] } = $$props;
      let { options: options2 = {} } = $$props;
      let { id: id2 = "chart-" + Math.random().toString(36) } = $$props;
      let { ref = null } = $$props;
      const dispatch2 = createEventDispatcher();
      if ($$props.Chart === void 0 && $$bindings.Chart && Chart2 !== void 0)
        $$bindings.Chart(Chart2);
      if ($$props.chart === void 0 && $$bindings.chart && chart2 !== void 0)
        $$bindings.chart(chart2);
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      if ($$props.options === void 0 && $$bindings.options && options2 !== void 0)
        $$bindings.options(options2);
      if ($$props.id === void 0 && $$bindings.id && id2 !== void 0)
        $$bindings.id(id2);
      if ($$props.ref === void 0 && $$bindings.ref && ref !== void 0)
        $$bindings.ref(ref);
      {
        if (chart2) {
          chart2.model.setData(data);
          chart2.model.setOptions(options2);
          dispatch2("update", { data, options: options2 });
        }
      }
      return `<div${spread([escape_object($$restProps), { id: escape_attribute_value(id2) }], {})}${add_attribute("this", ref, 0)}></div>`;
    });
    LineChart_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["chart", "ref"]);
      let { chart: chart2 = null } = $$props;
      let { ref = null } = $$props;
      if ($$props.chart === void 0 && $$bindings.chart && chart2 !== void 0)
        $$bindings.chart(chart2);
      if ($$props.ref === void 0 && $$bindings.ref && ref !== void 0)
        $$bindings.ref(ref);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(BaseChart, "BaseChart").$$render($$result, Object.assign($$restProps, { Chart: LineChart }, { ref }, { chart: chart2 }), {
          ref: ($$value) => {
            ref = $$value;
            $$settled = false;
          },
          chart: ($$value) => {
            chart2 = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      return $$rendered;
    });
    GaugeChart_1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $$restProps = compute_rest_props($$props, ["chart", "ref"]);
      let { chart: chart2 = null } = $$props;
      let { ref = null } = $$props;
      if ($$props.chart === void 0 && $$bindings.chart && chart2 !== void 0)
        $$bindings.chart(chart2);
      if ($$props.ref === void 0 && $$bindings.ref && ref !== void 0)
        $$bindings.ref(ref);
      let $$settled;
      let $$rendered;
      do {
        $$settled = true;
        $$rendered = `${validate_component(BaseChart, "BaseChart").$$render($$result, Object.assign($$restProps, { Chart: GaugeChart }, { ref }, { chart: chart2 }), {
          ref: ($$value) => {
            ref = $$value;
            $$settled = false;
          },
          chart: ($$value) => {
            chart2 = $$value;
            $$settled = false;
          }
        }, {})}`;
      } while (!$$settled);
      return $$rendered;
    });
    Dashboard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      return `${$$result.head += `${$$result.title = `<title>Dashboard</title>`, ""}`, ""}

<section><div class="${"bg-white shadow overflow-hidden sm:rounded-lg mb-3"}"><div class="${"px-4 py-5 sm:px-6"}"><svg class="${"w-6 h-6 dark:text-black"}" fill="${"none"}" stroke="${"currentColor"}" viewBox="${"0 0 24 24"}" xmlns="${"http://www.w3.org/2000/svg"}"><path stroke-linecap="${"round"}" stroke-linejoin="${"round"}" stroke-width="${"2"}" d="${"M10 19l-7-7m0 0l7-7m-7 7h18"}"></path></svg>

		<h3 class="${"text-lg leading-6 font-medium text-gray-900"}">ESCA</h3>
		<p class="${"mt-1 max-w-2xl text-sm text-gray-500"}">Personal details and application.</p></div></div>

<div class="${"relative overflow-x-auto shadow-md sm:rounded-lg"}"><div class="${"m-5"}"><div class="${"grid grid-cols-1 md:grid-cols-3 gap-4"}"><div>${validate_component(GaugeChart_1, "GaugeChart").$$render($$result, {
        data: [{ "group": "value", "value": 67 }],
        options: {
          "title": "CPU",
          "resizable": true,
          "height": "250px",
          "gauge": { "type": "full", "alignment": "center" },
          "color": { "scale": { "value": "#0C5DD8" } }
        }
      }, {}, {})}
				<p class="${"mt-5 text-sm text-center"}">67 of 100 used</p></div>
			<div>${validate_component(GaugeChart_1, "GaugeChart").$$render($$result, {
        data: [{ "group": "value", "value": 67 }],
        options: {
          "title": "RAM",
          "resizable": true,
          "height": "250px",
          "gauge": { "type": "full", "alignment": "center" },
          "color": { "scale": { "value": "#12CFEA" } }
        }
      }, {}, {})}
					<p class="${"mt-5 text-sm text-center"}">67 of 100 used</p></div>
			<div>${validate_component(GaugeChart_1, "GaugeChart").$$render($$result, {
        data: [{ "group": "value", "value": 67 }],
        options: {
          "title": "HDD",
          "resizable": true,
          "height": "250px",
          "gauge": { "type": "full", "alignment": "center" },
          "color": { "scale": { "value": "#FAE737" } }
        }
      }, {}, {})}
					<p class="${"mt-5 text-sm text-center"}">67 of 100 used</p></div></div></div></div>

<div class="${"relative overflow-x-auto shadow-md sm:rounded-lg"}"><div class="${"p-5"}">${validate_component(LineChart_1, "LineChart").$$render($$result, {
        data: [
          {
            "group": "Legend 1",
            "date": "2018-12-31T15:00:00.000Z",
            "temp": 23
          },
          {
            "group": "Legend 1",
            "date": "2019-01-31T15:00:00.000Z",
            "temp": 15
          },
          {
            "group": "Legend 1",
            "date": "2019-02-28T15:00:00.000Z",
            "temp": 24
          },
          {
            "group": "Legend 1",
            "date": "2019-03-31T15:00:00.000Z",
            "temp": 33
          },
          {
            "group": "Legend 1",
            "date": "2019-04-30T15:00:00.000Z",
            "temp": 23
          },
          {
            "group": "Legend 1",
            "date": "2019-05-31T15:00:00.000Z",
            "temp": 32
          },
          {
            "group": "Legend 1",
            "date": "2019-06-30T15:00:00.000Z",
            "temp": 23
          },
          {
            "group": "Legend 2",
            "date": "2018-12-31T15:00:00.000Z",
            "rainfall": 50
          },
          {
            "group": "Legend 2",
            "date": "2019-01-31T15:00:00.000Z",
            "rainfall": 65
          },
          {
            "group": "Legend 2",
            "date": "2019-02-28T15:00:00.000Z",
            "rainfall": 35
          },
          {
            "group": "Legend 2",
            "date": "2019-03-31T15:00:00.000Z",
            "rainfall": 43
          },
          {
            "group": "Legend 2",
            "date": "2019-04-30T15:00:00.000Z",
            "rainfall": 53
          },
          {
            "group": "Legend 2",
            "date": "2019-05-31T15:00:00.000Z",
            "rainfall": 19
          },
          {
            "group": "Legend 2",
            "date": "2019-06-30T15:00:00.000Z",
            "rainfall": 13
          }
        ],
        options: {
          "title": "Resource allocation over time",
          "axes": {
            "left": { "title": "Legend 1", "mapsTo": "temp" },
            "bottom": {
              "scaleType": "time",
              "mapsTo": "date",
              "title": "Date"
            },
            "right": {
              "title": "Legend 2",
              "mapsTo": "rainfall",
              "correspondingDatasets": ["Legend 2"]
            }
          },
          "curve": "curveMonotoneX",
          "height": "400px"
        }
      }, {}, {})}</div></div>
	
</section>`;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports3 = {};
__export(__exports3, {
  css: () => css4,
  entry: () => entry3,
  js: () => js3,
  module: () => dashboard_svelte_exports
});
var entry3, js3, css4;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_dashboard_svelte();
    entry3 = "pages/dashboard.svelte-48925f6e.js";
    js3 = ["pages/dashboard.svelte-48925f6e.js", "chunks/vendor-117ed6ab.js"];
    css4 = ["assets/pages/dashboard.svelte-21f80fed.css"];
  }
});

// .svelte-kit/vercel-tmp/entry.js
var entry_exports = {};
__export(entry_exports, {
  default: () => entry_default
});
module.exports = __toCommonJS(entry_exports);

// .svelte-kit/vercel-tmp/shims.js
init_install_fetch();
installFetch();

// node_modules/@sveltejs/kit/dist/node.js
var import_stream = require("stream");
function get_raw_body(req) {
  return new Promise((fulfil, reject) => {
    const h2 = req.headers;
    if (!h2["content-type"]) {
      return fulfil(null);
    }
    req.on("error", reject);
    const length = Number(h2["content-length"]);
    if (isNaN(length) && h2["transfer-encoding"] == null) {
      return fulfil(null);
    }
    let data = new Uint8Array(length || 0);
    if (length > 0) {
      let offset = 0;
      req.on("data", (chunk) => {
        const new_len = offset + Buffer.byteLength(chunk);
        if (new_len > length) {
          return reject({
            status: 413,
            reason: 'Exceeded "Content-Length" limit'
          });
        }
        data.set(chunk, offset);
        offset = new_len;
      });
    } else {
      req.on("data", (chunk) => {
        const new_data = new Uint8Array(data.length + chunk.length);
        new_data.set(data, 0);
        new_data.set(chunk, data.length);
        data = new_data;
      });
    }
    req.on("end", () => {
      fulfil(data);
    });
  });
}
async function getRequest(base2, req) {
  let headers = req.headers;
  if (req.httpVersionMajor === 2) {
    headers = Object.assign({}, headers);
    delete headers[":method"];
    delete headers[":path"];
    delete headers[":authority"];
    delete headers[":scheme"];
  }
  return new Request(base2 + req.url, {
    method: req.method,
    headers,
    body: await get_raw_body(req)
  });
}
async function setResponse(res, response) {
  const headers = Object.fromEntries(response.headers);
  if (response.headers.has("set-cookie")) {
    headers["set-cookie"] = response.headers.raw()["set-cookie"];
  }
  res.writeHead(response.status, headers);
  if (response.body instanceof import_stream.Readable) {
    response.body.pipe(res);
  } else {
    if (response.body) {
      res.write(await response.arrayBuffer());
    }
    res.end();
  }
}

// .svelte-kit/output/server/index.js
init_index_a93c14e4();
var import_cookie2 = __toESM(require_cookie(), 1);
init_dist();
var __accessCheck2 = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet2 = (obj, member, getter) => {
  __accessCheck2(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd2 = (obj, member, value2) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
};
var __privateSet2 = (obj, member, value2, setter) => {
  __accessCheck2(obj, member, "write to private field");
  setter ? setter.call(obj, value2) : member.set(obj, value2);
  return value2;
};
var _use_hashes;
var _dev;
var _script_needs_csp;
var _style_needs_csp;
var _directives;
var _script_src;
var _style_src;
function afterUpdate() {
}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  {
    stores.page.set(page);
  }
  return `


${components[1] ? `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => {
      return `${components[2] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
        default: () => {
          return `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
        }
      })}` : `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {})}`}`;
    }
  })}` : `${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {})}`}

${``}`;
});
function to_headers(object2) {
  const headers = new Headers();
  if (object2) {
    for (const key2 in object2) {
      const value2 = object2[key2];
      if (!value2)
        continue;
      if (Array.isArray(value2)) {
        value2.forEach((value22) => {
          headers.append(key2, value22);
        });
      } else {
        headers.set(key2, value2);
      }
    }
  }
  return headers;
}
function hash(value2) {
  let hash2 = 5381;
  let i2 = value2.length;
  if (typeof value2 === "string") {
    while (i2)
      hash2 = hash2 * 33 ^ value2.charCodeAt(--i2);
  } else {
    while (i2)
      hash2 = hash2 * 33 ^ value2[--i2];
  }
  return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key2 in obj) {
    clone2[key2.toLowerCase()] = obj[key2];
  }
  return clone2;
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = params[key2].replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
  }
  return params;
}
function is_pojo(body) {
  if (typeof body !== "object")
    return false;
  if (body) {
    if (body instanceof Uint8Array)
      return false;
    if (body._readableState && typeof body.pipe === "function")
      return false;
    if (typeof ReadableStream !== "undefined" && body instanceof ReadableStream)
      return false;
  }
  return true;
}
function normalize_request_method(event) {
  const method = event.request.method.toLowerCase();
  return method === "delete" ? "del" : method;
}
function error(body) {
  return new Response(body, {
    status: 500
  });
}
function is_string(s22) {
  return typeof s22 === "string" || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
  "application/xml",
  "application/json",
  "application/x-www-form-urlencoded",
  "multipart/form-data"
]);
function is_text(content_type) {
  if (!content_type)
    return true;
  const type2 = content_type.split(";")[0].toLowerCase();
  return type2.startsWith("text/") || type2.endsWith("+xml") || text_types.has(type2);
}
async function render_endpoint(event, mod2) {
  const method = normalize_request_method(event);
  let handler = mod2[method];
  if (!handler && method === "head") {
    handler = mod2.get;
  }
  if (!handler) {
    return event.request.headers.get("x-sveltekit-load") ? new Response(void 0, {
      status: 204
    }) : new Response("Method not allowed", {
      status: 405
    });
  }
  const response = await handler(event);
  const preface = `Invalid response from route ${event.url.pathname}`;
  if (typeof response !== "object") {
    return error(`${preface}: expected an object, got ${typeof response}`);
  }
  if (response.fallthrough) {
    throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
  }
  const { status = 200, body = {} } = response;
  const headers = response.headers instanceof Headers ? new Headers(response.headers) : to_headers(response.headers);
  const type2 = headers.get("content-type");
  if (!is_text(type2) && !(body instanceof Uint8Array || is_string(body))) {
    return error(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if (is_pojo(body) && (!type2 || type2.startsWith("application/json"))) {
    headers.set("content-type", "application/json; charset=utf-8");
    normalized_body = JSON.stringify(body);
  } else {
    normalized_body = body;
  }
  if ((typeof normalized_body === "string" || normalized_body instanceof Uint8Array) && !headers.has("etag")) {
    const cache_control = headers.get("cache-control");
    if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
      headers.set("etag", `"${hash(normalized_body)}"`);
    }
  }
  return new Response(method !== "head" ? normalized_body : void 0, {
    status,
    headers
  });
}
var chars$1 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value2) {
  var counts = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type2 = getType(thing);
      switch (type2) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key2) {
            return walk(thing[key2]);
          });
      }
    }
  }
  walk(value2);
  var names = /* @__PURE__ */ new Map();
  Array.from(counts).filter(function(entry4) {
    return entry4[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry4, i2) {
    names.set(entry4[0], getName(i2));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type2 = getType(thing);
    switch (type2) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i2) {
          return i2 in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type2 + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key2) {
          return safeKey(key2) + ":" + stringify(thing[key2]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value2);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type2 = getType(thing);
      switch (type2) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i2) {
            statements_1.push(name + "[" + i2 + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function(_a5) {
            var k = _a5[0], v = _a5[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key2) {
            statements_1.push("" + name + safeProp(key2) + "=" + stringify(thing[key2]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = "";
  do {
    name = chars$1[num % chars$1.length] + name;
    num = ~~(num / chars$1.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped2[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escapeUnsafeChars(JSON.stringify(key2));
}
function safeProp(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? "." + key2 : "[" + escapeUnsafeChars(JSON.stringify(key2)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i2 = 0; i2 < str.length; i2 += 1) {
    var char = str.charAt(i2);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped2) {
      result += escaped2[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i2 + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i2];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop2() {
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue = [];
function readable(value2, start2) {
  return {
    subscribe: writable(value2, start2).subscribe
  };
}
function writable(value2, start2 = noop2) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value2, new_value)) {
      value2 = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value2);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set2(fn(value2));
  }
  function subscribe(run2, invalidate = noop2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start2(set2) || noop2;
    }
    run2(value2);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update, subscribe };
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var render_json_payload_script_regex = new RegExp(`[${Object.keys(render_json_payload_script_dict).join("")}]`, "g");
function render_json_payload_script(attrs, payload) {
  const safe_payload = JSON.stringify(payload).replace(render_json_payload_script_regex, (match2) => render_json_payload_script_dict[match2]);
  let safe_attrs = "";
  for (const [key2, value2] of Object.entries(attrs)) {
    if (value2 === void 0)
      continue;
    safe_attrs += ` sveltekit:data-${key2}=${escape_html_attr(value2)}`;
  }
  return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(`[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`, "g");
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match2) => {
    if (match2.length === 2) {
      return match2;
    }
    return escape_html_attr_dict[match2] ?? `&#${match2.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
function create_prerendering_url_proxy(url) {
  return new Proxy(url, {
    get: (target, prop, receiver) => {
      if (prop === "search" || prop === "searchParams") {
        throw new Error(`Cannot access url.${prop} on a page with prerendering enabled`);
      }
      return Reflect.get(target, prop, receiver);
    }
  });
}
var encoder = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array2 = encode(data);
  for (let i2 = 0; i2 < array2.length; i2 += 16) {
    const w = array2.subarray(i2, i2 + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i22 = 0; i22 < 64; i22++) {
      if (i22 < 16) {
        tmp = w[i22];
      } else {
        a = w[i22 + 1 & 15];
        b = w[i22 + 14 & 15];
        tmp = w[i22 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i22 & 15] + w[i22 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i22];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x3) {
    return (x3 - Math.floor(x3)) * 4294967296;
  }
  let prime = 2;
  for (let i2 = 0; i2 < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i2 < 8) {
        init[i2] = frac(prime ** (1 / 2));
      }
      key[i2] = frac(prime ** (1 / 3));
      i2++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i2 = 0; i2 < bytes.length; i2 += 4) {
    const a = bytes[i2 + 0];
    const b = bytes[i2 + 1];
    const c = bytes[i2 + 2];
    const d = bytes[i2 + 3];
    bytes[i2 + 0] = d;
    bytes[i2 + 1] = c;
    bytes[i2 + 2] = b;
    bytes[i2 + 3] = a;
  }
}
function encode(str) {
  const encoded = encoder.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words2 = new Uint32Array(bytes.buffer);
  words2[words2.length - 2] = Math.floor(length / 4294967296);
  words2[words2.length - 1] = length;
  return words2;
}
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l = bytes.length;
  let result = "";
  let i2;
  for (i2 = 2; i2 < l; i2 += 3) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2 | bytes[i2] >> 6];
    result += chars[bytes[i2] & 63];
  }
  if (i2 === l + 1) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4];
    result += "==";
  }
  if (i2 === l) {
    result += chars[bytes[i2 - 2] >> 2];
    result += chars[(bytes[i2 - 2] & 3) << 4 | bytes[i2 - 1] >> 4];
    result += chars[(bytes[i2 - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var csp_ready;
var generate_nonce;
var generate_hash;
if (typeof crypto !== "undefined") {
  const array2 = new Uint8Array(16);
  generate_nonce = () => {
    crypto.getRandomValues(array2);
    return base64(array2);
  };
  generate_hash = sha256;
} else {
  const name = "crypto";
  csp_ready = import(name).then((crypto2) => {
    generate_nonce = () => {
      return crypto2.randomBytes(16).toString("base64");
    };
    generate_hash = (input) => {
      return crypto2.createHash("sha256").update(input, "utf-8").digest().toString("base64");
    };
  });
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
  constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
    __privateAdd2(this, _use_hashes, void 0);
    __privateAdd2(this, _dev, void 0);
    __privateAdd2(this, _script_needs_csp, void 0);
    __privateAdd2(this, _style_needs_csp, void 0);
    __privateAdd2(this, _directives, void 0);
    __privateAdd2(this, _script_src, void 0);
    __privateAdd2(this, _style_src, void 0);
    __privateSet2(this, _use_hashes, mode === "hash" || mode === "auto" && prerender);
    __privateSet2(this, _directives, dev ? __spreadValues({}, directives) : directives);
    __privateSet2(this, _dev, dev);
    const d = __privateGet2(this, _directives);
    if (dev) {
      const effective_style_src2 = d["style-src"] || d["default-src"];
      if (effective_style_src2 && !effective_style_src2.includes("unsafe-inline")) {
        d["style-src"] = [...effective_style_src2, "unsafe-inline"];
      }
    }
    __privateSet2(this, _script_src, []);
    __privateSet2(this, _style_src, []);
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    __privateSet2(this, _script_needs_csp, !!effective_script_src && effective_script_src.filter((value2) => value2 !== "unsafe-inline").length > 0);
    __privateSet2(this, _style_needs_csp, !dev && !!effective_style_src && effective_style_src.filter((value2) => value2 !== "unsafe-inline").length > 0);
    this.script_needs_nonce = __privateGet2(this, _script_needs_csp) && !__privateGet2(this, _use_hashes);
    this.style_needs_nonce = __privateGet2(this, _style_needs_csp) && !__privateGet2(this, _use_hashes);
    if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
      this.nonce = generate_nonce();
    }
  }
  add_script(content) {
    if (__privateGet2(this, _script_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _script_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _script_src).length === 0) {
        __privateGet2(this, _script_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  add_style(content) {
    if (__privateGet2(this, _style_needs_csp)) {
      if (__privateGet2(this, _use_hashes)) {
        __privateGet2(this, _style_src).push(`sha256-${generate_hash(content)}`);
      } else if (__privateGet2(this, _style_src).length === 0) {
        __privateGet2(this, _style_src).push(`nonce-${this.nonce}`);
      }
    }
  }
  get_header(is_meta = false) {
    const header = [];
    const directives = __spreadValues({}, __privateGet2(this, _directives));
    if (__privateGet2(this, _style_src).length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _style_src)
      ];
    }
    if (__privateGet2(this, _script_src).length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...__privateGet2(this, _script_src)
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value2 = directives[key2];
      if (!value2)
        continue;
      const directive = [key2];
      if (Array.isArray(value2)) {
        value2.forEach((value22) => {
          if (quoted.has(value22) || crypto_pattern.test(value22)) {
            directive.push(`'${value22}'`);
          } else {
            directive.push(value22);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
  get_meta() {
    const content = escape_html_attr(this.get_header(true));
    return `<meta http-equiv="content-security-policy" content=${content}>`;
  }
};
_use_hashes = /* @__PURE__ */ new WeakMap();
_dev = /* @__PURE__ */ new WeakMap();
_script_needs_csp = /* @__PURE__ */ new WeakMap();
_style_needs_csp = /* @__PURE__ */ new WeakMap();
_directives = /* @__PURE__ */ new WeakMap();
_script_src = /* @__PURE__ */ new WeakMap();
_style_src = /* @__PURE__ */ new WeakMap();
var updated = __spreadProps(__spreadValues({}, readable(false)), {
  check: () => false
});
async function render_response({
  branch,
  options: options2,
  state,
  $session,
  page_config,
  status,
  error: error2 = null,
  event,
  resolve_opts,
  stuff
}) {
  if (state.prerender) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %svelte.nonce%");
    }
  }
  const stylesheets = new Set(options2.manifest._.entry.css);
  const modulepreloads = new Set(options2.manifest._.entry.js);
  const styles = /* @__PURE__ */ new Map();
  const serialized_data = [];
  let shadow_props;
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (resolve_opts.ssr) {
    branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => stylesheets.add(url));
      if (node.js)
        node.js.forEach((url) => modulepreloads.add(url));
      if (node.styles)
        Object.entries(node.styles).forEach(([k, v]) => styles.set(k, v));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (props2)
        shadow_props = props2;
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable($session);
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        session,
        updated
      },
      page: {
        error: error2,
        params: event.params,
        routeId: event.routeId,
        status,
        stuff,
        url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url
      },
      components: branch.map(({ node }) => node.module.default)
    };
    const print_error = (property2, replacement) => {
      Object.defineProperty(props.page, property2, {
        get: () => {
          throw new Error(`$page.${property2} has been replaced by $page.url.${replacement}`);
        }
      });
    };
    print_error("origin", "origin");
    print_error("path", "pathname");
    print_error("query", "searchParams");
    for (let i2 = 0; i2 < branch.length; i2 += 1) {
      props[`props_${i2}`] = await branch[i2].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let { head, html: body } = rendered;
  const inlined_style = Array.from(styles.values()).join("\n");
  await csp_ready;
  const csp = new Csp(options2.csp, {
    dev: options2.dev,
    prerender: !!state.prerender,
    needs_nonce: options2.template_contains_nonce
  });
  const target = hash(body);
  const init_app = `
		import { start } from ${s2(options2.prefix + options2.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-hydrate="${target}"]').parentNode,
			paths: ${s2(options2.paths)},
			session: ${try_serialize($session, (error3) => {
    throw new Error(`Failed to serialize session data: ${error3.message}`);
  })},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options2.trailing_slash)},
			hydrate: ${resolve_opts.ssr && page_config.hydrate ? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [
					${(branch || []).map(({ node }) => `import(${s2(options2.prefix + node.entry)})`).join(",\n						")}
				],
				params: ${devalue(event.params)},
				routeId: ${s2(event.routeId)}
			}` : "null"}
		});
	`;
  const init_service_worker = `
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker.register('${options2.service_worker}');
		}
	`;
  if (options2.amp) {
    const styles2 = `${inlined_style}
${rendered.css.code}`;
    head += `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>

		<style amp-custom>${styles2}</style>`;
    if (options2.service_worker) {
      head += '<script async custom-element="amp-install-serviceworker" src="https://cdn.ampproject.org/v0/amp-install-serviceworker-0.1.js"><\/script>';
      body += `<amp-install-serviceworker src="${options2.service_worker}" layout="nodisplay"></amp-install-serviceworker>`;
    }
  } else {
    if (inlined_style) {
      const attributes = [];
      if (options2.dev)
        attributes.push(" data-svelte");
      if (csp.style_needs_nonce)
        attributes.push(` nonce="${csp.nonce}"`);
      csp.add_style(inlined_style);
      head += `
	<style${attributes.join("")}>${inlined_style}</style>`;
    }
    head += Array.from(stylesheets).map((dep) => {
      const attributes = [
        'rel="stylesheet"',
        `href="${options2.prefix + dep}"`
      ];
      if (csp.style_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      if (styles.has(dep)) {
        attributes.push("disabled", 'media="(max-width: 0)"');
      }
      return `
	<link ${attributes.join(" ")}>`;
    }).join("");
    if (page_config.router || page_config.hydrate) {
      head += Array.from(modulepreloads).map((dep) => `
	<link rel="modulepreload" href="${options2.prefix + dep}">`).join("");
      const attributes = ['type="module"', `data-hydrate="${target}"`];
      csp.add_script(init_app);
      if (csp.script_needs_nonce) {
        attributes.push(`nonce="${csp.nonce}"`);
      }
      body += `
		<script ${attributes.join(" ")}>${init_app}<\/script>`;
      body += serialized_data.map(({ url, body: body2, response }) => render_json_payload_script({ type: "data", url, body: typeof body2 === "string" ? hash(body2) : void 0 }, response)).join("\n	");
      if (shadow_props) {
        body += render_json_payload_script({ type: "props" }, shadow_props);
      }
    }
    if (options2.service_worker) {
      csp.add_script(init_service_worker);
      head += `
				<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_service_worker}<\/script>`;
    }
  }
  if (state.prerender && !options2.amp) {
    const http_equiv = [];
    const csp_headers = csp.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (maxage) {
      http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${maxage}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  }
  const segments = event.url.pathname.slice(options2.paths.base.length).split("/").slice(2);
  const assets2 = options2.paths.assets || (segments.length > 0 ? segments.map(() => "..").join("/") : ".");
  const html = await resolve_opts.transformPage({
    html: options2.template({ head, body, assets: assets2, nonce: csp.nonce })
  });
  const headers = new Headers({
    "content-type": "text/html",
    etag: `"${hash(html)}"`
  });
  if (maxage) {
    headers.set("cache-control", `${is_private ? "private" : "public"}, max-age=${maxage}`);
  }
  if (!options2.floc) {
    headers.set("permissions-policy", "interest-cohort=()");
  }
  if (!state.prerender) {
    const csp_header = csp.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
  }
  return new Response(html, {
    status,
    headers
  });
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name, message, stack: stack2 } = error2;
    serialized = try_serialize(__spreadProps(__spreadValues({}, error2), { name, message, stack: stack2 }));
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base2, path2) {
  if (scheme.test(path2))
    return path2;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path2);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path2.slice(path_match[0].length).split("/") : path2.split("/");
  baseparts.pop();
  for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
    const part = pathparts[i2];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function is_root_relative(path2) {
  return path2[0] === "/" && path2[1] !== "/";
}
function normalize_path(path2, trailing_slash) {
  if (path2 === "/" || trailing_slash === "ignore")
    return path2;
  if (trailing_slash === "never") {
    return path2.endsWith("/") ? path2.slice(0, -1) : path2;
  } else if (trailing_slash === "always" && /\/[^./]+$/.test(path2)) {
    return path2 + "/";
  }
  return path2;
}
async function load_node({
  event,
  options: options2,
  state,
  route,
  node,
  $session,
  stuff,
  is_error,
  is_leaf,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const shadow = is_leaf ? await load_shadow_data(route, event, options2, !!state.prerender) : {};
  if (shadow.cookies) {
    set_cookie_headers.push(...shadow.cookies);
  }
  if (shadow.error) {
    loaded = {
      status: shadow.status,
      error: shadow.error
    };
  } else if (shadow.redirect) {
    loaded = {
      status: shadow.status,
      redirect: shadow.redirect
    };
  } else if (module2.load) {
    const load_input = {
      url: state.prerender ? create_prerendering_url_proxy(event.url) : event.url,
      params: event.params,
      props: shadow.body || {},
      routeId: event.routeId,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let requested;
        if (typeof resource === "string") {
          requested = resource;
        } else {
          requested = resource.url;
          opts = __spreadValues({
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity
          }, opts);
        }
        opts.headers = new Headers(opts.headers);
        for (const [key2, value2] of event.request.headers) {
          if (key2 !== "authorization" && key2 !== "cookie" && key2 !== "host" && key2 !== "if-none-match" && !opts.headers.has(key2)) {
            opts.headers.set(key2, value2);
          }
        }
        const resolved = resolve(event.url.pathname, requested.split("?")[0]);
        let response;
        let dependency;
        const prefix = options2.paths.assets || options2.paths.base;
        const filename = decodeURIComponent(resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = options2.manifest.assets.has(filename);
        const is_asset_html = options2.manifest.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file = is_asset ? filename : filename_html;
          if (options2.read) {
            const type2 = is_asset ? options2.manifest.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            response = new Response(options2.read(file), {
              headers: type2 ? { "content-type": type2 } : {}
            });
          } else {
            response = await fetch(`${event.url.origin}/${file}`, opts);
          }
        } else if (is_root_relative(resolved)) {
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie2 = event.request.headers.get("cookie");
            const authorization = event.request.headers.get("authorization");
            if (cookie2) {
              opts.headers.set("cookie", cookie2);
            }
            if (authorization && !opts.headers.has("authorization")) {
              opts.headers.set("authorization", authorization);
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          response = await respond(new Request(new URL(requested, event.url).href, opts), options2, {
            getClientAddress: state.getClientAddress,
            initiator: route,
            prerender: state.prerender
          });
          if (state.prerender) {
            dependency = { response, body: null };
            state.prerender.dependencies.set(resolved, dependency);
          }
        } else {
          if (resolved.startsWith("//")) {
            requested = event.url.protocol + requested;
          }
          if (`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) && opts.credentials !== "omit") {
            uses_credentials = true;
            const cookie2 = event.request.headers.get("cookie");
            if (cookie2)
              opts.headers.set("cookie", cookie2);
          }
          const external_request = new Request(requested, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        const proxy = new Proxy(response, {
          get(response2, key2, _receiver) {
            async function text() {
              const body = await response2.text();
              const headers = {};
              for (const [key3, value2] of response2.headers) {
                if (key3 === "set-cookie") {
                  set_cookie_headers = set_cookie_headers.concat(value2);
                } else if (key3 !== "etag") {
                  headers[key3] = value2;
                }
              }
              if (!opts.body || typeof opts.body === "string") {
                const status_number = Number(response2.status);
                if (isNaN(status_number)) {
                  throw new Error(`response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`);
                }
                fetched.push({
                  url: requested,
                  body: opts.body,
                  response: {
                    status: status_number,
                    statusText: response2.statusText,
                    headers,
                    body
                  }
                });
              }
              if (dependency) {
                dependency.body = body;
              }
              return body;
            }
            if (key2 === "arrayBuffer") {
              return async () => {
                const buffer = await response2.arrayBuffer();
                if (dependency) {
                  dependency.body = new Uint8Array(buffer);
                }
                return buffer;
              };
            }
            if (key2 === "text") {
              return text;
            }
            if (key2 === "json") {
              return async () => {
                return JSON.parse(await text());
              };
            }
            return Reflect.get(response2, key2, response2);
          }
        });
        return proxy;
      },
      stuff: __spreadValues({}, stuff)
    };
    if (options2.dev) {
      Object.defineProperty(load_input, "page", {
        get: () => {
          throw new Error("`page` in `load` functions has been replaced by `url` and `params`");
        }
      });
    }
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
    if (!loaded) {
      throw new Error(`load function must return a value${options2.dev ? ` (${node.entry})` : ""}`);
    }
    if (loaded.fallthrough) {
      throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
    }
  } else if (shadow.body) {
    loaded = {
      props: shadow.body
    };
  } else {
    loaded = {};
  }
  if (shadow.body && state.prerender) {
    const pathname = `${event.url.pathname.replace(/\/$/, "")}/__data.json`;
    const dependency = {
      response: new Response(void 0),
      body: JSON.stringify(shadow.body)
    };
    state.prerender.dependencies.set(pathname, dependency);
  }
  return {
    node,
    props: shadow.body,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
async function load_shadow_data(route, event, options2, prerender) {
  if (!route.shadow)
    return {};
  try {
    const mod2 = await route.shadow();
    if (prerender && (mod2.post || mod2.put || mod2.del || mod2.patch)) {
      throw new Error("Cannot prerender pages that have endpoints with mutative methods");
    }
    const method = normalize_request_method(event);
    const is_get = method === "head" || method === "get";
    const handler = method === "head" ? mod2.head || mod2.get : mod2[method];
    if (!handler && !is_get) {
      return {
        status: 405,
        error: new Error(`${method} method not allowed`)
      };
    }
    const data = {
      status: 200,
      cookies: [],
      body: {}
    };
    if (!is_get) {
      const result = await handler(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      data.status = status;
      add_cookies(data.cookies, headers);
      if (status >= 300 && status < 400) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = body;
    }
    const get2 = method === "head" && mod2.head || mod2.get;
    if (get2) {
      const result = await get2(event);
      if (result.fallthrough) {
        throw new Error("fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching");
      }
      const { status, headers, body } = validate_shadow_output(result);
      add_cookies(data.cookies, headers);
      data.status = status;
      if (status >= 400) {
        data.error = new Error("Failed to load data");
        return data;
      }
      if (status >= 300) {
        data.redirect = headers instanceof Headers ? headers.get("location") : headers.location;
        return data;
      }
      data.body = __spreadValues(__spreadValues({}, body), data.body);
    }
    return data;
  } catch (e3) {
    const error2 = coalesce_to_error(e3);
    options2.handle_error(error2, event);
    return {
      status: 500,
      error: error2
    };
  }
}
function add_cookies(target, headers) {
  const cookies = headers["set-cookie"];
  if (cookies) {
    if (Array.isArray(cookies)) {
      target.push(...cookies);
    } else {
      target.push(cookies);
    }
  }
}
function validate_shadow_output(result) {
  const { status = 200, body = {} } = result;
  let headers = result.headers || {};
  if (headers instanceof Headers) {
    if (headers.has("set-cookie")) {
      throw new Error("Endpoint request handler cannot use Headers interface with Set-Cookie headers");
    }
  } else {
    headers = lowercase_keys(headers);
  }
  if (!is_pojo(body)) {
    throw new Error("Body returned from endpoint request handler must be a plain object");
  }
  return { status, headers, body };
}
async function respond_with_error({
  event,
  options: options2,
  state,
  $session,
  status,
  error: error2,
  resolve_opts
}) {
  try {
    const default_layout = await options2.manifest._.nodes[0]();
    const default_error = await options2.manifest._.nodes[1]();
    const layout_loaded = await load_node({
      event,
      options: options2,
      state,
      route: null,
      node: default_layout,
      $session,
      stuff: {},
      is_error: false,
      is_leaf: false
    });
    const error_loaded = await load_node({
      event,
      options: options2,
      state,
      route: null,
      node: default_error,
      $session,
      stuff: layout_loaded ? layout_loaded.stuff : {},
      is_error: true,
      is_leaf: false,
      status,
      error: error2
    });
    return await render_response({
      options: options2,
      state,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router
      },
      stuff: error_loaded.stuff,
      status,
      error: error2,
      branch: [layout_loaded, error_loaded],
      event,
      resolve_opts
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, event);
    return new Response(error3.stack, {
      status: 500
    });
  }
}
async function respond$1(opts) {
  const { event, options: options2, state, $session, route, resolve_opts } = opts;
  let nodes;
  if (!resolve_opts.ssr) {
    return await render_response(__spreadProps(__spreadValues({}, opts), {
      branch: [],
      page_config: {
        hydrate: true,
        router: true
      },
      status: 200,
      error: null,
      event,
      stuff: {}
    }));
  }
  try {
    nodes = await Promise.all(route.a.map((n) => options2.manifest._.nodes[n] && options2.manifest._.nodes[n]()));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, event);
    return await respond_with_error({
      event,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3,
      resolve_opts
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (state.prerender) {
    const should_prerender = leaf.prerender ?? state.prerender.default;
    if (!should_prerender) {
      return new Response(void 0, {
        status: 204
      });
    }
  }
  let branch = [];
  let status = 200;
  let error2 = null;
  let set_cookie_headers = [];
  let stuff = {};
  ssr:
    if (resolve_opts.ssr) {
      for (let i2 = 0; i2 < nodes.length; i2 += 1) {
        const node = nodes[i2];
        let loaded;
        if (node) {
          try {
            loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
              node,
              stuff,
              is_error: false,
              is_leaf: i2 === nodes.length - 1
            }));
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies(new Response(void 0, {
                status: loaded.loaded.status,
                headers: {
                  location: loaded.loaded.redirect
                }
              }), set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e3 = coalesce_to_error(err);
            options2.handle_error(e3, event);
            status = 500;
            error2 = e3;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i2--) {
              if (route.b[i2]) {
                const error_node = await options2.manifest._.nodes[route.b[i2]]();
                let node_loaded;
                let j = i2;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node(__spreadProps(__spreadValues({}, opts), {
                    node: error_node,
                    stuff: node_loaded.stuff,
                    is_error: true,
                    is_leaf: false,
                    status,
                    error: error2
                  }));
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  stuff = __spreadValues(__spreadValues({}, node_loaded.stuff), error_loaded.stuff);
                  break ssr;
                } catch (err) {
                  const e3 = coalesce_to_error(err);
                  options2.handle_error(e3, event);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              event,
              options: options2,
              state,
              $session,
              status,
              error: error2,
              resolve_opts
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = __spreadValues(__spreadValues({}, stuff), loaded.loaded.stuff);
        }
      }
    }
  try {
    return with_cookies(await render_response(__spreadProps(__spreadValues({}, opts), {
      stuff,
      event,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    })), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, event);
    return with_cookies(await respond_with_error(__spreadProps(__spreadValues({}, opts), {
      status: 500,
      error: error3
    })), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  if ("ssr" in leaf) {
    throw new Error("`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle");
  }
  return {
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    set_cookie_headers.forEach((value2) => {
      response.headers.append("set-cookie", value2);
    });
  }
  return response;
}
async function render_page(event, route, options2, state, resolve_opts) {
  if (state.initiator === route) {
    return new Response(`Not found: ${event.url.pathname}`, {
      status: 404
    });
  }
  if (route.shadow) {
    const type2 = negotiate(event.request.headers.get("accept") || "text/html", [
      "text/html",
      "application/json"
    ]);
    if (type2 === "application/json") {
      return render_endpoint(event, await route.shadow());
    }
  }
  const $session = await options2.hooks.getSession(event);
  return respond$1({
    event,
    options: options2,
    state,
    $session,
    resolve_opts,
    route
  });
}
function negotiate(accept, types2) {
  const parts = accept.split(",").map((str, i2) => {
    const match2 = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match2) {
      const [, type2, subtype, q = "1"] = match2;
      return { type: type2, subtype, q: +q, i: i2 };
    }
    throw new Error(`Invalid Accept header: ${accept}`);
  }).sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types2) {
    const [type2, subtype] = mimetype.split("/");
    const priority = parts.findIndex((part) => (part.type === type2 || part.type === "*") && (part.subtype === subtype || part.subtype === "*"));
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function exec(match2, names, types2, matchers) {
  const params = {};
  for (let i2 = 0; i2 < names.length; i2 += 1) {
    const name = names[i2];
    const type2 = types2[i2];
    const value2 = match2[i2 + 1] || "";
    if (type2) {
      const matcher2 = matchers[type2];
      if (!matcher2)
        throw new Error(`Missing "${type2}" param matcher`);
      if (!matcher2(value2))
        return;
    }
    params[name] = value2;
  }
  return params;
}
var DATA_SUFFIX = "/__data.json";
var default_transform = ({ html }) => html;
async function respond(request, options2, state) {
  var _a5, _b, _c;
  let url = new URL(request.url);
  const normalized = normalize_path(url.pathname, options2.trailing_slash);
  if (normalized !== url.pathname && !((_a5 = state.prerender) == null ? void 0 : _a5.fallback)) {
    return new Response(void 0, {
      status: 301,
      headers: {
        location: (normalized.startsWith("//") ? url.origin + normalized : normalized) + (url.search === "?" ? "" : url.search)
      }
    });
  }
  const { parameter, allowed } = options2.method_override;
  const method_override = (_b = url.searchParams.get(parameter)) == null ? void 0 : _b.toUpperCase();
  if (method_override) {
    if (request.method === "POST") {
      if (allowed.includes(method_override)) {
        request = new Proxy(request, {
          get: (target, property2, _receiver) => {
            if (property2 === "method")
              return method_override;
            return Reflect.get(target, property2, target);
          }
        });
      } else {
        const verb = allowed.length === 0 ? "enabled" : "allowed";
        const body = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
        return new Response(body, {
          status: 400
        });
      }
    } else {
      throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
    }
  }
  let decoded = decodeURI(url.pathname);
  let route = null;
  let params = {};
  if (options2.paths.base && !((_c = state.prerender) == null ? void 0 : _c.fallback)) {
    if (!decoded.startsWith(options2.paths.base)) {
      return new Response(void 0, { status: 404 });
    }
    decoded = decoded.slice(options2.paths.base.length) || "/";
  }
  const is_data_request = decoded.endsWith(DATA_SUFFIX);
  if (is_data_request) {
    decoded = decoded.slice(0, -DATA_SUFFIX.length) || "/";
    const normalized2 = normalize_path(url.pathname.slice(0, -DATA_SUFFIX.length), options2.trailing_slash);
    url = new URL(url.origin + normalized2 + url.search);
  }
  if (!state.prerender || !state.prerender.fallback) {
    const matchers = await options2.manifest._.matchers();
    for (const candidate of options2.manifest._.routes) {
      const match2 = candidate.pattern.exec(decoded);
      if (!match2)
        continue;
      const matched = exec(match2, candidate.names, candidate.types, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  const event = {
    get clientAddress() {
      if (!state.getClientAddress) {
        throw new Error(`${"@sveltejs/adapter-vercel"} does not specify getClientAddress. Please raise an issue`);
      }
      Object.defineProperty(event, "clientAddress", {
        value: state.getClientAddress()
      });
      return event.clientAddress;
    },
    locals: {},
    params,
    platform: state.platform,
    request,
    routeId: route && route.id,
    url
  };
  const removed = (property2, replacement, suffix = "") => ({
    get: () => {
      throw new Error(`event.${property2} has been replaced by event.${replacement}` + suffix);
    }
  });
  const details = ". See https://github.com/sveltejs/kit/pull/3384 for details";
  const body_getter = {
    get: () => {
      throw new Error("To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`" + details);
    }
  };
  Object.defineProperties(event, {
    method: removed("method", "request.method", details),
    headers: removed("headers", "request.headers", details),
    origin: removed("origin", "url.origin"),
    path: removed("path", "url.pathname"),
    query: removed("query", "url.searchParams"),
    body: body_getter,
    rawBody: body_getter
  });
  let resolve_opts = {
    ssr: true,
    transformPage: default_transform
  };
  try {
    const response = await options2.hooks.handle({
      event,
      resolve: async (event2, opts) => {
        if (opts) {
          resolve_opts = {
            ssr: opts.ssr !== false,
            transformPage: opts.transformPage || default_transform
          };
        }
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            event: event2,
            options: options2,
            state,
            $session: await options2.hooks.getSession(event2),
            page_config: { router: true, hydrate: true },
            stuff: {},
            status: 200,
            error: null,
            branch: [],
            resolve_opts: __spreadProps(__spreadValues({}, resolve_opts), {
              ssr: false
            })
          });
        }
        if (route) {
          let response2;
          if (is_data_request && route.type === "page" && route.shadow) {
            response2 = await render_endpoint(event2, await route.shadow());
            if (request.headers.has("x-sveltekit-load")) {
              if (response2.status >= 300 && response2.status < 400) {
                const location2 = response2.headers.get("location");
                if (location2) {
                  const headers = new Headers(response2.headers);
                  headers.set("x-sveltekit-location", location2);
                  response2 = new Response(void 0, {
                    status: 204,
                    headers
                  });
                }
              }
            }
          } else {
            response2 = route.type === "endpoint" ? await render_endpoint(event2, await route.load()) : await render_page(event2, route, options2, state, resolve_opts);
          }
          if (response2) {
            if (response2.status === 200 && response2.headers.has("etag")) {
              let if_none_match_value = request.headers.get("if-none-match");
              if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
                if_none_match_value = if_none_match_value.substring(2);
              }
              const etag = response2.headers.get("etag");
              if (if_none_match_value === etag) {
                const headers = new Headers({ etag });
                for (const key2 of [
                  "cache-control",
                  "content-location",
                  "date",
                  "expires",
                  "vary"
                ]) {
                  const value2 = response2.headers.get(key2);
                  if (value2)
                    headers.set(key2, value2);
                }
                return new Response(void 0, {
                  status: 304,
                  headers
                });
              }
            }
            return response2;
          }
        }
        if (!state.initiator) {
          const $session = await options2.hooks.getSession(event2);
          return await respond_with_error({
            event: event2,
            options: options2,
            state,
            $session,
            status: 404,
            error: new Error(`Not found: ${event2.url.pathname}`),
            resolve_opts
          });
        }
        if (state.prerender) {
          return new Response("not found", { status: 404 });
        }
        return await fetch(request);
      },
      get request() {
        throw new Error("request in handle has been replaced with event" + details);
      }
    });
    if (response && !(response instanceof Response)) {
      throw new Error("handle must return a Response object" + details);
    }
    return response;
  } catch (e3) {
    const error2 = coalesce_to_error(e3);
    options2.handle_error(error2, event);
    try {
      const $session = await options2.hooks.getSession(event);
      return await respond_with_error({
        event,
        options: options2,
        state,
        $session,
        status: 500,
        error: error2,
        resolve_opts
      });
    } catch (e22) {
      const error3 = coalesce_to_error(e22);
      return new Response(options2.dev ? error3.stack : error3.message, {
        status: 500
      });
    }
  }
}
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
var template = ({ head, body, assets: assets2, nonce }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<meta name="description" content="Svelte demo app" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + "\n	</head>\n	<body>\n		<div>" + body + "</div>\n	</body>\n</html>\n";
var read = null;
set_paths({ "base": "", "assets": "" });
var Server = class {
  constructor(manifest2) {
    this.options = {
      amp: false,
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      dev: false,
      floc: false,
      get_stack: (error2) => String(error2),
      handle_error: (error2, event) => {
        this.options.hooks.handleError({
          error: error2,
          event,
          get request() {
            throw new Error("request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details");
          }
        });
        error2.stack = this.options.get_stack(error2);
      },
      hooks: null,
      hydrate: true,
      manifest: manifest2,
      method_override: { "parameter": "_method", "allowed": ["PATCH", "DELETE"] },
      paths: { base, assets },
      prefix: assets + "/_app/",
      prerender: true,
      read,
      root: Root,
      service_worker: null,
      router: true,
      template,
      template_contains_nonce: false,
      trailing_slash: "never"
    };
  }
  async respond(request, options2 = {}) {
    if (!(request instanceof Request)) {
      throw new Error("The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details");
    }
    if (!this.options.hooks) {
      const module2 = await Promise.resolve().then(() => (init_hooks_5b953b47(), hooks_5b953b47_exports));
      this.options.hooks = {
        getSession: module2.getSession || (() => ({})),
        handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
        handleError: module2.handleError || (({ error: error2 }) => console.error(error2.stack)),
        externalFetch: module2.externalFetch || fetch
      };
    }
    return respond(request, this.options, options2);
  }
};

// .svelte-kit/vercel-tmp/manifest.js
var manifest = {
  appDir: "_app",
  assets: /* @__PURE__ */ new Set(["favicon.png", "genome.png", "genome_expanded.png", "robots.txt", "svelte-welcome.png", "svelte-welcome.webp"]),
  mimeTypes: { ".png": "image/png", ".txt": "text/plain", ".webp": "image/webp" },
  _: {
    entry: { "file": "start-820e85ac.js", "js": ["start-820e85ac.js", "chunks/vendor-117ed6ab.js"], "css": [] },
    nodes: [
      () => Promise.resolve().then(() => (init__(), __exports)),
      () => Promise.resolve().then(() => (init__2(), __exports2)),
      () => Promise.resolve().then(() => (init__3(), __exports3))
    ],
    routes: [
      {
        type: "page",
        id: "dashboard",
        pattern: /^\/dashboard\/?$/,
        names: [],
        types: [],
        path: "/dashboard",
        shadow: null,
        a: [0, 2],
        b: [1]
      }
    ],
    matchers: async () => {
      return {};
    }
  }
};

// .svelte-kit/vercel-tmp/entry.js
var server = new Server(manifest);
var entry_default = async (req, res) => {
  let request;
  try {
    request = await getRequest(`https://${req.headers.host}`, req);
  } catch (err) {
    res.statusCode = err.status || 400;
    return res.end(err.reason || "Invalid request body");
  }
  setResponse(res, await server.respond(request, {
    getClientAddress() {
      return request.headers.get("x-forwarded-for");
    }
  }));
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
